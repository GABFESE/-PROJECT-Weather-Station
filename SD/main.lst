CCS PCH C Compiler, Version 5.059, 5967               17-feb.-20 00:09

               Filename:   E:\Trabajos U\ELECTIVA INSTRUMENTACION\PROYECTO\SD\main.lst

               ROM used:   19068 bytes (58%)
                           Largest free fragment is 13700
               RAM used:   610 (30%) at main() level
                           1047 (51%) worst case
               Stack used: 10 locations
               Stack size: 31

*
0000:  GOTO   4A06
.................... #include <main.h> 
.................... // SD card module connections 
.................... #define MMCSD_SPI_HW                // Use hardware SPI module 
.................... #define MMCSD_PIN_SELECT  PIN_C0 
.................... // End SD card module connections 
....................   
.................... #include <18F2550.h> 
.................... //////////// Standard Header file for the PIC18F2550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2550 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 2F,44
0016:  DATA 61,74
0018:  DATA 6F,73
001A:  DATA 2E,74
001C:  DATA 78,74
001E:  DATA 00,00
0020:  DATA 0D,0A
0022:  DATA 2D,2D
0024:  DATA 25,73
0026:  DATA 2D,2D
0028:  DATA 00,00
002A:  DATA 0D,0A
002C:  DATA 0D,0A
002E:  DATA 20,20
0030:  DATA 20,20
0032:  DATA 20,20
0034:  DATA 20,20
0036:  DATA 20,00
0038:  DATA 0D,0A
003A:  DATA 0D,0A
003C:  DATA 2D,2D
003E:  DATA 46,41
0040:  DATA 54,20
0042:  DATA 53,74
0044:  DATA 61,74
0046:  DATA 73,2D
0048:  DATA 2D,0D
004A:  DATA 0A,00
004C:  DATA 46,69
004E:  DATA 72,73
0050:  DATA 74,20
0052:  DATA 46,41
0054:  DATA 54,20
0056:  DATA 73,74
0058:  DATA 61,72
005A:  DATA 74,73
005C:  DATA 20,61
005E:  DATA 74,3A
0060:  DATA 20,30
0062:  DATA 78,25
0064:  DATA 6C,58
0066:  DATA 0D,0A
0068:  DATA 00,00
006A:  DATA 44,61
006C:  DATA 74,61
006E:  DATA 20,53
0070:  DATA 74,61
0072:  DATA 72,74
0074:  DATA 73,20
0076:  DATA 41,74
0078:  DATA 3A,20
007A:  DATA 30,78
007C:  DATA 25,6C
007E:  DATA 58,0D
0080:  DATA 0A,00
0082:  DATA 52,6F
0084:  DATA 6F,74
0086:  DATA 20,44
0088:  DATA 69,72
008A:  DATA 65,63
008C:  DATA 74,6F
008E:  DATA 72,79
0090:  DATA 20,49
0092:  DATA 73,20
0094:  DATA 41,74
0096:  DATA 3A,20
0098:  DATA 30,78
009A:  DATA 25,6C
009C:  DATA 58,0D
009E:  DATA 0A,00
00A0:  DATA 42,79
00A2:  DATA 74,65
00A4:  DATA 73,20
00A6:  DATA 50,65
00A8:  DATA 72,20
00AA:  DATA 43,6C
00AC:  DATA 75,73
00AE:  DATA 74,65
00B0:  DATA 72,3A
00B2:  DATA 20,30
00B4:  DATA 78,25
00B6:  DATA 6C,58
00B8:  DATA 0D,0A
00BA:  DATA 00,00
00BC:  DATA 0D,0A
00BE:  DATA 0D,0A
00C0:  DATA 2D,2D
00C2:  DATA 00,00
00C4:  DATA 20,49
00C6:  DATA 6E,66
00C8:  DATA 6F,2D
00CA:  DATA 2D,00
00CC:  DATA 0D,0A
00CE:  DATA 41,74
00D0:  DATA 74,72
00D2:  DATA 69,62
00D4:  DATA 75,74
00D6:  DATA 65,73
00D8:  DATA 3A,20
00DA:  DATA 30,78
00DC:  DATA 25,58
00DE:  DATA 00,00
00E0:  DATA 0D,0A
00E2:  DATA 43,72
00E4:  DATA 65,61
00E6:  DATA 74,65
00E8:  DATA 64,3A
00EA:  DATA 20,00
00EC:  DATA 0D,0A
00EE:  DATA 4D,6F
00F0:  DATA 64,69
00F2:  DATA 66,69
00F4:  DATA 65,64
00F6:  DATA 3A,20
00F8:  DATA 00,00
00FA:  DATA 0D,0A
00FC:  DATA 53,74
00FE:  DATA 61,72
0100:  DATA 74,69
0102:  DATA 6E,67
0104:  DATA 20,63
0106:  DATA 6C,75
0108:  DATA 73,74
010A:  DATA 65,72
010C:  DATA 3A,20
010E:  DATA 25,6C
0110:  DATA 58,00
0112:  DATA 0D,0A
0114:  DATA 53,74
0116:  DATA 61,72
0118:  DATA 74,69
011A:  DATA 6E,67
011C:  DATA 20,61
011E:  DATA 64,64
0120:  DATA 72,65
0122:  DATA 73,73
0124:  DATA 3A,20
0126:  DATA 25,6C
0128:  DATA 58,00
012A:  DATA 0D,0A
012C:  DATA 53,69
012E:  DATA 7A,65
0130:  DATA 3A,20
0132:  DATA 25,6C
0134:  DATA 75,20
0136:  DATA 42,79
0138:  DATA 74,65
013A:  DATA 73,0D
013C:  DATA 0A,00
013E:  DATA 0D,0A
0140:  DATA 0A,49
0142:  DATA 6E,69
0144:  DATA 74,69
0146:  DATA 61,6C
0148:  DATA 69,7A
014A:  DATA 65,20
014C:  DATA 46,41
014E:  DATA 54,20
0150:  DATA 6C,69
0152:  DATA 62,72
0154:  DATA 61,72
0156:  DATA 79,20
0158:  DATA 2E,2E
015A:  DATA 2E,20
015C:  DATA 00,00
015E:  DATA 45,72
0160:  DATA 72,6F
0162:  DATA 72,20
0164:  DATA 69,6E
0166:  DATA 69,74
0168:  DATA 69,61
016A:  DATA 6C,69
016C:  DATA 7A,69
016E:  DATA 6E,67
0170:  DATA 20,46
0172:  DATA 41,54
0174:  DATA 20,6C
0176:  DATA 69,62
0178:  DATA 72,61
017A:  DATA 72,79
017C:  DATA 21,0D
017E:  DATA 0A,00
0180:  DATA 46,41
0182:  DATA 54,20
0184:  DATA 4C,69
0186:  DATA 62,72
0188:  DATA 61,72
018A:  DATA 79,20
018C:  DATA 69,6E
018E:  DATA 69,74
0190:  DATA 69,61
0192:  DATA 6C,69
0194:  DATA 7A,65
0196:  DATA 64,20
0198:  DATA 2E,2E
019A:  DATA 2E,20
019C:  DATA 00,00
019E:  DATA 43,61
01A0:  DATA 72,64
01A2:  DATA 20,54
01A4:  DATA 79,70
01A6:  DATA 65,3A
01A8:  DATA 20,00
01AA:  DATA 4D,4D
01AC:  DATA 43,20
01AE:  DATA 0D,0A
01B0:  DATA 00,00
01B2:  DATA 53,44
01B4:  DATA 53,43
01B6:  DATA 20,0D
01B8:  DATA 0A,00
01BA:  DATA 53,44
01BC:  DATA 48,43
01BE:  DATA 20,0D
01C0:  DATA 0A,00
01C2:  DATA 43,72
01C4:  DATA 65,61
01C6:  DATA 74,65
01C8:  DATA 20,27
01CA:  DATA 44,61
01CC:  DATA 74,6F
01CE:  DATA 73,2E
01D0:  DATA 74,78
01D2:  DATA 74,27
01D4:  DATA 20,66
01D6:  DATA 69,6C
01D8:  DATA 65,20
01DA:  DATA 2D,2D
01DC:  DATA 2D,3E
01DE:  DATA 20,00
01E0:  DATA 4F,4B
01E2:  DATA 20,0D
01E4:  DATA 0A,00
01E6:  DATA 65,72
01E8:  DATA 72,6F
01EA:  DATA 72,20
01EC:  DATA 63,72
01EE:  DATA 65,61
01F0:  DATA 74,69
01F2:  DATA 6E,67
01F4:  DATA 20,66
01F6:  DATA 69,6C
01F8:  DATA 65,20
01FA:  DATA 0D,0A
01FC:  DATA 00,00
01FE:  DATA 65,6C
0200:  DATA 69,6D
0202:  DATA 69,6E
0204:  DATA 61,74
0206:  DATA 69,6E
0208:  DATA 67,20
020A:  DATA 27,44
020C:  DATA 61,74
020E:  DATA 6F,73
0210:  DATA 2E,74
0212:  DATA 78,74
0214:  DATA 27,20
0216:  DATA 66,69
0218:  DATA 6C,65
021A:  DATA 20,2D
021C:  DATA 2D,2D
021E:  DATA 3E,20
0220:  DATA 00,00
0222:  DATA 4F,4B
0224:  DATA 20,0D
0226:  DATA 0A,00
0228:  DATA 65,72
022A:  DATA 72,6F
022C:  DATA 72,20
022E:  DATA 65,6C
0230:  DATA 69,6D
0232:  DATA 69,6E
0234:  DATA 61,74
0236:  DATA 69,6E
0238:  DATA 67,20
023A:  DATA 66,69
023C:  DATA 6C,65
023E:  DATA 20,0D
0240:  DATA 0A,00
0242:  DATA 20,20
0244:  DATA 65,72
0246:  DATA 72,6F
0248:  DATA 72,20
024A:  DATA 6F,70
024C:  DATA 65,6E
024E:  DATA 69,6E
0250:  DATA 67,20
0252:  DATA 66,69
0254:  DATA 6C,65
0256:  DATA 20,0D
0258:  DATA 0A,00
025A:  DATA 20,20
025C:  DATA 77,72
025E:  DATA 69,74
0260:  DATA 69,6E
0262:  DATA 67,20
0264:  DATA 65,72
0266:  DATA 72,6F
0268:  DATA 72,20
026A:  DATA 0D,0A
026C:  DATA 00,00
026E:  DATA 20,2D
0270:  DATA 2D,2D
0272:  DATA 3E,20
0274:  DATA 77,72
0276:  DATA 69,74
0278:  DATA 69,6E
027A:  DATA 67,20
027C:  DATA 65,72
027E:  DATA 72,6F
0280:  DATA 72,20
0282:  DATA 0D,0A
0284:  DATA 00,00
0286:  DATA 20,20
0288:  DATA 63,6C
028A:  DATA 6F,73
028C:  DATA 69,6E
028E:  DATA 67,20
0290:  DATA 65,72
0292:  DATA 72,6F
0294:  DATA 72,20
0296:  DATA 0D,0A
0298:  DATA 00,00
029A:  DATA 52,65
029C:  DATA 61,64
029E:  DATA 69,6E
02A0:  DATA 67,20
02A2:  DATA 27,44
02A4:  DATA 61,74
02A6:  DATA 6F,73
02A8:  DATA 2E,74
02AA:  DATA 78,74
02AC:  DATA 27,20
02AE:  DATA 66,69
02B0:  DATA 6C,65
02B2:  DATA 3A,20
02B4:  DATA 0D,0A
02B6:  DATA 00,00
02B8:  DATA 0D,0A
02BA:  DATA 0A,00
*
0328:  TBLRD*+
032A:  MOVF   FF5,F
032C:  BZ    0346
032E:  MOVFF  FF6,294
0332:  MOVFF  FF7,295
0336:  MOVFF  FF5,296
033A:  RCALL  02E4
033C:  MOVFF  294,FF6
0340:  MOVFF  295,FF7
0344:  BRA    0328
0346:  RETURN 0
*
0B08:  MOVLB  2
0B0A:  MOVF   x83,W
0B0C:  MULWF  x85
0B0E:  MOVFF  FF3,01
0B12:  MOVFF  FF4,00
0B16:  MULWF  x86
0B18:  MOVF   FF3,W
0B1A:  ADDWF  00,F
0B1C:  MOVF   x84,W
0B1E:  MULWF  x85
0B20:  MOVF   FF3,W
0B22:  ADDWFC 00,W
0B24:  MOVWF  02
0B26:  MOVLB  0
0B28:  GOTO   0EBA (RETURN)
0B2C:  MOVLB  3
0B2E:  CLRF   xE2
0B30:  CLRF   xE3
0B32:  MOVLW  01
0B34:  MOVWF  xE4
0B36:  CLRF   FDA
0B38:  CLRF   FD9
0B3A:  MOVLW  03
0B3C:  MOVWF  xE7
0B3E:  MOVLW  DA
0B40:  MOVWF  xE6
0B42:  MOVLW  03
0B44:  MOVWF  FEA
0B46:  MOVLW  DE
0B48:  MOVWF  FE9
0B4A:  MOVFF  3E7,FE2
0B4E:  MOVFF  3E6,FE1
0B52:  MOVFF  3E4,3E5
0B56:  BCF    FD8.0
0B58:  MOVF   FE5,W
0B5A:  MULWF  FEE
0B5C:  MOVF   FF3,W
0B5E:  ADDWFC xE2,F
0B60:  MOVF   FF4,W
0B62:  ADDWFC xE3,F
0B64:  DECFSZ xE5,F
0B66:  BRA    0B56
0B68:  MOVFF  3E2,FDE
0B6C:  MOVFF  3E3,3E2
0B70:  CLRF   xE3
0B72:  BTFSC  FD8.0
0B74:  INCF   xE3,F
0B76:  INCF   xE6,F
0B78:  BTFSC  FD8.2
0B7A:  INCF   xE7,F
0B7C:  INCF   xE4,F
0B7E:  MOVF   xE4,W
0B80:  SUBLW  05
0B82:  BNZ   0B42
0B84:  MOVLB  0
0B86:  RETURN 0
*
11D4:  BTFSC  FD8.1
11D6:  BRA    11E0
11D8:  MOVLW  03
11DA:  MOVWF  FEA
11DC:  MOVLW  B0
11DE:  MOVWF  FE9
11E0:  CLRF   00
11E2:  CLRF   01
11E4:  CLRF   02
11E6:  CLRF   03
11E8:  MOVLB  3
11EA:  CLRF   xB0
11EC:  CLRF   xB1
11EE:  CLRF   xB2
11F0:  CLRF   xB3
11F2:  MOVF   xAF,W
11F4:  IORWF  xAE,W
11F6:  IORWF  xAD,W
11F8:  IORWF  xAC,W
11FA:  BZ    1254
11FC:  MOVLW  20
11FE:  MOVWF  xB4
1200:  BCF    FD8.0
1202:  RLCF   xA8,F
1204:  RLCF   xA9,F
1206:  RLCF   xAA,F
1208:  RLCF   xAB,F
120A:  RLCF   xB0,F
120C:  RLCF   xB1,F
120E:  RLCF   xB2,F
1210:  RLCF   xB3,F
1212:  MOVF   xAF,W
1214:  SUBWF  xB3,W
1216:  BNZ   1228
1218:  MOVF   xAE,W
121A:  SUBWF  xB2,W
121C:  BNZ   1228
121E:  MOVF   xAD,W
1220:  SUBWF  xB1,W
1222:  BNZ   1228
1224:  MOVF   xAC,W
1226:  SUBWF  xB0,W
1228:  BNC   1248
122A:  MOVF   xAC,W
122C:  SUBWF  xB0,F
122E:  MOVF   xAD,W
1230:  BTFSS  FD8.0
1232:  INCFSZ xAD,W
1234:  SUBWF  xB1,F
1236:  MOVF   xAE,W
1238:  BTFSS  FD8.0
123A:  INCFSZ xAE,W
123C:  SUBWF  xB2,F
123E:  MOVF   xAF,W
1240:  BTFSS  FD8.0
1242:  INCFSZ xAF,W
1244:  SUBWF  xB3,F
1246:  BSF    FD8.0
1248:  RLCF   00,F
124A:  RLCF   01,F
124C:  RLCF   02,F
124E:  RLCF   03,F
1250:  DECFSZ xB4,F
1252:  BRA    1200
1254:  MOVFF  3B0,FEF
1258:  MOVFF  3B1,FEC
125C:  MOVFF  3B2,FEC
1260:  MOVFF  3B3,FEC
1264:  MOVLB  0
1266:  RETURN 0
*
33F2:  MOVFF  223,FEA
33F6:  MOVFF  222,FE9
33FA:  MOVLB  3
33FC:  MOVFF  36E,FEF
3400:  INCF   FE9,F
3402:  BTFSC  FD8.2
3404:  INCF   FEA,F
3406:  CLRF   FEF
3408:  MOVLB  2
340A:  INCF   x22,F
340C:  BTFSC  FD8.2
340E:  INCF   x23,F
3410:  MOVLB  0
3412:  RETURN 0
3414:  MOVF   FE9,W
3416:  MOVLB  3
3418:  MOVWF  x66
341A:  MOVLW  3B
341C:  MOVWF  x6D
341E:  MOVLW  9A
3420:  MOVWF  x6C
3422:  MOVLW  CA
3424:  MOVWF  x6B
3426:  CLRF   x6A
3428:  MOVLW  0A
342A:  MOVWF  x68
342C:  BSF    FD8.1
342E:  MOVLW  03
3430:  MOVWF  FEA
3432:  MOVLW  62
3434:  MOVWF  FE9
3436:  MOVFF  365,3AB
343A:  MOVFF  364,3AA
343E:  MOVFF  363,3A9
3442:  MOVFF  362,3A8
3446:  MOVFF  36D,3AF
344A:  MOVFF  36C,3AE
344E:  MOVFF  36B,3AD
3452:  MOVFF  36A,3AC
3456:  MOVLB  0
3458:  CALL   11D4
345C:  MOVF   01,W
345E:  MOVF   00,F
3460:  BNZ   3488
3462:  MOVLB  3
3464:  MOVF   x68,W
3466:  XORLW  01
3468:  BTFSS  FD8.2
346A:  BRA    3470
346C:  MOVLB  0
346E:  BRA    3488
3470:  MOVF   x66,W
3472:  BZ    348C
3474:  ANDLW  0F
3476:  SUBWF  x68,W
3478:  BZ    347C
347A:  BC    349A
347C:  BTFSC  x66.7
347E:  BRA    349A
3480:  BTFSC  x66.6
3482:  BRA    348C
3484:  MOVLW  20
3486:  BRA    348E
3488:  MOVLB  3
348A:  CLRF   x66
348C:  MOVLW  30
348E:  ADDWF  00,F
3490:  MOVFF  00,36E
3494:  MOVLB  0
3496:  RCALL  33F2
3498:  MOVLB  3
349A:  BCF    FD8.1
349C:  MOVFF  36D,3AB
34A0:  MOVFF  36C,3AA
34A4:  MOVFF  36B,3A9
34A8:  MOVFF  36A,3A8
34AC:  CLRF   xAF
34AE:  CLRF   xAE
34B0:  CLRF   xAD
34B2:  MOVLW  0A
34B4:  MOVWF  xAC
34B6:  MOVLB  0
34B8:  CALL   11D4
34BC:  MOVFF  03,36D
34C0:  MOVFF  02,36C
34C4:  MOVFF  01,36B
34C8:  MOVFF  00,36A
34CC:  MOVLB  3
34CE:  DECFSZ x68,F
34D0:  BRA    342C
34D2:  MOVLB  0
34D4:  GOTO   3762 (RETURN)
*
3A9E:  MOVLB  3
3AA0:  MOVF   x2F,W
3AA2:  XORWF  x30,W
3AA4:  ANDLW  80
3AA6:  MOVWF  x32
3AA8:  BTFSS  x2F.7
3AAA:  BRA    3AB0
3AAC:  COMF   x2F,F
3AAE:  INCF   x2F,F
3AB0:  BTFSS  x30.7
3AB2:  BRA    3AB8
3AB4:  COMF   x30,F
3AB6:  INCF   x30,F
3AB8:  MOVF   x30,W
3ABA:  CLRF   01
3ABC:  SUBWF  x2F,W
3ABE:  BC    3AC6
3AC0:  MOVFF  32F,00
3AC4:  BRA    3ADE
3AC6:  CLRF   00
3AC8:  MOVLW  08
3ACA:  MOVWF  x31
3ACC:  RLCF   x2F,F
3ACE:  RLCF   00,F
3AD0:  MOVF   x30,W
3AD2:  SUBWF  00,W
3AD4:  BTFSC  FD8.0
3AD6:  MOVWF  00
3AD8:  RLCF   01,F
3ADA:  DECFSZ x31,F
3ADC:  BRA    3ACC
3ADE:  BTFSS  x32.7
3AE0:  BRA    3AE6
3AE2:  COMF   01,F
3AE4:  INCF   01,F
3AE6:  MOVLB  0
3AE8:  RETURN 0
*
40D8:  MOVLB  2
40DA:  MOVF   x97,W
40DC:  CLRF   01
40DE:  SUBWF  x96,W
40E0:  BC    40E8
40E2:  MOVFF  296,00
40E6:  BRA    4100
40E8:  CLRF   00
40EA:  MOVLW  08
40EC:  MOVWF  x98
40EE:  RLCF   x96,F
40F0:  RLCF   00,F
40F2:  MOVF   x97,W
40F4:  SUBWF  00,W
40F6:  BTFSC  FD8.0
40F8:  MOVWF  00
40FA:  RLCF   01,F
40FC:  DECFSZ x98,F
40FE:  BRA    40EE
4100:  MOVLB  0
4102:  RETURN 0
4104:  MOVF   01,W
4106:  MOVFF  294,296
410A:  MOVLW  64
410C:  MOVLB  2
410E:  MOVWF  x97
4110:  MOVLB  0
4112:  RCALL  40D8
4114:  MOVFF  00,294
4118:  MOVF   01,W
411A:  MOVLW  30
411C:  BNZ   412E
411E:  MOVLB  2
4120:  BTFSS  x95.1
4122:  BRA    4144
4124:  BTFSC  x95.3
4126:  BRA    4144
4128:  BTFSC  x95.4
412A:  MOVLW  20
412C:  BRA    4136
412E:  MOVLB  2
4130:  BCF    x95.3
4132:  BCF    x95.4
4134:  BSF    x95.0
4136:  ADDWF  01,F
4138:  MOVFF  01,36E
413C:  MOVLB  0
413E:  CALL   33F2
4142:  MOVLB  2
4144:  MOVFF  294,296
4148:  MOVLW  0A
414A:  MOVWF  x97
414C:  MOVLB  0
414E:  RCALL  40D8
4150:  MOVFF  00,294
4154:  MOVF   01,W
4156:  MOVLW  30
4158:  BNZ   416A
415A:  MOVLB  2
415C:  BTFSC  x95.3
415E:  BRA    4176
4160:  BTFSS  x95.0
4162:  BRA    4176
4164:  BTFSC  x95.4
4166:  MOVLW  20
4168:  MOVLB  0
416A:  ADDWF  01,F
416C:  MOVFF  01,36E
4170:  CALL   33F2
4174:  MOVLB  2
4176:  MOVLW  30
4178:  ADDWF  x94,F
417A:  MOVFF  294,36E
417E:  MOVLB  0
4180:  CALL   33F2
4184:  GOTO   4214 (RETURN)
*
41D6:  MOVF   FEF,F
41D8:  BZ    41FA
41DA:  MOVFF  FEA,295
41DE:  MOVFF  FE9,294
41E2:  MOVFF  FEF,296
41E6:  CALL   02E4
41EA:  MOVFF  295,FEA
41EE:  MOVFF  294,FE9
41F2:  INCF   FE9,F
41F4:  BTFSC  FD8.2
41F6:  INCF   FEA,F
41F8:  BRA    41D6
41FA:  GOTO   4238 (RETURN)
....................  
.................... #list 
....................  
.................... #device PASS_STRINGS = IN_RAM 
.................... #fuses HSPLL, PLL2, CPUDIV1 
.................... #use delay(internal = 8MHz) 
*
02BC:  MOVLW  02
02BE:  MOVWF  FEA
02C0:  MOVLW  89
02C2:  MOVWF  FE9
02C4:  MOVF   FEF,W
02C6:  BZ    02E2
02C8:  MOVLW  02
02CA:  MOVWF  01
02CC:  CLRF   00
02CE:  DECFSZ 00,F
02D0:  BRA    02CE
02D2:  DECFSZ 01,F
02D4:  BRA    02CC
02D6:  MOVLW  97
02D8:  MOVWF  00
02DA:  DECFSZ 00,F
02DC:  BRA    02DA
02DE:  DECFSZ FEF,F
02E0:  BRA    02C8
02E2:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_A3, rcv=PIN_A4)    // Initialize software UART 
02E4:  BCF    F92.3
02E6:  BCF    F89.3
02E8:  MOVLW  08
02EA:  MOVWF  01
02EC:  BRA    02EE
02EE:  NOP   
02F0:  BSF    01.7
02F2:  BRA    0314
02F4:  BCF    01.7
02F6:  MOVLB  2
02F8:  RRCF   x96,F
02FA:  MOVLB  0
02FC:  BTFSC  FD8.0
02FE:  BSF    F89.3
0300:  BTFSS  FD8.0
0302:  BCF    F89.3
0304:  BSF    01.6
0306:  BRA    0314
0308:  BCF    01.6
030A:  DECFSZ 01,F
030C:  BRA    02F6
030E:  BRA    0310
0310:  NOP   
0312:  BSF    F89.3
0314:  MOVLW  3F
0316:  MOVWF  FE9
0318:  DECFSZ FE9,F
031A:  BRA    0318
031C:  NOP   
031E:  BTFSC  01.7
0320:  BRA    02F4
0322:  BTFSC  01.6
0324:  BRA    0308
0326:  RETURN 0
.................... #use fast_io(C) 
....................  
.................... #include <SD.c> 
.................... // Include MMC/SD card driver source file 
.................... #include <mmcsd_m.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           mmcsd_m.c                             //// 
.................... ////                                                                 //// 
.................... ////   This driver is a modified version of CCS C compiler mmcsd.c   //// 
.................... ////   file, now it supports all types of cards: MMC, SD and SDHC.   //// 
.................... ////                                                                 //// 
.................... ////               https://simple-circuit.com/                       //// 
.................... ////               contact@simple-circuit.com                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////    This is a low-level driver for MMC and SD cards.             //// 
.................... ////                                                                 //// 
.................... //// --User Functions--                                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_init(): Initializes the media.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_byte(a, p)                                           //// 
.................... ////  Reads a byte from the MMC/SD card at location a, saves to      //// 
.................... ////  pointer p.  Returns 0 if OK, non-zero if error.                //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_data(a, n, p)                                        //// 
.................... ////  Reads n bytes of data from the MMC/SD card starting at address //// 
.................... ////  a, saves result to pointer p.  Returns 0 if OK, non-zero if    //// 
.................... ////  error.                                                         //// 
.................... ////                                                                 //// 
.................... //// mmcsd_flush_buffer()                                            //// 
.................... ////  The two user write functions (mmcsd_write_byte() and           //// 
.................... ////  mmcsd_write_data()) maintain a buffer to speed up the writing  //// 
.................... ////  process.  Whenever a read or write is performed, the write     //// 
.................... ////  buffer is loaded with the specified page and only the          //// 
.................... ////  contents of this buffer is changed.  If any future writes      //// 
.................... ////  cross a page boundary then the buffer in RAM is written        //// 
.................... ////  to the MMC/SD and then the next page is loaded into the        //// 
.................... ////  buffer.  mmcsd_flush_buffer() forces the contents in RAM       //// 
.................... ////  to the MMC/SD card.  Returns 0 if OK, non-zero if errror.      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_byte(a, d)                                          //// 
.................... ////  Writes data byte d to the MMC/SD address a.  Intelligently     //// 
.................... ////  manages a write buffer, therefore you may need to call         //// 
.................... ////  mmcsd_flush_buffer() to flush the buffer.                      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_data(a, n, p)                                       //// 
.................... ////  Writes n bytes of data from pointer p to the MMC/SD card       //// 
.................... ////  starting at address a.  This function intelligently manages    //// 
.................... ////  a write buffer, therefore if you may need to call              //// 
.................... ////  mmcsd_flush_buffer() to flush any buffered characters.         //// 
.................... ////  returns 0 if OK, non-zero if error.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_block(a, s, p)                                       //// 
.................... ////  Reads an entire page from the SD/MMC.  Keep in mind that the   //// 
.................... ////  start of the read has to be aligned to a block                 //// 
.................... ////  (Address % 512 = 0).  Therefore s must be evenly divisible by  //// 
.................... ////  512.  At the application level it is much more effecient to    //// 
.................... ////  to use mmcsd_read_data() or mmcsd_read_byte().  Returns 0      //// 
.................... ////  if successful, non-zero if error.                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_block(a, s, p):                                     //// 
.................... ////  Writes an entire page to the SD/MMC.  This will write an       //// 
.................... ////  entire page to the SD/MMC, so the address and size must be     //// 
.................... ////  evenly  divisble by 512.  At the application level it is much  //// 
.................... ////  more effecient to use mmcsd_write_data() or mmcsd_write_byte().//// 
.................... ////  Returns 0 if successful, non-zero if error.                    //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_cid(): Displays all data in the Card Identification //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_csd(): Displays all data in the Card Specific Data  //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// --Non-User Functions--                                          //// 
.................... ////                                                                 //// 
.................... //// mmcsd_go_idle_state(): Sends the GO_IDLE_STATE command to the   //// 
.................... ////                        SD/MMC.                                  //// 
.................... //// mmcsd_send_op_cond(): Sends the SEND_OP_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_send_if_cond(): Sends the SEND_IF_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_sd_status(): Sends the SD_STATUS command to the SD. Note  //// 
.................... ////                     This command only works on SD cards.        //// 
.................... //// mmcsd_send_status(): Sends the SEND_STATUS command to the       //// 
.................... ////                       SD/MMC.                                   //// 
.................... //// mmcsd_set_blocklen(): Sends the SET_BLOCKLEN command along with //// 
.................... ////                        the desired block length.                //// 
.................... //// mmcsd_app_cmd(): Sends the APP_CMD command to the SD. This only //// 
.................... ////                   works on SD cards and is used just before any //// 
.................... ////                   SD-only command (e.g. send_op_cond()).        //// 
.................... //// mmcsd_read_ocr(): Sends the READ_OCR command to the SD/MMC.     //// 
.................... //// mmcsd_crc_on_off(): Sends the CRC_ON_OFF command to the SD/MMC  //// 
.................... ////                      along with a bit to turn the CRC on/off.   //// 
.................... //// mmcsd_send_cmd(): Sends a command and argument to the SD/MMC.   //// 
.................... //// mmcsd_get_r1(): Waits for an R1 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r2(): Waits for an R2 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r3(): Waits for an R3 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r7(): Waits for an R7 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_wait_for_token(): Waits for a specified token from the    //// 
.................... ////                          SD/MMC.                                //// 
.................... //// mmcsd_crc7(): Generates a CRC7 using a pointer to some data,    //// 
.................... ////                and how many bytes long the data is.             //// 
.................... //// mmcsd_crc16(): Generates a CRC16 using a pointer to some data,  //// 
.................... ////                and how many bytes long the data is.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MMCSD_C 
.................... #define MMCSD_C 
....................  
.................... ///////////////////// 
.................... ////             //// 
.................... //// User Config //// 
.................... ////             //// 
.................... ///////////////////// 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef MMCSD_SPI_HW 
....................   #use spi(MASTER, DI=MMCSD_PIN_MISO, DO=MMCSD_PIN_MOSI, CLK=MMCSD_PIN_SCK, BITS=8, MSB_FIRST, MODE=3, baud=400000) 
.................... #endif 
....................  
.................... //////////////////////// 
.................... ////                //// 
.................... //// Useful Defines //// 
.................... ////                //// 
.................... //////////////////////// 
....................  
.................... enum MMCSD_err 
....................    {MMCSD_GOODEC = 0, 
....................    MMCSD_IDLE = 0x01, 
....................    MMCSD_ERASE_RESET = 0x02, 
....................    MMCSD_ILLEGAL_CMD = 0x04, 
....................    MMCSD_CRC_ERR = 0x08, 
....................    MMCSD_ERASE_SEQ_ERR = 0x10, 
....................    MMCSD_ADDR_ERR = 0x20, 
....................    MMCSD_PARAM_ERR = 0x40, 
....................    RESP_TIMEOUT = 0x80}; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_OP_COND 1 
.................... #define SEND_IF_COND 8 
.................... #define SEND_CSD 9 
.................... #define SEND_CID 10 
.................... #define SD_STATUS 13 
.................... #define SEND_STATUS 13 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SD_SEND_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
.................... #define CRC_ON_OFF 59 
....................  
.................... #define IDLE_TOKEN 0x01 
.................... #define DATA_START_TOKEN 0xFE 
....................  
.................... #define MMCSD_MAX_BLOCK_SIZE 512 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... uint8_t g_mmcsd_buffer[MMCSD_MAX_BLOCK_SIZE]; 
....................  
.................... int1 g_CRC_enabled; 
.................... int1 g_MMCSDBufferChanged; 
....................  
.................... uint32_t g_mmcsdBufferAddress; 
....................  
.................... enum _card_type{MMC, SDSC, SDHC} g_card_type; 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init(); 
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_go_idle_state(void); 
.................... MMCSD_err mmcsd_send_op_cond(void); 
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]); 
.................... MMCSD_err mmcsd_print_csd(); 
.................... MMCSD_err mmcsd_print_cid(); 
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen); 
.................... MMCSD_err mmcsd_read_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_write_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_sd_send_op_cond(void); 
.................... MMCSD_err mmcsd_app_cmd(void); 
.................... MMCSD_err mmcsd_read_ocr(uint8_t* r1); 
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled); 
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg); 
.................... MMCSD_err mmcsd_get_r1(void); 
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]); 
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]); 
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]); 
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token); 
.................... uint8_t mmcsd_crc7(char *data, uint8_t length); 
.................... //uint16_t mmcsd_crc16(char *data, uint8_t length);  // Not needed --> commented 
.................... void mmcsd_select(); 
.................... void mmcsd_deselect(); 
....................  
.................... /// Fast Functions ! /// 
....................  
.................... MMCSD_err mmcsd_load_buffer(void); 
.................... MMCSD_err mmcsd_flush_buffer(void); 
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr); 
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data); 
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... int8 MMCSD_SPI_XFER(int8 spi_data) { 
....................   #ifdef MMCSD_SPI_HW 
....................     return SPI_Read(spi_data); 
*
034C:  MOVF   FC9,W
034E:  MOVFF  40F,FC9
0352:  RRCF   FC7,W
0354:  BNC   0352
0356:  MOVFF  FC9,01
....................   #else 
035A:  RETURN 0
....................     return spi_xfer(spi_data); 
....................   #endif 
.................... } 
....................  
.................... MMCSD_err mmcsd_init() 
.................... { 
....................    uint8_t 
....................       i, 
....................       r1, 
....................       r3[4]; 
....................  
....................    g_CRC_enabled = TRUE; 
*
06D8:  MOVLB  2
06DA:  BSF    x04.0
....................    g_mmcsdBufferAddress = 0; 
06DC:  CLRF   x08
06DE:  CLRF   x07
06E0:  CLRF   x06
06E2:  CLRF   x05
....................  
....................    output_drive(MMCSD_PIN_SELECT); 
06E4:  BCF    F94.0
....................  
....................   #ifdef MMCSD_SPI_HW 
....................     SETUP_SPI(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
06E6:  BCF    FC6.5
06E8:  BSF    F93.0
06EA:  BCF    F93.1
06EC:  MOVLW  32
06EE:  MOVWF  FC6
06F0:  MOVLW  00
06F2:  MOVWF  FC7
....................   #else   // Software SPI 
....................     output_drive(MMCSD_PIN_SCK); 
....................     output_drive(MMCSD_PIN_MOSI); 
....................     output_float(MMCSD_PIN_MISO); 
....................   #endif 
....................  
....................    mmcsd_deselect(); 
06F4:  MOVLB  0
06F6:  RCALL  0348
....................    delay_ms(250); 
06F8:  MOVLW  FA
06FA:  MOVLB  2
06FC:  MOVWF  x89
06FE:  MOVLB  0
0700:  RCALL  02BC
....................     for(i = 0; i < 10; i++)                        // Send 80 cycles 
0702:  MOVLB  2
0704:  CLRF   x83
0706:  MOVF   x83,W
0708:  SUBLW  09
070A:  BNC   071A
....................       MMCSD_SPI_XFER(0xFF); 
070C:  MOVLB  4
070E:  SETF   x0F
0710:  MOVLB  0
0712:  RCALL  034C
0714:  MOVLB  2
0716:  INCF   x83,F
0718:  BRA    0706
....................  
....................    /* begin initialization */ 
....................    i = 0; 
071A:  CLRF   x83
....................    do 
....................    { 
....................       delay_ms(1); 
071C:  MOVLW  01
071E:  MOVWF  x89
0720:  MOVLB  0
0722:  RCALL  02BC
....................       mmcsd_select(); 
0724:  RCALL  035C
....................       r1 = mmcsd_go_idle_state(); 
0726:  RCALL  044A
0728:  MOVFF  01,284
....................       mmcsd_deselect(); 
072C:  RCALL  0348
....................       i++; 
072E:  MOVLB  2
0730:  INCF   x83,F
....................       if(i == 0xFF) { 
0732:  INCFSZ x83,W
0734:  BRA    0748
....................          if (r1 == 0) 
0736:  MOVF   x84,F
0738:  BNZ   0742
....................            return 1; 
073A:  MOVLW  01
073C:  MOVWF  01
073E:  BRA    0870
0740:  BRA    0748
....................          else 
....................            return r1; 
0742:  MOVFF  284,01
0746:  BRA    0870
....................       } 
....................    } while(r1 != MMCSD_IDLE); 
0748:  DECFSZ x84,W
074A:  BRA    071C
....................  
....................    i = 0; 
074C:  CLRF   x83
....................    do 
....................    { 
....................       delay_ms(1); 
074E:  MOVLW  01
0750:  MOVWF  x89
0752:  MOVLB  0
0754:  RCALL  02BC
....................       mmcsd_select(); 
0756:  RCALL  035C
....................       r1 = mmcsd_send_op_cond(); 
0758:  BRA    0460
075A:  MOVFF  01,284
....................       mmcsd_deselect(); 
075E:  RCALL  0348
....................       i++; 
0760:  MOVLB  2
0762:  INCF   x83,F
....................    } while((r1 & MMCSD_IDLE) && i != 0xFF); 
0764:  BTFSS  x84.0
0766:  BRA    076C
0768:  INCFSZ x83,W
076A:  BRA    074E
....................    if(i == 0xFF) { 
076C:  INCFSZ x83,W
076E:  BRA    07B0
....................      delay_ms(100); 
0770:  MOVLW  64
0772:  MOVWF  x89
0774:  MOVLB  0
0776:  RCALL  02BC
....................      mmcsd_select(); 
0778:  RCALL  035C
....................      r1 = mmcsd_go_idle_state(); 
077A:  RCALL  044A
077C:  MOVFF  01,284
....................      mmcsd_deselect(); 
0780:  RCALL  0348
....................      delay_ms(100); 
0782:  MOVLW  64
0784:  MOVLB  2
0786:  MOVWF  x89
0788:  MOVLB  0
078A:  RCALL  02BC
....................      mmcsd_select(); 
078C:  RCALL  035C
....................      r1 = mmcsd_send_if_cond(r3); 
078E:  MOVLW  02
0790:  MOVLB  2
0792:  MOVWF  x8A
0794:  MOVLW  85
0796:  MOVWF  x89
0798:  MOVLB  0
079A:  BRA    04EC
079C:  MOVFF  01,284
....................      mmcsd_deselect(); 
07A0:  RCALL  0348
....................    if(r1 != MMCSD_IDLE) 
07A2:  MOVLB  2
07A4:  DECFSZ x84,W
07A6:  BRA    07AA
07A8:  BRA    07B0
....................      return r1; 
07AA:  MOVFF  284,01
07AE:  BRA    0870
....................    } 
....................  
....................    /* figure out if we have an SD or MMC */ 
....................    i = 0; 
07B0:  CLRF   x83
....................    do { 
....................      mmcsd_select(); 
07B2:  MOVLB  0
07B4:  RCALL  035C
....................      r1=mmcsd_app_cmd(); 
07B6:  BRA    0512
07B8:  MOVFF  01,284
....................      r1=mmcsd_sd_send_op_cond(); 
07BC:  BRA    052C
07BE:  MOVFF  01,284
....................      mmcsd_deselect(); 
07C2:  RCALL  0348
....................      delay_ms(100); 
07C4:  MOVLW  64
07C6:  MOVLB  2
07C8:  MOVWF  x89
07CA:  MOVLB  0
07CC:  RCALL  02BC
....................      i++; 
07CE:  MOVLB  2
07D0:  INCF   x83,F
....................    } while((r1 == MMCSD_IDLE) && (i != 0xFF)); 
07D2:  DECFSZ x84,W
07D4:  BRA    07DA
07D6:  INCFSZ x83,W
07D8:  BRA    07B2
....................    if(r1 == MMCSD_IDLE) 
07DA:  DECFSZ x84,W
07DC:  BRA    07E4
....................      return r1; 
07DE:  MOVFF  284,01
07E2:  BRA    0870
....................  
....................    /* an mmc will return an 0x04 here */ 
....................    if(r1 == 0x04) 
07E4:  MOVF   x84,W
07E6:  SUBLW  04
07E8:  BNZ   07EE
....................       g_card_type = MMC; 
07EA:  CLRF   x09
07EC:  BRA    081E
....................    else { 
....................       g_card_type = SDSC; 
07EE:  MOVLW  01
07F0:  MOVWF  x09
....................       mmcsd_select(); 
07F2:  MOVLB  0
07F4:  RCALL  035C
....................       r1 = mmcsd_read_ocr(r3); 
07F6:  MOVLW  02
07F8:  MOVLB  2
07FA:  MOVWF  x8A
07FC:  MOVLW  85
07FE:  MOVWF  x89
0800:  MOVLB  0
0802:  BRA    0558
0804:  MOVFF  01,284
....................       mmcsd_deselect(); 
0808:  RCALL  0348
....................       if(r1 != MMCSD_ILLEGAL_CMD) { 
080A:  MOVLB  2
080C:  MOVF   x84,W
080E:  SUBLW  04
0810:  BZ    081E
....................         r1 = r3[3]; 
0812:  MOVFF  288,284
....................         if(bit_test(r1, 6))                  // If bit 30 of the OCR register is 1 (CCS is 1) ==> SDHC type 
0816:  BTFSS  x84.6
0818:  BRA    081E
....................           g_card_type =  SDHC; 
081A:  MOVLW  02
081C:  MOVWF  x09
....................       } 
....................    } 
....................  
....................    /* set block length to 512 bytes */ 
....................    mmcsd_select(); 
081E:  MOVLB  0
0820:  RCALL  035C
....................    r1 = mmcsd_set_blocklen(MMCSD_MAX_BLOCK_SIZE); 
0822:  MOVLB  2
0824:  CLRF   x8C
0826:  CLRF   x8B
0828:  MOVLW  02
082A:  MOVWF  x8A
082C:  CLRF   x89
082E:  MOVLB  0
0830:  BRA    057A
0832:  MOVFF  01,284
....................    mmcsd_deselect(); 
0836:  RCALL  0348
....................    if(r1 != MMCSD_GOODEC) 
0838:  MOVLB  2
083A:  MOVF   x84,F
083C:  BZ    0844
....................      return r1; 
083E:  MOVFF  284,01
0842:  BRA    0870
....................  
.................... /// this would be a good time to set a higher clock speed, 20MHz 
.................... #ifdef MMCSD_SPI_HW 
....................   setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
0844:  BCF    FC6.5
0846:  BSF    F93.0
0848:  BCF    F93.1
084A:  MOVLW  30
084C:  MOVWF  FC6
084E:  MOVLW  00
0850:  MOVWF  FC7
.................... #else 
....................   #use spi(MASTER, DI=MMCSD_PIN_MISO, DO=MMCSD_PIN_MOSI, CLK=MMCSD_PIN_SCK, BITS=8, MODE=3) 
.................... #endif 
....................  
....................    // Turn OFF CRC check, some card return 0 (MMCSD_GOODEC) and some others return 0x04 (MMCSD_ILLEGAL_CMD) 
....................    mmcsd_select(); 
0852:  MOVLB  0
0854:  RCALL  035C
....................    r1 = mmcsd_crc_on_off(FALSE); 
0856:  MOVLB  2
0858:  CLRF   x89
085A:  MOVLB  0
085C:  BRA    059C
085E:  MOVFF  01,284
....................    mmcsd_deselect(); 
0862:  RCALL  0348
....................    r1 = mmcsd_load_buffer(); 
0864:  RCALL  06AE
0866:  MOVFF  01,284
....................  
....................    return MMCSD_GOODEC; 
086A:  MOVLW  00
086C:  MOVWF  01
086E:  MOVLB  2
0870:  MOVLB  0
0872:  GOTO   0B90 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err r1; 
....................    uint16_t i;  // counter for loops 
....................  
....................    for(i = 0; i < size; i++) 
*
0A80:  MOVLB  3
0A82:  CLRF   xC7
0A84:  CLRF   xC6
0A86:  MOVF   xC7,W
0A88:  SUBWF  xC2,W
0A8A:  BNC   0B00
0A8C:  BNZ   0A94
0A8E:  MOVF   xC1,W
0A90:  SUBWF  xC6,W
0A92:  BC    0B00
....................    { 
....................       r1 = mmcsd_read_byte(address++, ptr++); 
0A94:  MOVFF  3C0,3D1
0A98:  MOVFF  3BF,02
0A9C:  MOVFF  3BE,01
0AA0:  MOVFF  3BD,00
0AA4:  MOVLW  01
0AA6:  ADDWF  xBD,F
0AA8:  BTFSC  FD8.0
0AAA:  INCF   xBE,F
0AAC:  BTFSC  FD8.2
0AAE:  INCF   xBF,F
0AB0:  BTFSC  FD8.2
0AB2:  INCF   xC0,F
0AB4:  MOVFF  02,3CA
0AB8:  MOVFF  01,3C9
0ABC:  MOVFF  00,3C8
0AC0:  MOVFF  3C4,03
0AC4:  MOVF   xC3,W
0AC6:  INCF   xC3,F
0AC8:  BTFSC  FD8.2
0ACA:  INCF   xC4,F
0ACC:  MOVWF  xCC
0ACE:  MOVFF  03,3CD
0AD2:  MOVFF  02,3D0
0AD6:  MOVFF  01,3CF
0ADA:  MOVFF  00,3CE
0ADE:  MOVFF  03,3D3
0AE2:  MOVWF  xD2
0AE4:  MOVLB  0
0AE6:  BRA    0A2E
0AE8:  MOVFF  01,3C5
....................       if(r1 != MMCSD_GOODEC) 
0AEC:  MOVLB  3
0AEE:  MOVF   xC5,F
0AF0:  BZ    0AF8
....................          return r1; 
0AF2:  MOVFF  3C5,01
0AF6:  BRA    0B04
0AF8:  INCF   xC6,F
0AFA:  BTFSC  FD8.2
0AFC:  INCF   xC7,F
0AFE:  BRA    0A86
....................    } 
....................     
....................    return MMCSD_GOODEC; 
0B00:  MOVLW  00
0B02:  MOVWF  01
0B04:  MOVLB  0
0B06:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {   
....................    MMCSD_err ec; 
....................    uint16_t i; // counter for loops 
....................   
....................    // send command 
....................    mmcsd_select(); 
*
0602:  RCALL  035C
....................    ec = mmcsd_read_single_block(address); 
0604:  MOVFF  3F8,403
0608:  MOVFF  3F7,402
060C:  MOVFF  3F6,401
0610:  MOVFF  3F5,400
0614:  BRA    05C2
0616:  MOVFF  01,3FD
....................    if(ec != MMCSD_GOODEC) 
061A:  MOVLB  3
061C:  MOVF   xFD,F
061E:  BZ    062C
....................    { 
....................       mmcsd_deselect(); 
0620:  MOVLB  0
0622:  RCALL  0348
....................       return ec; 
0624:  MOVLB  3
0626:  MOVFF  3FD,01
062A:  BRA    06A8
....................    } 
....................     
....................    // wait for the data start token 
....................    ec = mmcsd_wait_for_token(DATA_START_TOKEN); 
062C:  MOVLW  FE
062E:  MOVLB  4
0630:  MOVWF  x00
0632:  MOVLB  0
0634:  BRA    05E4
0636:  MOVFF  01,3FD
....................    if(ec != MMCSD_GOODEC) 
063A:  MOVLB  3
063C:  MOVF   xFD,F
063E:  BZ    064C
....................    { 
....................       mmcsd_deselect(); 
0640:  MOVLB  0
0642:  RCALL  0348
....................       return ec; 
0644:  MOVLB  3
0646:  MOVFF  3FD,01
064A:  BRA    06A8
....................    } 
....................     
....................    // read in the data 
....................    for(i = 0; i < size; i += 1) 
064C:  CLRF   xFF
064E:  CLRF   xFE
0650:  MOVF   xFF,W
0652:  SUBWF  xFA,W
0654:  BNC   0690
0656:  BNZ   065E
0658:  MOVF   xF9,W
065A:  SUBWF  xFE,W
065C:  BC    0690
....................       ptr[i] = MMCSD_SPI_XFER(0xFF); 
065E:  MOVF   xFB,W
0660:  ADDWF  xFE,W
0662:  MOVWF  01
0664:  MOVF   xFC,W
0666:  ADDWFC xFF,W
0668:  MOVWF  03
066A:  MOVFF  01,400
066E:  MOVLB  4
0670:  MOVWF  x01
0672:  SETF   x0F
0674:  MOVLB  0
0676:  RCALL  034C
0678:  MOVFF  401,FEA
067C:  MOVFF  400,FE9
0680:  MOVFF  01,FEF
0684:  MOVLW  01
0686:  MOVLB  3
0688:  ADDWF  xFE,F
068A:  MOVLW  00
068C:  ADDWFC xFF,F
068E:  BRA    0650
....................  
....................  /*  if(g_CRC_enabled)   // already FALSE 
....................    { 
....................       // check the crc 
....................       if(make16(MMCSD_SPI_XFER(0xFF), MMCSD_SPI_XFER(0xFF)) != mmcsd_crc16(g_mmcsd_buffer, MMCSD_MAX_BLOCK_SIZE)) 
....................       { 
....................          mmcsd_deselect(); 
....................          return MMCSD_CRC_ERR; 
....................       } 
....................    } 
....................    else 
....................    { */ 
....................       /* have the card transmit the CRC, but ignore it */ 
....................       MMCSD_SPI_XFER(0xFF); 
0690:  MOVLB  4
0692:  SETF   x0F
0694:  MOVLB  0
0696:  RCALL  034C
....................       MMCSD_SPI_XFER(0xFF); 
0698:  MOVLB  4
069A:  SETF   x0F
069C:  MOVLB  0
069E:  RCALL  034C
.................... //   } 
....................    mmcsd_deselect(); 
06A0:  RCALL  0348
....................  
....................    return MMCSD_GOODEC; 
06A2:  MOVLW  00
06A4:  MOVWF  01
06A6:  MOVLB  3
06A8:  MOVLB  0
06AA:  GOTO   06D4 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err ec; 
....................    uint16_t i;  // counter for loops 
....................    
....................    for(i = 0; i < size; i++) 
*
198E:  MOVLB  3
1990:  CLRF   xE0
1992:  CLRF   xDF
1994:  MOVF   xE0,W
1996:  SUBWF  xDB,W
1998:  BNC   1A0C
199A:  BNZ   19A2
199C:  MOVF   xDA,W
199E:  SUBWF  xDF,W
19A0:  BC    1A0C
....................    { 
....................       ec = mmcsd_write_byte(address++, *ptr++); 
19A2:  MOVFF  3D9,3E9
19A6:  MOVFF  3D8,02
19AA:  MOVFF  3D7,01
19AE:  MOVFF  3D6,00
19B2:  MOVLW  01
19B4:  ADDWF  xD6,F
19B6:  BTFSC  FD8.0
19B8:  INCF   xD7,F
19BA:  BTFSC  FD8.2
19BC:  INCF   xD8,F
19BE:  BTFSC  FD8.2
19C0:  INCF   xD9,F
19C2:  MOVFF  02,3E3
19C6:  MOVFF  01,3E2
19CA:  MOVFF  00,3E1
19CE:  MOVFF  3DD,03
19D2:  MOVF   xDC,W
19D4:  INCF   xDC,F
19D6:  BTFSC  FD8.2
19D8:  INCF   xDD,F
19DA:  MOVWF  FE9
19DC:  MOVFF  03,FEA
19E0:  MOVFF  FEF,3EA
19E4:  MOVFF  02,3E8
19E8:  MOVFF  01,3E7
19EC:  MOVFF  00,3E6
19F0:  MOVLB  0
19F2:  BRA    1940
19F4:  MOVFF  01,3DE
....................       if(ec != MMCSD_GOODEC) 
19F8:  MOVLB  3
19FA:  MOVF   xDE,F
19FC:  BZ    1A04
....................          return ec; 
19FE:  MOVFF  3DE,01
1A02:  BRA    1A10
1A04:  INCF   xDF,F
1A06:  BTFSC  FD8.2
1A08:  INCF   xE0,F
1A0A:  BRA    1994
....................    } 
....................     
....................    return MMCSD_GOODEC; 
1A0C:  MOVLW  00
1A0E:  MOVWF  01
1A10:  MOVLB  0
1A12:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {  
....................    MMCSD_err ec; 
....................    uint16_t i; 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
0898:  RCALL  035C
....................    ec = mmcsd_write_single_block(address); 
089A:  MOVFF  3F8,403
089E:  MOVFF  3F7,402
08A2:  MOVFF  3F6,401
08A6:  MOVFF  3F5,400
08AA:  BRA    0876
08AC:  MOVFF  01,3FD
....................    if(ec != MMCSD_GOODEC) 
08B0:  MOVLB  3
08B2:  MOVF   xFD,F
08B4:  BZ    08C2
....................    { 
....................       mmcsd_deselect(); 
08B6:  MOVLB  0
08B8:  RCALL  0348
....................       return ec; 
08BA:  MOVLB  3
08BC:  MOVFF  3FD,01
08C0:  BRA    0944
....................    } 
....................     
....................    // send a data start token 
....................    MMCSD_SPI_XFER(DATA_START_TOKEN); 
08C2:  MOVLW  FE
08C4:  MOVLB  4
08C6:  MOVWF  x0F
08C8:  MOVLB  0
08CA:  RCALL  034C
....................     
....................    // send all the data 
....................    for(i = 0; i < size; i += 1) 
08CC:  MOVLB  3
08CE:  CLRF   xFF
08D0:  CLRF   xFE
08D2:  MOVF   xFF,W
08D4:  SUBWF  xFA,W
08D6:  BNC   0900
08D8:  BNZ   08E0
08DA:  MOVF   xF9,W
08DC:  SUBWF  xFE,W
08DE:  BC    0900
....................    { 
....................       MMCSD_SPI_XFER(ptr[i]); 
08E0:  MOVF   xFB,W
08E2:  ADDWF  xFE,W
08E4:  MOVWF  FE9
08E6:  MOVF   xFC,W
08E8:  ADDWFC xFF,W
08EA:  MOVWF  FEA
08EC:  MOVFF  FEF,40F
08F0:  MOVLB  0
08F2:  RCALL  034C
08F4:  MOVLW  01
08F6:  MOVLB  3
08F8:  ADDWF  xFE,F
08FA:  MOVLW  00
08FC:  ADDWFC xFF,F
08FE:  BRA    08D2
....................    } 
....................  
....................    // if the CRC is enabled we have to calculate it, otherwise just send an 0xFFFF 
.................... /*   if(g_CRC_enabled)   // already FALSE 
....................       MMCSD_SPI_XFER(mmcsd_crc16(ptr, size)); 
....................    else 
....................    {   */ 
....................       MMCSD_SPI_XFER(0xFF); 
0900:  MOVLB  4
0902:  SETF   x0F
0904:  MOVLB  0
0906:  RCALL  034C
....................       MMCSD_SPI_XFER(0xFF); 
0908:  MOVLB  4
090A:  SETF   x0F
090C:  MOVLB  0
090E:  RCALL  034C
.................... //   } 
....................     
....................    // get the error code back from the card; "data accepted" is 0bXXX00101 
....................    ec = mmcsd_get_r1(); 
0910:  RCALL  041C
0912:  MOVFF  01,3FD
....................    if(ec & 0x0A) 
0916:  MOVLB  3
0918:  MOVF   xFD,W
091A:  ANDLW  0A
091C:  BZ    092A
....................    { 
....................       mmcsd_deselect(); 
091E:  MOVLB  0
0920:  RCALL  0348
....................       return ec; 
0922:  MOVLB  3
0924:  MOVFF  3FD,01
0928:  BRA    0944
....................    } 
....................     
....................    // wait for the line to go back high, this indicates that the write is complete 
....................    while(MMCSD_SPI_XFER(0xFF) == 0); 
092A:  MOVLB  4
092C:  SETF   x0F
092E:  MOVLB  0
0930:  RCALL  034C
0932:  MOVF   01,F
0934:  BTFSS  FD8.2
0936:  BRA    093C
0938:  MOVLB  3
093A:  BRA    092A
....................    mmcsd_deselect(); 
093C:  RCALL  0348
....................  
....................    return MMCSD_GOODEC; 
093E:  MOVLW  00
0940:  MOVWF  01
0942:  MOVLB  3
0944:  MOVLB  0
0946:  GOTO   0974 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_go_idle_state(void) 
.................... { 
....................    mmcsd_send_cmd(GO_IDLE_STATE, 0); 
*
044A:  MOVLB  4
044C:  CLRF   x04
044E:  CLRF   x08
0450:  CLRF   x07
0452:  CLRF   x06
0454:  CLRF   x05
0456:  MOVLB  0
0458:  RCALL  03B4
....................     
....................    return mmcsd_get_r1(); 
045A:  RCALL  041C
045C:  MOVF   01,W
045E:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SEND_OP_COND, 0); 
0460:  MOVLW  01
0462:  MOVLB  4
0464:  MOVWF  x04
0466:  CLRF   x08
0468:  CLRF   x07
046A:  CLRF   x06
046C:  CLRF   x05
046E:  MOVLB  0
0470:  RCALL  03B4
....................     
....................    return mmcsd_get_r1(); 
0472:  RCALL  041C
0474:  MOVF   01,W
0476:  GOTO   075A (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_IF_COND, 0x1AA); 
*
04EC:  MOVLW  08
04EE:  MOVLB  4
04F0:  MOVWF  x04
04F2:  CLRF   x08
04F4:  CLRF   x07
04F6:  MOVLW  01
04F8:  MOVWF  x06
04FA:  MOVLW  AA
04FC:  MOVWF  x05
04FE:  MOVLB  0
0500:  RCALL  03B4
....................  
....................    return mmcsd_get_r7(r7); 
0502:  MOVFF  28A,28E
0506:  MOVFF  289,28D
050A:  RCALL  047A
050C:  MOVF   01,W
050E:  GOTO   079C (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_print_csd() 
.................... {   
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................  
....................    mmcsd_select();    
....................    mmcsd_send_cmd(SEND_CSD, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................  
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
.................... /* 
....................    printf("\r\nCSD_STRUCTURE: %X", (buf[0] & 0x0C) >> 2); 
....................    printf("\r\nTAAC: %X", buf[1]); 
....................    printf("\r\nNSAC: %X", buf[2]); 
....................    printf("\r\nTRAN_SPEED: %X", buf[3]); 
....................    printf("\r\nCCC: %lX", (make16(buf[4], buf[5]) & 0xFFF0) >> 4); 
....................    printf("\r\nREAD_BL_LEN: %X", buf[5] & 0x0F);    
....................    printf("\r\nREAD_BL_PARTIAL: %X", (buf[6] & 0x80) >> 7); 
....................    printf("\r\nWRITE_BLK_MISALIGN: %X", (buf[6] & 0x40) >> 6); 
....................    printf("\r\nREAD_BLK_MISALIGN: %X", (buf[6] & 0x20) >> 5); 
....................    printf("\r\nDSR_IMP: %X", (buf[6] & 0x10) >> 4); 
....................    printf("\r\nC_SIZE: %lX", (((buf[6] & 0x03) << 10) | (buf[7] << 2) | ((buf[8] & 0xC0) >> 6))); 
....................    printf("\r\nVDD_R_CURR_MIN: %X", (buf[8] & 0x38) >> 3); 
....................    printf("\r\nVDD_R_CURR_MAX: %X", buf[8] & 0x07); 
....................    printf("\r\nVDD_W_CURR_MIN: %X", (buf[9] & 0xE0) >> 5); 
....................    printf("\r\nVDD_W_CURR_MAX: %X", (buf[9] & 0x1C) >> 2); 
....................    printf("\r\nC_SIZE_MULT: %X", ((buf[9] & 0x03) << 1) | ((buf[10] & 0x80) >> 7)); 
....................    printf("\r\nERASE_BLK_EN: %X", (buf[10] & 0x40) >> 6); 
....................    printf("\r\nSECTOR_SIZE: %X", ((buf[10] & 0x3F) << 1) | ((buf[11] & 0x80) >> 7)); 
....................    printf("\r\nWP_GRP_SIZE: %X", buf[11] & 0x7F); 
....................    printf("\r\nWP_GRP_ENABLE: %X", (buf[12] & 0x80) >> 7); 
....................    printf("\r\nR2W_FACTOR: %X", (buf[12] & 0x1C) >> 2); 
....................    printf("\r\nWRITE_BL_LEN: %X", ((buf[12] & 0x03) << 2) | ((buf[13] & 0xC0) >> 6)); 
....................    printf("\r\nWRITE_BL_PARTIAL: %X", (buf[13] & 0x20) >> 5); 
....................    printf("\r\nFILE_FORMAT_GRP: %X", (buf[14] & 0x80) >> 7); 
....................    printf("\r\nCOPY: %X", (buf[14] & 0x40) >> 6); 
....................    printf("\r\nPERM_WRITE_PROTECT: %X", (buf[14] & 0x20) >> 5); 
....................    printf("\r\nTMP_WRITE_PROTECT: %X", (buf[14] & 0x10) >> 4); 
....................    printf("\r\nFILE_FORMAT: %X", (buf[14] & 0x0C) >> 2); 
....................    printf("\r\nCRC: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_cid() 
.................... { 
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................     
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SEND_CID, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
....................    /* 
....................    printf("\r\nManufacturer ID: %X", buf[0]); 
....................    printf("\r\nOEM/Application ID: %c%c", buf[1], buf[2]); 
....................    printf("\r\nOEM/Application ID: %c%c%c%c%c", buf[3], buf[4], buf[5], buf[6], buf[7]); 
....................    printf("\r\nProduct Revision: %X", buf[8]); 
....................    printf("\r\nSerial Number: %X%X%X%X", buf[9], buf[10], buf[11], buf[12]); 
....................    printf("\r\nManufacturer Date Code: %X%X", buf[13] & 0x0F, buf[14]); 
....................    printf("\r\nCRC-7 Checksum: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]) 
.................... { 
....................    uint8_t i; 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(APP_CMD, 0); 
....................    r2[0]=mmcsd_get_r1(); 
....................    mmcsd_deselect(); 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SD_STATUS, 0); 
....................  
....................    for(i = 0; i < 64; i++) 
....................       MMCSD_SPI_XFER(0xFF);       
....................  
....................    mmcsd_deselect(); 
....................  
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_STATUS, 0);    
....................     
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen) 
.................... { 
....................    mmcsd_send_cmd(SET_BLOCKLEN, blocklen); 
*
057A:  MOVLW  10
057C:  MOVLB  4
057E:  MOVWF  x04
0580:  MOVFF  28C,408
0584:  MOVFF  28B,407
0588:  MOVFF  28A,406
058C:  MOVFF  289,405
0590:  MOVLB  0
0592:  RCALL  03B4
....................     
....................    return mmcsd_get_r1(); 
0594:  RCALL  041C
0596:  MOVF   01,W
0598:  GOTO   0832 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(READ_SINGLE_BLOCK, address); 
*
05C2:  MOVLW  11
05C4:  MOVLB  4
05C6:  MOVWF  x04
05C8:  MOVFF  403,408
05CC:  MOVFF  402,407
05D0:  MOVFF  401,406
05D4:  MOVFF  400,405
05D8:  MOVLB  0
05DA:  RCALL  03B4
....................     
....................    return mmcsd_get_r1(); 
05DC:  RCALL  041C
05DE:  MOVF   01,W
05E0:  GOTO   0616 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(WRITE_BLOCK, address); 
*
0876:  MOVLW  18
0878:  MOVLB  4
087A:  MOVWF  x04
087C:  MOVFF  403,408
0880:  MOVFF  402,407
0884:  MOVFF  401,406
0888:  MOVFF  400,405
088C:  MOVLB  0
088E:  RCALL  03B4
....................    
....................    return mmcsd_get_r1(); 
0890:  RCALL  041C
0892:  MOVF   01,W
0894:  GOTO   08AC (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SD_SEND_OP_COND, 0x40000000); 
*
052C:  MOVLW  29
052E:  MOVLB  4
0530:  MOVWF  x04
0532:  MOVLW  40
0534:  MOVWF  x08
0536:  CLRF   x07
0538:  CLRF   x06
053A:  CLRF   x05
053C:  MOVLB  0
053E:  RCALL  03B4
....................     
....................    return mmcsd_get_r1(); 
0540:  RCALL  041C
0542:  MOVF   01,W
0544:  GOTO   07BE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_app_cmd(void) 
.................... { 
....................    mmcsd_send_cmd(APP_CMD, 0); 
*
0512:  MOVLW  37
0514:  MOVLB  4
0516:  MOVWF  x04
0518:  CLRF   x08
051A:  CLRF   x07
051C:  CLRF   x06
051E:  CLRF   x05
0520:  MOVLB  0
0522:  RCALL  03B4
....................     
....................    return mmcsd_get_r1(); 
0524:  RCALL  041C
0526:  MOVF   01,W
0528:  GOTO   07B8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_ocr(int r3[]) 
.................... { 
....................    mmcsd_send_cmd(READ_OCR, 0); 
*
0558:  MOVLW  3A
055A:  MOVLB  4
055C:  MOVWF  x04
055E:  CLRF   x08
0560:  CLRF   x07
0562:  CLRF   x06
0564:  CLRF   x05
0566:  MOVLB  0
0568:  RCALL  03B4
....................     
....................    return mmcsd_get_r3(r3); 
056A:  MOVFF  28A,28C
056E:  MOVFF  289,28B
0572:  BRA    0548
0574:  MOVF   01,W
0576:  GOTO   0804 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled) 
.................... { 
....................    mmcsd_send_cmd(CRC_ON_OFF, crc_enabled); 
*
059C:  MOVLW  3B
059E:  MOVLB  4
05A0:  MOVWF  x04
05A2:  CLRF   x08
05A4:  CLRF   x07
05A6:  CLRF   x06
05A8:  MOVFF  289,405
05AC:  MOVLB  0
05AE:  RCALL  03B4
....................     
....................    g_CRC_enabled = crc_enabled; 
05B0:  MOVLB  2
05B2:  BCF    x04.0
05B4:  BTFSC  x89.0
05B6:  BSF    x04.0
....................     
....................    return mmcsd_get_r1(); 
05B8:  MOVLB  0
05BA:  RCALL  041C
05BC:  MOVF   01,W
05BE:  GOTO   085E (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg) 
.................... {    
....................    uint8_t packet[6]; // the entire command, argument, and crc in one variable 
....................  
....................    // construct the packet 
....................    // every command on an SD card is or'ed with 0x40 
....................    packet[0] = cmd | 0x40; 
*
03B4:  MOVLB  4
03B6:  MOVF   x04,W
03B8:  IORLW  40
03BA:  MOVWF  x09
....................    packet[1] = make8(arg, 3); 
03BC:  MOVFF  408,40A
....................    packet[2] = make8(arg, 2); 
03C0:  MOVFF  407,40B
....................    packet[3] = make8(arg, 1); 
03C4:  MOVFF  406,40C
....................    packet[4] = make8(arg, 0); 
03C8:  MOVFF  405,40D
....................  
....................    // calculate the crc if needed 
....................    if(g_CRC_enabled) 
03CC:  MOVLB  2
03CE:  BTFSS  x04.0
03D0:  BRA    03EC
....................       packet[5] = mmcsd_crc7(packet, 5); 
03D2:  MOVLW  04
03D4:  MOVLB  4
03D6:  MOVWF  x10
03D8:  MOVLW  09
03DA:  MOVWF  x0F
03DC:  MOVLW  05
03DE:  MOVWF  x11
03E0:  MOVLB  0
03E2:  BRA    0360
03E4:  MOVFF  01,40E
03E8:  BRA    03F2
03EA:  MOVLB  2
....................    else 
....................       packet[5] = 0xFF; 
03EC:  MOVLB  4
03EE:  SETF   x0E
03F0:  MOVLB  0
....................  
....................    // transfer the command and argument, with an extra 0xFF hacked in there 
....................    MMCSD_SPI_XFER(packet[0]); 
03F2:  MOVFF  409,40F
03F6:  RCALL  034C
....................    MMCSD_SPI_XFER(packet[1]); 
03F8:  MOVFF  40A,40F
03FC:  RCALL  034C
....................    MMCSD_SPI_XFER(packet[2]); 
03FE:  MOVFF  40B,40F
0402:  RCALL  034C
....................    MMCSD_SPI_XFER(packet[3]); 
0404:  MOVFF  40C,40F
0408:  RCALL  034C
....................    MMCSD_SPI_XFER(packet[4]); 
040A:  MOVFF  40D,40F
040E:  RCALL  034C
....................    MMCSD_SPI_XFER(packet[5]); 
0410:  MOVFF  40E,40F
0414:  RCALL  034C
.................... //!   spi_write2(packet[0]); 
.................... //!   spi_write2(packet[1]); 
.................... //!   spi_write2(packet[2]); 
.................... //!   spi_write2(packet[3]); 
.................... //!   spi_write2(packet[4]); 
.................... //!   spi_write2(packet[5]); 
....................     
....................  
....................    return MMCSD_GOODEC; 
0416:  MOVLW  00
0418:  MOVWF  01
041A:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r1(void) 
041C:  MOVLB  4
041E:  CLRF   x04
0420:  SETF   x05
.................... { 
....................    uint8_t 
....................       response = 0,  // place to hold the response coming back from the SPI line 
....................       timeout = 0xFF; // maximum amount loops to wait for idle before getting impatient and leaving the function with an error code 
....................      
....................    // loop until timeout == 0 
....................    while(timeout) 
0422:  MOVF   x05,F
0424:  BZ    0442
....................    { 
....................       // read what's on the SPI line 
....................       //  the SD/MMC requires that you leave the line high when you're waiting for data from it 
....................       response = MMCSD_SPI_XFER(0xFF); 
0426:  SETF   x0F
0428:  MOVLB  0
042A:  RCALL  034C
042C:  MOVFF  01,404
....................       //response = MMCSD_SPI_XFER(0x00);//leave the line idle 
....................        
....................       // check to see if we got a response 
....................       if(response != 0xFF) 
0430:  MOVLB  4
0432:  INCFSZ x04,W
0434:  BRA    0438
0436:  BRA    043E
....................       {    
....................          // fill in the response that we got and leave the function 
....................          return response; 
0438:  MOVFF  404,01
043C:  BRA    0446
....................       } 
....................  
....................       // wait for a little bit longer 
....................       timeout--; 
043E:  DECF   x05,F
0440:  BRA    0422
....................    } 
....................     
....................    // for some reason, we didn't get a response back from the card 
....................    //  return the proper error codes 
....................    return RESP_TIMEOUT; 
0442:  MOVLW  80
0444:  MOVWF  01
0446:  MOVLB  0
0448:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]) 
.................... { 
....................    r2[1] = mmcsd_get_r1(); 
....................     
....................    r2[0] = MMCSD_SPI_XFER(0xFF); 
....................     
....................    return 0; 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]) 
.................... { 
....................    return mmcsd_get_r7(r3); 
*
0548:  MOVFF  28C,28E
054C:  MOVFF  28B,28D
0550:  RCALL  047A
0552:  MOVF   01,W
0554:  GOTO   0574 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]) 
.................... { 
....................    uint8_t i;   // counter for loop 
....................     
....................    // the top byte of r7 is r1 
....................    r7[4]=mmcsd_get_r1(); 
*
047A:  MOVLW  04
047C:  MOVLB  2
047E:  ADDWF  x8D,W
0480:  MOVWF  01
0482:  MOVLW  00
0484:  ADDWFC x8E,W
0486:  MOVWF  03
0488:  MOVFF  01,290
048C:  MOVWF  x91
048E:  MOVLB  0
0490:  RCALL  041C
0492:  MOVFF  291,FEA
0496:  MOVFF  290,FE9
049A:  MOVFF  01,FEF
....................     
....................    // fill in the other 4 bytes 
....................    for(i = 0; i < 4; i++) 
049E:  MOVLB  2
04A0:  CLRF   x8F
04A2:  MOVF   x8F,W
04A4:  SUBLW  03
04A6:  BNC   04D8
....................       r7[3 - i] = MMCSD_SPI_XFER(0xFF); 
04A8:  MOVLW  03
04AA:  BSF    FD8.0
04AC:  SUBFWB x8F,W
04AE:  ADDWF  x8D,W
04B0:  MOVWF  01
04B2:  MOVLW  00
04B4:  ADDWFC x8E,W
04B6:  MOVWF  03
04B8:  MOVFF  01,290
04BC:  MOVWF  x91
04BE:  MOVLB  4
04C0:  SETF   x0F
04C2:  MOVLB  0
04C4:  RCALL  034C
04C6:  MOVFF  291,FEA
04CA:  MOVFF  290,FE9
04CE:  MOVFF  01,FEF
04D2:  MOVLB  2
04D4:  INCF   x8F,F
04D6:  BRA    04A2
....................  
....................    return r7[4]; 
04D8:  MOVLW  04
04DA:  ADDWF  x8D,W
04DC:  MOVWF  FE9
04DE:  MOVLW  00
04E0:  ADDWFC x8E,W
04E2:  MOVWF  FEA
04E4:  MOVFF  FEF,01
04E8:  MOVLB  0
04EA:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token) 
.................... { 
....................    MMCSD_err r1; 
....................     
....................    // get a token 
....................    r1 = mmcsd_get_r1(); 
*
05E4:  RCALL  041C
05E6:  MOVFF  01,401
....................     
....................    // check to see if the token we recieved was the one that we were looking for 
....................    if(r1 == token) 
05EA:  MOVLB  4
05EC:  MOVF   x00,W
05EE:  SUBWF  x01,W
05F0:  BNZ   05F8
....................       return MMCSD_GOODEC; 
05F2:  MOVLW  00
05F4:  MOVWF  01
05F6:  BRA    05FC
....................     
....................    // if that wasn't right, return the error 
....................    return r1;    
05F8:  MOVFF  401,01
05FC:  MOVLB  0
05FE:  GOTO   0636 (RETURN)
.................... } 
....................  
.................... unsigned int8 mmcsd_crc7(char *data,uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c, crc; 
....................      
....................    crc = 0x00;                                                                // Set initial value 
*
0360:  MOVLB  4
0362:  CLRF   x15
....................  
....................    for (i = 0; i < length; i++, data++) 
0364:  CLRF   x12
0366:  MOVF   x11,W
0368:  SUBWF  x12,W
036A:  BC    03A6
....................    { 
....................       c = *data; 
036C:  MOVFF  40F,FE9
0370:  MOVFF  410,FEA
0374:  MOVFF  FEF,414
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
0378:  CLRF   x13
037A:  MOVF   x13,W
037C:  SUBLW  07
037E:  BNC   0398
....................       { 
....................          crc = crc << 1; 
0380:  BCF    FD8.0
0382:  RLCF   x15,F
....................          if ((c ^ crc) & 0x80) crc = crc ^ 0x09;                              // ^ is XOR 
0384:  MOVF   x14,W
0386:  XORWF  x15,W
0388:  ANDLW  80
038A:  BZ    0390
038C:  MOVLW  09
038E:  XORWF  x15,F
....................          c = c << 1; 
0390:  BCF    FD8.0
0392:  RLCF   x14,F
0394:  INCF   x13,F
0396:  BRA    037A
....................       } 
....................  
....................        crc = crc & 0x7F; 
0398:  BCF    x15.7
039A:  MOVF   x12,W
039C:  INCF   x12,F
039E:  INCF   x0F,F
03A0:  BTFSC  FD8.2
03A2:  INCF   x10,F
03A4:  BRA    0366
....................    } 
....................  
....................    shift_left(&crc, 1, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
03A6:  BSF    FD8.0
03A8:  RLCF   x15,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
03AA:  MOVFF  415,01
03AE:  MOVLB  0
03B0:  GOTO   03E4 (RETURN)
.................... } 
....................  
.................... /* Not needed function (CRC is OFF) 
.................... uint16_t mmcsd_crc16(char *data, uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c; 
....................  
....................    uint16_t crc; 
....................  
....................    crc = 0x0000;                                                                // Set initial value 
....................  
....................    for (i = 0; i < length; i++, data++) 
....................    { 
....................       c = *data; 
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
....................       { 
....................          crc = crc << 1; 
....................          if ((c ^ crc) & 0x8000) crc = crc ^ 0x1021;                              // ^ is XOR 
....................          c = c << 1; 
....................       } 
....................  
....................        crc = crc & 0x7FFF; 
....................    } 
....................  
....................    shift_left(&crc, 2, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
.................... } 
.................... */ 
....................  
.................... void mmcsd_select() 
.................... { 
....................    output_low(MMCSD_PIN_SELECT); 
*
035C:  BCF    F8B.0
035E:  RETURN 0
.................... } 
....................  
.................... void mmcsd_deselect() 
.................... { 
....................    //MMCSD_SPI_XFER(0xFF); 
....................    output_high(MMCSD_PIN_SELECT); 
*
0348:  BSF    F8B.0
034A:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_load_buffer(void) 
.................... { 
....................    g_MMCSDBufferChanged = FALSE; 
*
06AE:  MOVLB  2
06B0:  BCF    x04.1
....................    return(mmcsd_read_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
06B2:  MOVFF  208,3F8
06B6:  MOVFF  207,3F7
06BA:  MOVFF  206,3F6
06BE:  MOVFF  205,3F5
06C2:  MOVLW  02
06C4:  MOVLB  3
06C6:  MOVWF  xFA
06C8:  CLRF   xF9
06CA:  CLRF   xFC
06CC:  MOVLW  04
06CE:  MOVWF  xFB
06D0:  MOVLB  0
06D2:  BRA    0602
06D4:  MOVF   01,W
06D6:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_flush_buffer(void) 
.................... { 
....................    if (g_MMCSDBufferChanged) 
*
094A:  MOVLB  2
094C:  BTFSS  x04.1
094E:  BRA    097A
....................    { 
....................       g_MMCSDBufferChanged = FALSE; 
0950:  BCF    x04.1
....................       return(mmcsd_write_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
0952:  MOVFF  208,3F8
0956:  MOVFF  207,3F7
095A:  MOVFF  206,3F6
095E:  MOVFF  205,3F5
0962:  MOVLW  02
0964:  MOVLB  3
0966:  MOVWF  xFA
0968:  CLRF   xF9
096A:  CLRF   xFC
096C:  MOVLW  04
096E:  MOVWF  xFB
0970:  MOVLB  0
0972:  BRA    0898
0974:  MOVF   01,W
0976:  BRA    0980
0978:  MOVLB  2
....................    } 
....................    return(0);  //ok 
097A:  MOVLW  00
097C:  MOVWF  01
097E:  MOVLB  0
0980:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr) 
0982:  MOVLB  3
0984:  CLRF   xF0
.................... { 
....................    MMCSD_err ec = MMCSD_GOODEC; 
....................    uint32_t 
....................       //cur_block, 
....................       new_block; 
....................     
....................    // make sure we're still on the same block 
....................    //cur_block = g_mmcsdBufferAddress - (g_mmcsdBufferAddress % MMCSD_MAX_BLOCK_SIZE); 
....................    if(g_card_type == SDHC) 
0986:  MOVLB  2
0988:  MOVF   x09,W
098A:  SUBLW  02
098C:  BNZ   09A4
....................      new_block = new_addr / MMCSD_MAX_BLOCK_SIZE; 
098E:  BCF    FD8.0
0990:  MOVLB  3
0992:  CLRF   xF4
0994:  RRCF   xEF,W
0996:  MOVWF  xF3
0998:  RRCF   xEE,W
099A:  MOVWF  xF2
099C:  RRCF   xED,W
099E:  MOVWF  xF1
09A0:  BRA    09C8
09A2:  MOVLB  2
....................    else 
....................      new_block = new_addr - (new_addr % MMCSD_MAX_BLOCK_SIZE); 
09A4:  MOVLB  3
09A6:  MOVF   xED,W
09A8:  ANDLW  01
09AA:  MOVWF  01
09AC:  CLRF   02
09AE:  CLRF   03
09B0:  MOVF   xEC,W
09B2:  SUBWF  xEC,W
09B4:  MOVWF  xF1
09B6:  MOVF   01,W
09B8:  SUBWFB xED,W
09BA:  MOVWF  xF2
09BC:  MOVF   02,W
09BE:  SUBWFB xEE,W
09C0:  MOVWF  xF3
09C2:  MOVF   03,W
09C4:  SUBWFB xEF,W
09C6:  MOVWF  xF4
....................     
....................    //if(cur_block != new_block) 
....................    if(g_mmcsdBufferAddress != new_block) 
09C8:  MOVF   xF1,W
09CA:  MOVLB  2
09CC:  SUBWF  x05,W
09CE:  BNZ   09EE
09D0:  MOVLB  3
09D2:  MOVF   xF2,W
09D4:  MOVLB  2
09D6:  SUBWF  x06,W
09D8:  BNZ   09EE
09DA:  MOVLB  3
09DC:  MOVF   xF3,W
09DE:  MOVLB  2
09E0:  SUBWF  x07,W
09E2:  BNZ   09EE
09E4:  MOVLB  3
09E6:  MOVF   xF4,W
09E8:  MOVLB  2
09EA:  SUBWF  x08,W
09EC:  BZ    0A24
....................    { 
....................       // dump the old buffer 
....................       if (g_MMCSDBufferChanged) 
09EE:  BTFSS  x04.1
09F0:  BRA    0A0A
....................       { 
....................          ec = mmcsd_flush_buffer(); 
09F2:  MOVLB  0
09F4:  RCALL  094A
09F6:  MOVFF  01,3F0
....................          if(ec != MMCSD_GOODEC) 
09FA:  MOVLB  3
09FC:  MOVF   xF0,F
09FE:  BZ    0A06
....................             return ec; 
0A00:  MOVFF  3F0,01
0A04:  BRA    0A2A
....................          g_MMCSDBufferChanged = FALSE; 
0A06:  MOVLB  2
0A08:  BCF    x04.1
....................       } 
....................           
....................       // figure out the best place for a block 
....................       g_mmcsdBufferAddress = new_block; 
0A0A:  MOVFF  3F4,208
0A0E:  MOVFF  3F3,207
0A12:  MOVFF  3F2,206
0A16:  MOVFF  3F1,205
....................  
....................       // load up a new buffer 
....................       ec = mmcsd_load_buffer(); 
0A1A:  MOVLB  0
0A1C:  RCALL  06AE
0A1E:  MOVFF  01,3F0
0A22:  MOVLB  2
....................    } 
....................     
....................    return ec; 
0A24:  MOVLB  3
0A26:  MOVFF  3F0,01
0A2A:  MOVLB  0
0A2C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data) 
.................... { 
....................    MMCSD_err ec; 
....................     
....................    ec = mmcsd_move_buffer(addr); 
0A2E:  MOVFF  3D1,3EF
0A32:  MOVFF  3D0,3EE
0A36:  MOVFF  3CF,3ED
0A3A:  MOVFF  3CE,3EC
0A3E:  RCALL  0982
0A40:  MOVFF  01,3D4
....................    if(ec != MMCSD_GOODEC) 
0A44:  MOVLB  3
0A46:  MOVF   xD4,F
0A48:  BZ    0A50
....................    { 
....................      return ec; 
0A4A:  MOVFF  3D4,01
0A4E:  BRA    0A7A
....................    } 
....................   
....................    *data = g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE]; 
0A50:  MOVF   xCF,W
0A52:  ANDLW  01
0A54:  MOVWF  xD8
0A56:  CLRF   xD9
0A58:  CLRF   xDA
0A5A:  MOVLW  04
0A5C:  ADDWF  xCE,W
0A5E:  MOVWF  FE9
0A60:  MOVLW  00
0A62:  ADDWFC xD8,W
0A64:  MOVWF  FEA
0A66:  MOVFF  FEF,3DB
0A6A:  MOVFF  3D3,FEA
0A6E:  MOVFF  3D2,FE9
0A72:  MOVFF  3DB,FEF
....................  
....................    return MMCSD_GOODEC; 
0A76:  MOVLW  00
0A78:  MOVWF  01
0A7A:  MOVLB  0
0A7C:  GOTO   0AE8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data) 
.................... {   
....................    MMCSD_err ec; 
....................    ec = mmcsd_move_buffer(addr); 
*
1940:  MOVFF  3E9,3EF
1944:  MOVFF  3E8,3EE
1948:  MOVFF  3E7,3ED
194C:  MOVFF  3E6,3EC
1950:  CALL   0982
1954:  MOVFF  01,3EB
....................    if(ec != MMCSD_GOODEC) 
1958:  MOVLB  3
195A:  MOVF   xEB,F
195C:  BZ    1964
....................      return ec; 
195E:  MOVFF  3EB,01
1962:  BRA    1988
....................     
....................    g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE] = data; 
1964:  MOVF   xE7,W
1966:  ANDLW  01
1968:  MOVWF  xED
196A:  CLRF   xEE
196C:  CLRF   xEF
196E:  MOVLW  04
1970:  ADDWF  xE6,W
1972:  MOVWF  FE9
1974:  MOVLW  00
1976:  ADDWFC xED,W
1978:  MOVWF  FEA
197A:  MOVFF  3EA,FEF
....................     
....................    g_MMCSDBufferChanged = TRUE; 
197E:  MOVLB  2
1980:  BSF    x04.1
....................  
....................    return MMCSD_GOODEC; 
1982:  MOVLW  00
1984:  MOVWF  01
1986:  MOVLB  3
1988:  MOVLB  0
198A:  GOTO   19F4 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................   
.................... // Include FAT library source file 
.................... #include <fat_m.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          fat_m.c                                //// 
.................... ////                                                                 //// 
.................... ////        Driver/Library for a FAT filesystem with a PIC           //// 
.................... ////                                                                 //// 
.................... ////  This library is modified version of CCS C compiler FAT library //// 
.................... ////  source file fat.c, it now supports SDHC (high capacity) cards. //// 
.................... ////                                                                 //// 
.................... ////               https://simple-circuit.com/                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This Library was designed to resemble standard ANSI C I/O as    //// 
.................... ////  much as possible. There are, however, some caveats to this.    //// 
.................... ////  Please read the comments to make sure the inputs and outputs   //// 
.................... ////  to each function are understood before using anything in       //// 
.................... ////  this library.                                                  //// 
.................... ////                                                                 //// 
.................... //// This library supports FAT16 and FAT32, but not both at the same //// 
.................... //// time (this is a compile option, see options below).  It is      //// 
.................... //// recommended to use FAT32, FAT32 also has been tested more.      //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a file name must be in  //// 
.................... ////  the form of...                                                 //// 
.................... ////  "/filename.fil" for a file in the root directory               //// 
.................... ////  "/Directory/filename.fil" for a file in a subdirectory of root //// 
.................... ////  "/Directory/Subdirectory/filename.fil" and so on...            //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a directory name must   //// 
.................... ////  be in the form of...                                           //// 
.................... ////  "/Dirname/" for a directory in the root directory              //// 
.................... ////  "/Dirname/Subdirname/" for a directory in a subdirectory of    //// 
.................... ////  root and so on...                                              //// 
.................... ////                                                                 //// 
.................... //// A compatable media library must be provided.  This is           //// 
.................... //// documented after the User Functions.                            //// 
.................... ////                                                                 //// 
.................... //// -- User Functions --                                            //// 
.................... ////                                                                 //// 
.................... //// fat_init()                                                      //// 
.................... ////  Initializes the FAT library, also initializes the media.       //// 
.................... ////                                                                 //// 
.................... //// fatopen(char *name, char *mode, FILE *fstream)                  //// 
.................... ////  Opens up a FILE stream to a specified file with the specified  ////  
.................... ////  permission mode:                                               //// 
.................... ////             Permissions: "r" = read                             //// 
.................... ////                          "w" = write                            //// 
.................... ////                          "a" = append                           //// 
.................... ////                          "rb" = read binarily                   //// 
.................... ////             "w" will erase all of the data in the file upon     //// 
.................... ////              the opening of the file.                           //// 
.................... ////             "a" will tack on all of the data to the end of the  //// 
.................... ////              file.                                              //// 
.................... ////             "r" will keep on reading until the stream           //// 
.................... ////              hits an '\0'                                       //// 
.................... ////             "rb" will keep on reading until the amount of       //// 
.................... ////              bytes read equals the size of the file.            //// 
.................... ////                                                                 //// 
.................... ////  Unlike standard C fopen(), this does not malloc a FILE -       //// 
.................... ////  instead the caller will have to have allready allocated a      //// 
.................... ////  a FILE and pass a pointer to it.                               //// 
.................... ////                                                                 //// 
.................... //// fatreopen(char *name, char *mode, FILE *fstream)                //// 
.................... ////  Closes a FILE stream, then reopens the stream with a new file  //// 
.................... ////  and new permissions.                                           //// 
.................... ////                                                                 //// 
.................... //// fatclose(FILE *fstream)                                         //// 
.................... ////  Closes a FILE stream. It is very important to call this        ////  
.................... ////  function when you're done reading or writing to a file.        ////                             //// 
.................... ////                                                                 //// 
.................... //// fatgetc(FILE *fstream)                                          //// 
.................... ////  Gets a character from a stream. An EOF will be returned at     ////  
.................... ////  different times depending on whether or not the stream is      ////  
.................... ////  reading binarily.  If not reading binarily: EOF when the       ////  
.................... ////  stream reads a '\0'.  If reading binarily: EOF when the amount ////  
.................... ////  of bytes read equals the size of the file (end of file).       //// 
.................... ////                                                                 //// 
.................... //// fatputc(char c, FILE *fstream)                                  //// 
.................... ////  Puts a character into a stream (write to the file).            //// 
.................... ////  Writes are buffered, so the media may not be written to until  //// 
.................... ////  a fatclose().                                                  //// 
.................... ////                                                                 //// 
.................... //// char* fatgets(char* str, int num, FILE *fstream)                ////  
.................... ////  Gets characters from a stream until either a '\r',  EOF, or    ////  
.................... ////  num - 1 is hit.                                                //// 
.................... ////                                                                 //// 
.................... //// fatputs(char* str, FILE *fstream)                               //// 
.................... ////  Puts a string into a stream (write a string to the file).      //// 
.................... ////                                                                 //// 
.................... //// fatprintf(FILE *stream): Printfs the entire stream.             //// 
.................... ////  printf()'s the entire stream (printf()'s the contents of the 
.................... ////  file). 
.................... ////                                                                 //// 
.................... //// fatgetpos(FILE *fstream, fatpos_t *pos)                         //// 
.................... ////  Gets the current position of the stream/file, saves to pos.    //// 
.................... ////                                                                 //// 
.................... //// fatsetpos(FILE *fstream, fatpos_t *pos)                          //// 
.................... ////  Sets the current position of the stream/file.                  //// 
.................... ////                                                                 //// 
.................... //// fatseek(FILE *fstream, int32 offset, int origin)                 //// 
.................... ////  Sets the current position of the stream according to the       //// 
.................... ////  origin parameter:                                              //// 
.................... ////             SEEK_CUR: Set position relative to the              //// 
.................... ////              current stream position.                           //// 
.................... ////             SEEK_END: Set position relative to the              //// 
.................... ////              end of the stream.                                 //// 
.................... ////             SEEK_SET: Set position relative to the              //// 
.................... ////              beginning of the stream.                           //// 
.................... ////                                                                 //// 
.................... //// fateof(FILE *fstream)                                           //// 
.................... ////  Returns non-zero if the stream/file position is at EOF,        ////  
.................... ////  non-zero if there are still data left in the stream.           //// 
.................... ////                                                                 //// 
.................... //// faterror(FILE *fstream):                                        //// 
.................... ////  Returns non-zero if there have been errors with the stream,    //// 
.................... ////  zero if the stream has been operating correctly since it has   //// 
.................... ////  been opened.                                                   //// 
.................... ////                                                                 //// 
.................... //// fatread(void* buffer, int size, int32 num, FILE* fstream)       //// 
.................... ////  Reads size*num chars from the stream, saves to buffer.         //// 
.................... ////                                                                 //// 
.................... //// fatwrite(void* buffer, int size, int32 num, FILE* fstream)      ////  
.................... ////  Writes size*num chars from buffer to the stream.               //// 
.................... ////                                                                 //// 
.................... //// fatflush(FILE *fstream)                                         //// 
.................... ////  Flushes the buffer in a stream.                                //// 
.................... ////                                                                 //// 
.................... //// clearerr(FILE *fstream)                                         //// 
.................... ////  Clears any error flags in the stream.                          //// 
.................... ////                                                                 //// 
.................... //// rewind(FILE *fstream)                                           //// 
.................... ////  Send the stream back to the beginning of the file.             //// 
.................... ////                                                                 //// 
.................... //// fatpos_t fattell(FILE *fstream)                                 //// 
.................... ////  Returns the current position of the stream.                    //// 
.................... ////                                                                 //// 
.................... //// rm_file(char *fname)                                            //// 
.................... ////  Removes a file.                                                //// 
.................... ////                                                                 //// 
.................... //// rm_dir(char *dirname)                                           //// 
.................... ////  Removes a directory.                                           //// 
.................... ////                                                                 //// 
.................... //// mk_file(char *fname)                                            //// 
.................... ////  Makes a file, file will be blank.                              //// 
.................... ////                                                                 //// 
.................... //// mk_dir(char *dirname)                                           //// 
.................... ////  Makes a directory.                                             //// 
.................... ////                                                                 //// 
.................... //// format(int32 mediaSize)                                         //// 
.................... ////  Formats the media into a FAT32 or FAT16 file system.           //// 
.................... ////  If you specify a mediaSize larger than the actual media bad    //// 
.................... ////  things will happen.  If you specify a mediaSize smaller than   //// 
.................... ////  the actual media size will simply limit the filesystem from    //// 
.................... ////  using 0 to mediaSize-1.  Anything after mediaSize can be used  //// 
.................... ////  by the application (perhaps as a general purpose EEPROM?)      //// 
.................... ////  NOTE: Windows thinks the filesystem is RAW.                    //// 
.................... ////  NOTE: This may be a little buggy.                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This library was written to use CCS's MMC/SD library as the     //// 
.................... //// media source.  If you want to use a different media source,     //// 
.................... //// you must provide the following 4 functions:                     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_init(void);                                          //// 
.................... ////  Initializes the media.  This will be called by fat_init().     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_read_bytes(int32 a, int16 s, char *p);               //// 
.................... ////  Read s bytes from p to the media starting at address a.        //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_write_data(int32 a, int16 s, char *p);               //// 
.................... ////  Write s bytes from p to the media starting at address a.       //// 
.................... ////  To maximize throughput on some medias, it's a good idea to     //// 
.................... ////  buffer writes in this function.                                //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_flush_buffer(void);                                  //// 
.................... ////  If your write function is buffering writes, this will flush    //// 
.................... ////  the buffer and write it to the media.                          //// 
.................... ////                                                                 //// 
.................... //// All four functions should return 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // NOTE This library has no concept of what time and date it currently is. 
.................... //       All files and folders created or modified using this library 
.................... //       will have invalid/inaccurate timestamps and datestamps. 
....................  
.................... // NOTE To save on ROM and RAM space, the user of this library will have to  
.................... //       define what type of FAT they will be working with. The defines are  
.................... //       in the Useful Defines section below. 
....................  
.................... // NOTE For faster writing or appending for an application such as a logger,  
.................... //       uncomment #FAST_FAT below.  This will make the FAT library assume  
.................... //       there is one file on the card to write or append to, thereby 
.................... //       making writing and appending much faster. Reading is impossible in  
.................... //       this mode. 
.................... //       THIS IS NOT TESTED VERY WELL YET! 
....................  
.................... // NOTE The current maximum file name length (full path) is 32 characters  
.................... //       long. If longer file names are desired, change the  
.................... //       MAX_FILE_NAME_LENGTH define below. Creating a file whose full path  
.................... //       is longer than MAX_FILE_NAME_LENGTH may lead to weird operation. Keep 
.................... //       in mind that making this define larger will make your RAM usage go  
.................... //        up. 
....................  
.................... #ifndef FAT_PIC_C 
.................... #define FAT_PIC_C 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
1842:  MOVLB  3
1844:  MOVFF  382,FE9
1848:  MOVFF  383,FEA
184C:  MOVFF  FEF,386
1850:  MOVFF  385,03
1854:  MOVFF  384,FE9
1858:  MOVFF  385,FEA
185C:  MOVF   FEF,W
185E:  SUBWF  x86,W
1860:  BNZ   188C
....................       if (*s1 == '\0') 
1862:  MOVFF  383,03
1866:  MOVFF  382,FE9
186A:  MOVFF  03,FEA
186E:  MOVF   FEF,F
1870:  BNZ   1878
....................          return(0); 
1872:  MOVLW  00
1874:  MOVWF  01
1876:  BRA    18B6
1878:  MOVFF  383,03
187C:  MOVF   x82,W
187E:  INCF   x82,F
1880:  BTFSC  FD8.2
1882:  INCF   x83,F
1884:  INCF   x84,F
1886:  BTFSC  FD8.2
1888:  INCF   x85,F
188A:  BRA    1844
....................    return((*s1 < *s2) ? -1: 1); 
188C:  MOVFF  383,03
1890:  MOVFF  382,FE9
1894:  MOVFF  383,FEA
1898:  MOVFF  FEF,386
189C:  MOVFF  385,03
18A0:  MOVFF  384,FE9
18A4:  MOVFF  385,FEA
18A8:  MOVF   FEF,W
18AA:  SUBWF  x86,W
18AC:  BC    18B2
18AE:  MOVLW  FF
18B0:  BRA    18B4
18B2:  MOVLW  01
18B4:  MOVWF  01
18B6:  MOVLB  0
18B8:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
33AE:  MOVFF  363,03
33B2:  MOVLB  3
33B4:  MOVFF  362,FE9
33B8:  MOVFF  363,FEA
33BC:  MOVF   x64,W
33BE:  SUBWF  FEF,W
33C0:  BZ    33E6
....................       if (*s == '\0') 
33C2:  MOVFF  363,03
33C6:  MOVFF  362,FE9
33CA:  MOVFF  363,FEA
33CE:  MOVF   FEF,F
33D0:  BNZ   33DA
....................          return(0); 
33D2:  MOVLW  00
33D4:  MOVWF  01
33D6:  MOVWF  02
33D8:  BRA    33EE
33DA:  INCF   x62,F
33DC:  BTFSC  FD8.2
33DE:  INCF   x63,F
33E0:  MOVLB  0
33E2:  BRA    33AE
33E4:  MOVLB  3
....................    return(s); 
33E6:  MOVFF  362,01
33EA:  MOVFF  363,02
33EE:  MOVLB  0
33F0:  RETURN 0
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
*
32F0:  MOVLB  2
32F2:  CLRF   xF7
32F4:  CLRF   xF6
....................    { 
....................       if (*s == c) 
32F6:  MOVFF  2F4,03
32FA:  MOVFF  2F3,FE9
32FE:  MOVFF  2F4,FEA
3302:  MOVF   xF5,W
3304:  SUBWF  FEF,W
3306:  BNZ   3310
....................          p = s; 
3308:  MOVFF  2F4,2F7
330C:  MOVFF  2F3,2F6
....................       if (*s == '\0') 
3310:  MOVFF  2F4,03
3314:  MOVFF  2F3,FE9
3318:  MOVFF  2F4,FEA
331C:  MOVF   FEF,F
331E:  BNZ   332A
....................          return(p); 
3320:  MOVFF  2F6,01
3324:  MOVFF  2F7,02
3328:  BRA    3332
332A:  INCF   xF3,F
332C:  BTFSC  FD8.2
332E:  INCF   xF4,F
3330:  BRA    32F6
....................    } 
3332:  MOVLB  0
3334:  GOTO   3EEC (RETURN)
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1060:  MOVFF  39B,39D
1064:  MOVFF  39A,39C
1068:  MOVFF  39D,03
106C:  MOVLB  3
106E:  MOVFF  39C,FE9
1072:  MOVFF  39D,FEA
1076:  MOVF   FEF,F
1078:  BZ    1086
107A:  INCF   x9C,F
107C:  BTFSC  FD8.2
107E:  INCF   x9D,F
1080:  MOVLB  0
1082:  BRA    1068
1084:  MOVLB  3
....................    return(sc - s); 
1086:  MOVF   x9A,W
1088:  SUBWF  x9C,W
108A:  MOVWF  00
108C:  MOVF   x9B,W
108E:  SUBWFB x9D,W
1090:  MOVWF  03
1092:  MOVFF  00,01
1096:  MOVWF  02
1098:  MOVLB  0
109A:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #case 
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... /// Define your FAT type here /// 
.................... #ifndef FAT16 
....................   #define FAT32 
.................... #endif 
....................  
.................... /// For faster single-file writing, uncomment this line below /// 
.................... //#define FAST_FAT 
....................  
.................... /// Everything else /// 
.................... #define MAX_FILE_NAME_LENGTH 0x20  // the maximum length of a file name for our FAT, including /0 terminator 
.................... #define STREAM_BUF_SIZE 0x20       // how big the FILE buffer is. 0x20 is optimal 
....................  
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #define EOF -1 
.................... #define GOODEC 0 
.................... #define fatpos_t int32 
.................... #define SEEK_CUR 0 
.................... #define SEEK_END 1 
.................... #define SEEK_SET 2 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... int16 
....................    Bytes_Per_Cluster;   // number of addressable bytes per cluster 
....................  
.................... int32 
....................    FAT_Start,           // when the first FAT begins 
....................    Data_Start,          // when data starts 
....................    FAT_Length,          // the length of one FAT 
....................    Next_Free_Clust,     // where the next free cluster is 
....................    Root_Dir;            // when the root directory starts 
....................  
.................... enum filetype 
.................... { 
....................    Data_File,  // the stream is pointing to a binary, data file 
....................    Directory,  // the stream is pointing to a directory 
....................    None        // the stream isn't currently pointing to anything 
.................... }; 
....................  
.................... enum ioflags 
.................... { 
....................    Closed = 0x00, 
....................    Read = 0x01, 
....................    Write = 0x02, 
....................    Append = 0x04, 
....................    Binary = 0x08, 
....................    EOF_Reached = 0x10, 
....................    Read_Error = 0x20, 
....................    Write_Error = 0x40, 
....................    File_Not_Found = 0x80 
.................... }; 
....................  
.................... struct iobuf 
.................... { 
....................    fatpos_t 
....................       Bytes_Until_EOF,     // how many bytes until the stream's end of file 
....................       Cur_Char,            // the current byte that the stream is pointing at 
....................       Entry_Addr,          // the entry address of the file that is associated with the stream 
....................       Parent_Start_Addr,   // the parent's start adddress of the file that is associated with the stream 
....................       Size,                // the size of the file that is associated with the stream 
....................       Start_Addr;          // the beginning of the data in the file that is associated with the stream 
....................  
....................    enum filetype File_Type;   // the type of file that is associated with the stream 
....................  
....................    enum ioflags Flags;        // any associated input/output flag 
....................  
....................    int Buf[STREAM_BUF_SIZE];  // this is a buffer so that during fatputc() or fatgetc() 
....................                               //  the media won't have to be read at every character 
.................... }; 
.................... typedef struct iobuf FILE; 
....................  
.................... /////////////////////////// 
.................... ///                     /// 
.................... /// Function Prototypes /// 
.................... ///                     /// 
.................... /////////////////////////// 
....................  
.................... /// Standard C Functions /// 
.................... signed int fatopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatclose(FILE* stream); 
.................... signed int fatgetc(FILE* stream); 
.................... signed int fatputc(int ch, FILE* stream); 
.................... char* fatgets(char* str, int num, FILE* stream); 
.................... signed int fatputs(char* str, FILE* stream); 
.................... signed int fatprintf(FILE* stream); 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatseek(FILE* stream, int32 offset, int origin); 
.................... signed int fateof(FILE* stream); 
.................... signed int faterror(FILE* stream); 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream); 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ); 
.................... signed int fatflush(FILE* stream); 
.................... signed int remove(char* fname); 
.................... void clearerr(FILE* stream); 
.................... void rewind(FILE* stream); 
.................... fatpos_t fattell(FILE* stream); 
....................  
.................... /// Non-Standard C Functions /// 
.................... signed int rm_file(char fname[]); 
.................... signed int rm_dir(char dname[]); 
.................... signed int mk_file(char fname[]); 
.................... signed int mk_dir(char dname[]); 
....................  
.................... /// Functions' Utility Functions /// 
.................... signed int set_file(char fname[], int attrib, FILE* stream); 
.................... signed int get_file_name(int32 file_entry_addr, char name[]); 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]); 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type); 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]); 
.................... int long_name_chksum (int* pFcbName); 
.................... signed int check_invalid_char(char fname[]); 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster); 
.................... signed int dealloc_clusters(int32 start_cluster); 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int32 cluster); 
.................... signed int write_fat(int32 cluster, int32 data); 
.................... #else // FAT16 
.................... signed int get_next_free_cluster(int16* my_cluster); 
.................... signed int dealloc_clusters(int16 start_cluster); 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int16 cluster); 
.................... signed int write_fat(int16 cluster, int16 data); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_file(FILE* stream); 
.................... signed int get_prev_file(FILE* stream); 
.................... signed int get_next_free_addr(int32* my_addr); 
.................... signed int get_next_free_entry(int32* start_addr); 
.................... signed int get_next_entry(int32* start_addr); 
.................... signed int get_prev_entry(int32* start_addr); 
.................... signed int read_buffer(FILE* stream, int* val); 
.................... signed int write_buffer(FILE* stream, int val); 
.................... void fill_entry(char the_entry[], char val, int8 start_ind); 
.................... void disp_timestamp(int16 timestamp); 
.................... void disp_datestamp(int16 datestamp); 
....................  
.................... /// Data Utility Functions /// 
.................... signed int fat_init(); 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster); 
.................... signed int get_prev_cluster(int32* my_cluster); 
.................... int32 cluster_to_addr(int32 cluster); 
.................... int32 addr_to_cluster(int32 addr); 
.................... #else // FAT16 
.................... signed int get_next_cluster(int16* my_cluster); 
.................... signed int get_prev_cluster(int16* my_cluster); 
.................... int32 cluster_to_addr(int16 cluster); 
.................... int16 addr_to_cluster(int32 addr); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_addr(int32* my_addr); 
.................... signed int get_prev_addr(int32* my_addr); 
.................... signed int format(int32 DskSize); 
....................  
.................... /// Debugging Utility Functions /// 
.................... signed int disp_folder_contents(char foldername[]); 
.................... signed int dump_addr(int32 from, int32 to); 
.................... signed int dump_clusters(int32 from, int32 to); 
.................... void disp_fat_stats(); 
.................... signed int fatprintfinfo(FILE* stream); 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /// Standard C Functions /// 
....................  
.................... /* 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... Summary: This will open up a file stream for reading, writing, or appending. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to open up. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
*
304A:  MOVLW  01
304C:  MOVLB  2
304E:  MOVWF  xF9
3050:  MOVLB  3
3052:  CLRF   x54
.................... { 
....................    int fname_parse_pos = 1;    // the current index of the fname character 
....................  
....................    char target_file[MAX_FILE_NAME_LENGTH];   // temporary buffer to hold names of files 
....................  
....................    FILE cur_stream;     // this will   be the stream that will be returned if all goes well 
....................  
.................... #ifndef FAST_FAT 
....................    int 
....................       depth = 0,              // how many subdirectories deep the file is 
....................       target_file_parse_pos;  // the current index of the target_file character 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set flags 
.................... #ifdef FAST_FAT 
....................    switch(mode[0]) 
....................    { 
....................       case 'w': 
....................          cur_stream.Flags = Write; 
....................          break; 
....................       case 'a': 
....................          cur_stream.Flags = Append; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
....................  
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
....................       target_file[fname_parse_pos - 1] = fname[fname_parse_pos]; 
....................       fname_parse_pos += 1; 
....................    } 
....................  
....................    target_file[fname_parse_pos] = '\0'; 
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
....................       *stream = cur_stream; 
....................       return EOF; 
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................    switch(mode[0]) 
3054:  MOVLB  2
3056:  MOVF   xF5,W
3058:  MOVWF  FE9
305A:  MOVF   xF6,W
305C:  MOVWF  FEA
305E:  MOVF   FEF,W
3060:  XORLW  72
3062:  MOVLB  0
3064:  BZ    3070
3066:  XORLW  05
3068:  BZ    3078
306A:  XORLW  16
306C:  BZ    3080
306E:  BRA    308A
....................    { 
....................       case 'r': 
....................          cur_stream.Flags = Read; 
3070:  MOVLW  01
3072:  MOVLB  3
3074:  MOVWF  x33
....................          break; 
3076:  BRA    3092
....................       case 'w': 
....................          cur_stream.Flags = Write; 
3078:  MOVLW  02
307A:  MOVLB  3
307C:  MOVWF  x33
....................          break; 
307E:  BRA    3092
....................       case 'a': 
....................          cur_stream.Flags = Append; 
3080:  MOVLW  04
3082:  MOVLB  3
3084:  MOVWF  x33
....................          break; 
3086:  BRA    3092
3088:  MOVLB  0
....................       default: 
....................          return EOF; 
308A:  MOVLW  FF
308C:  MOVWF  01
308E:  BRA    32EE
3090:  MOVLB  3
....................    } 
....................  
....................    if(mode[1] == 'b') 
3092:  MOVLW  01
3094:  MOVLB  2
3096:  ADDWF  xF5,W
3098:  MOVWF  FE9
309A:  MOVLW  00
309C:  ADDWFC xF6,W
309E:  MOVWF  FEA
30A0:  MOVF   FEF,W
30A2:  SUBLW  62
30A4:  BNZ   30AC
....................       cur_stream.Flags |= Binary; 
30A6:  MOVLB  3
30A8:  BSF    x33.3
30AA:  MOVLB  2
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
30AC:  MOVFF  221,329
30B0:  MOVFF  220,328
30B4:  MOVFF  21F,327
30B8:  MOVFF  21E,326
30BC:  MOVFF  329,331
30C0:  MOVFF  328,330
30C4:  MOVFF  327,32F
30C8:  MOVFF  326,32E
....................  
....................    // figure out how deep we have to go, count how many '/' we have in the string 
....................    while(fname[fname_parse_pos] != '\0') 
30CC:  MOVF   xF9,W
30CE:  ADDWF  xF3,W
30D0:  MOVWF  FE9
30D2:  MOVLW  00
30D4:  ADDWFC xF4,W
30D6:  MOVWF  FEA
30D8:  MOVF   FEF,F
30DA:  BZ    30FA
....................    { 
....................       if(fname[fname_parse_pos] == '/') 
30DC:  MOVF   xF9,W
30DE:  ADDWF  xF3,W
30E0:  MOVWF  FE9
30E2:  MOVLW  00
30E4:  ADDWFC xF4,W
30E6:  MOVWF  FEA
30E8:  MOVF   FEF,W
30EA:  SUBLW  2F
30EC:  BNZ   30F4
....................          depth++; 
30EE:  MOVLB  3
30F0:  INCF   x54,F
30F2:  MOVLB  2
....................       fname_parse_pos += 1; 
30F4:  MOVLW  01
30F6:  ADDWF  xF9,F
30F8:  BRA    30CC
....................    } 
....................  
....................    // start the fname index at 1 to skip over the '/' 
....................    fname_parse_pos = 1; 
30FA:  MOVLW  01
30FC:  MOVWF  xF9
....................  
....................    // open up to the subdirectory, if possible 
....................    while(depth > 0) 
30FE:  MOVLB  3
3100:  MOVF   x54,F
3102:  BZ    31DA
....................    { 
....................       // find the name of our next target directory 
....................       target_file_parse_pos = 0; 
3104:  CLRF   x55
....................       while(fname[fname_parse_pos] != '/') 
3106:  MOVLB  2
3108:  MOVF   xF9,W
310A:  ADDWF  xF3,W
310C:  MOVWF  FE9
310E:  MOVLW  00
3110:  ADDWFC xF4,W
3112:  MOVWF  FEA
3114:  MOVF   FEF,W
3116:  SUBLW  2F
3118:  BZ    3170
....................       { 
....................          // check to make sure that we're not at the end of a poorly formatted string 
....................          if(fname[fname_parse_pos] == '\0') 
311A:  MOVF   xF9,W
311C:  ADDWF  xF3,W
311E:  MOVWF  FE9
3120:  MOVLW  00
3122:  ADDWFC xF4,W
3124:  MOVWF  FEA
3126:  MOVF   FEF,F
3128:  BNZ   3134
....................             return EOF; 
312A:  MOVLW  FF
312C:  MOVWF  01
312E:  MOVLB  0
3130:  BRA    32EE
3132:  MOVLB  2
....................  
....................          // fill up the buffer and increment the indexes 
....................          target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
3134:  CLRF   03
3136:  MOVLB  3
3138:  MOVF   x55,W
313A:  ADDLW  FA
313C:  MOVWF  01
313E:  MOVLW  02
3140:  ADDWFC 03,F
3142:  MOVLB  2
3144:  MOVF   xF9,W
3146:  ADDWF  xF3,W
3148:  MOVWF  FE9
314A:  MOVLW  00
314C:  ADDWFC xF4,W
314E:  MOVWF  FEA
3150:  MOVFF  FEF,358
3154:  MOVLB  3
3156:  MOVFF  03,FEA
315A:  MOVFF  01,FE9
315E:  MOVFF  358,FEF
....................          fname_parse_pos += 1; 
3162:  MOVLW  01
3164:  MOVLB  2
3166:  ADDWF  xF9,F
....................          target_file_parse_pos += 1; 
3168:  MOVLB  3
316A:  ADDWF  x55,F
316C:  BRA    3106
316E:  MOVLB  2
....................       } 
....................  
....................       // increment the fname index one more because it's currently pointing at the '/' 
....................       fname_parse_pos += 1; 
3170:  MOVLW  01
3172:  ADDWF  xF9,F
....................  
....................       // tack on a \0 to the end of the target file to terminate the string 
....................       target_file[target_file_parse_pos] = '\0'; 
3174:  CLRF   03
3176:  MOVLB  3
3178:  MOVF   x55,W
317A:  ADDLW  FA
317C:  MOVWF  FE9
317E:  MOVLW  02
3180:  ADDWFC 03,W
3182:  MOVWF  FEA
3184:  CLRF   FEF
....................  
....................       // check to see if the directory exists and open it if possible, otherwise exit because the directory doesn't exist 
....................       if(set_file(target_file, 0x10, &cur_stream) != GOODEC) 
3186:  MOVLW  02
3188:  MOVWF  x57
318A:  MOVLW  FA
318C:  MOVWF  x56
318E:  MOVLW  10
3190:  MOVWF  x58
3192:  MOVLW  03
3194:  MOVWF  x5A
3196:  MOVLW  1A
3198:  MOVWF  x59
319A:  MOVLB  0
319C:  CALL   297A
31A0:  MOVF   01,F
31A2:  BZ    31D2
....................       { 
....................          cur_stream.Flags |= File_Not_Found; 
31A4:  MOVLB  3
31A6:  BSF    x33.7
....................          *stream = cur_stream; 
31A8:  MOVFF  2F8,03
31AC:  MOVLB  2
31AE:  MOVFF  2F7,FE9
31B2:  MOVFF  2F8,FEA
31B6:  MOVLW  03
31B8:  MOVWF  FE2
31BA:  MOVLW  1A
31BC:  MOVWF  FE1
31BE:  MOVLW  3A
31C0:  MOVWF  01
31C2:  MOVFF  FE6,FEE
31C6:  DECFSZ 01,F
31C8:  BRA    31C2
....................          return EOF; 
31CA:  MOVLW  FF
31CC:  MOVWF  01
31CE:  MOVLB  0
31D0:  BRA    32EE
....................       } 
....................       depth -= 1; 
31D2:  MOVLW  01
31D4:  MOVLB  3
31D6:  SUBWF  x54,F
31D8:  BRA    3100
....................    } 
....................  
....................    // check to see if we're trying to open just a directory 
....................    if(fname[fname_parse_pos] == '\0') 
31DA:  MOVLB  2
31DC:  MOVF   xF9,W
31DE:  ADDWF  xF3,W
31E0:  MOVWF  FE9
31E2:  MOVLW  00
31E4:  ADDWFC xF4,W
31E6:  MOVWF  FEA
31E8:  MOVF   FEF,F
31EA:  BNZ   3216
....................    { 
....................       *stream = cur_stream; 
31EC:  MOVFF  2F8,03
31F0:  MOVFF  2F7,FE9
31F4:  MOVFF  2F8,FEA
31F8:  MOVLW  03
31FA:  MOVWF  FE2
31FC:  MOVLW  1A
31FE:  MOVWF  FE1
3200:  MOVLW  3A
3202:  MOVWF  01
3204:  MOVFF  FE6,FEE
3208:  DECFSZ 01,F
320A:  BRA    3204
....................       return GOODEC; 
320C:  MOVLW  00
320E:  MOVWF  01
3210:  MOVLB  0
3212:  BRA    32EE
3214:  MOVLB  2
....................    } 
....................  
....................    // now that we have the location of the subdirectory that the file is in, attempt to open the file 
....................    target_file_parse_pos = 0; 
3216:  MOVLB  3
3218:  CLRF   x55
....................    while(fname[fname_parse_pos] != '\0') 
321A:  MOVLB  2
321C:  MOVF   xF9,W
321E:  ADDWF  xF3,W
3220:  MOVWF  FE9
3222:  MOVLW  00
3224:  ADDWFC xF4,W
3226:  MOVWF  FEA
3228:  MOVF   FEF,F
322A:  BZ    3268
....................    { 
....................       // fill up the buffer and increment the indexes 
....................       target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
322C:  CLRF   03
322E:  MOVLB  3
3230:  MOVF   x55,W
3232:  ADDLW  FA
3234:  MOVWF  01
3236:  MOVLW  02
3238:  ADDWFC 03,F
323A:  MOVLB  2
323C:  MOVF   xF9,W
323E:  ADDWF  xF3,W
3240:  MOVWF  FE9
3242:  MOVLW  00
3244:  ADDWFC xF4,W
3246:  MOVWF  FEA
3248:  MOVFF  FEF,358
324C:  MOVLB  3
324E:  MOVFF  03,FEA
3252:  MOVFF  01,FE9
3256:  MOVFF  358,FEF
....................       fname_parse_pos += 1; 
325A:  MOVLW  01
325C:  MOVLB  2
325E:  ADDWF  xF9,F
....................       target_file_parse_pos += 1; 
3260:  MOVLB  3
3262:  ADDWF  x55,F
3264:  BRA    321A
3266:  MOVLB  2
....................    } 
....................  
....................    // tack on a \0 to the end of the target file to terminate the string 
....................    target_file[target_file_parse_pos] = '\0'; 
3268:  CLRF   03
326A:  MOVLB  3
326C:  MOVF   x55,W
326E:  ADDLW  FA
3270:  MOVWF  FE9
3272:  MOVLW  02
3274:  ADDWFC 03,W
3276:  MOVWF  FEA
3278:  CLRF   FEF
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
327A:  MOVLW  02
327C:  MOVWF  x57
327E:  MOVLW  FA
3280:  MOVWF  x56
3282:  MOVLW  20
3284:  MOVWF  x58
3286:  MOVLW  03
3288:  MOVWF  x5A
328A:  MOVLW  1A
328C:  MOVWF  x59
328E:  MOVLB  0
3290:  CALL   297A
3294:  MOVF   01,F
3296:  BZ    32C6
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
3298:  MOVLB  3
329A:  BSF    x33.7
....................       *stream = cur_stream; 
329C:  MOVFF  2F8,03
32A0:  MOVLB  2
32A2:  MOVFF  2F7,FE9
32A6:  MOVFF  2F8,FEA
32AA:  MOVLW  03
32AC:  MOVWF  FE2
32AE:  MOVLW  1A
32B0:  MOVWF  FE1
32B2:  MOVLW  3A
32B4:  MOVWF  01
32B6:  MOVFF  FE6,FEE
32BA:  DECFSZ 01,F
32BC:  BRA    32B6
....................       return EOF; 
32BE:  MOVLW  FF
32C0:  MOVWF  01
32C2:  MOVLB  0
32C4:  BRA    32EE
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
32C6:  MOVFF  2F8,03
32CA:  MOVLB  2
32CC:  MOVFF  2F7,FE9
32D0:  MOVFF  2F8,FEA
32D4:  MOVLW  03
32D6:  MOVWF  FE2
32D8:  MOVLW  1A
32DA:  MOVWF  FE1
32DC:  MOVLW  3A
32DE:  MOVWF  01
32E0:  MOVFF  FE6,FEE
32E4:  DECFSZ 01,F
32E6:  BRA    32E0
....................    return GOODEC; 
32E8:  MOVLW  00
32EA:  MOVWF  01
32EC:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
32EE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatreopen(char fname[], char mode[], FILE* old_stream, FILE* new_stream) 
.................... Summary: This will close a stream and then reopen it using new parameters. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to close and reopen. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................          /Directory/filename.fil for a file in a subdirectory of root 
....................          /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream) 
.................... { 
....................    // close the old stream 
....................    if(fatclose(stream) == EOF) 
....................      return EOF; 
....................  
....................    // open the new stream 
....................    if(fatopen(fname, mode, stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatclose(FILE* stream) 
.................... Summary: Closes a stream and commits any changes done to the file. 
.................... Param: The stream to close. 
.................... Returns: EOF if there was a problem, 0 if everything went okay. 
.................... */ 
.................... signed int fatclose(FILE* stream) 
*
440A:  MOVLB  2
440C:  CLRF   x63
.................... { 
....................    int ec = 0; 
....................  
....................    int32 first_cluster; 
....................  
....................    // commit data back to the stream's entry, if needed 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
440E:  MOVLW  19
4410:  ADDWF  x61,W
4412:  MOVWF  FE9
4414:  MOVLW  00
4416:  ADDWFC x62,W
4418:  MOVWF  FEA
441A:  BTFSC  FEF.1
441C:  BRA    442E
441E:  MOVLW  19
4420:  ADDWF  x61,W
4422:  MOVWF  FE9
4424:  MOVLW  00
4426:  ADDWFC x62,W
4428:  MOVWF  FEA
442A:  BTFSS  FEF.2
442C:  BRA    4694
....................    {  
....................       // write the new size of the file 
....................       if(mmcsd_write_data(stream->Entry_Addr + 0x1C, 4, &(stream->Size)) != GOODEC) 
442E:  MOVLW  08
4430:  ADDWF  x61,W
4432:  MOVWF  FE9
4434:  MOVLW  00
4436:  ADDWFC x62,W
4438:  MOVWF  FEA
443A:  MOVFF  FEF,268
443E:  MOVFF  FEC,269
4442:  MOVFF  FEC,26A
4446:  MOVFF  FEC,26B
444A:  MOVLW  1C
444C:  ADDWF  x68,F
444E:  MOVLW  00
4450:  ADDWFC x69,F
4452:  ADDWFC x6A,F
4454:  ADDWFC x6B,F
4456:  MOVLW  10
4458:  ADDWF  x61,W
445A:  MOVWF  01
445C:  MOVLW  00
445E:  ADDWFC x62,W
4460:  MOVWF  03
4462:  MOVFF  01,26C
4466:  MOVWF  x6D
4468:  MOVFF  26B,3D9
446C:  MOVFF  26A,3D8
4470:  MOVFF  269,3D7
4474:  MOVFF  268,3D6
4478:  MOVLB  3
447A:  CLRF   xDB
447C:  MOVLW  04
447E:  MOVWF  xDA
4480:  MOVFF  03,3DD
4484:  MOVFF  01,3DC
4488:  MOVLB  0
448A:  CALL   198E
448E:  MOVF   01,F
4490:  BZ    44AE
....................       { 
....................          stream->Flags |= Write_Error; 
4492:  MOVLW  19
4494:  MOVLB  2
4496:  ADDWF  x61,W
4498:  MOVWF  FE9
449A:  MOVLW  00
449C:  ADDWFC x62,W
449E:  MOVWF  FEA
44A0:  MOVF   FEF,W
44A2:  IORLW  40
44A4:  MOVWF  FEF
....................          return EOF; 
44A6:  MOVLW  FF
44A8:  MOVWF  01
44AA:  BRA    4722
44AC:  MOVLB  0
....................       } 
....................  
....................       // check to see if the first cluster is already linked in the file 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
44AE:  MOVLW  08
44B0:  MOVLB  2
44B2:  ADDWF  x61,W
44B4:  MOVWF  FE9
44B6:  MOVLW  00
44B8:  ADDWFC x62,W
44BA:  MOVWF  FEA
44BC:  MOVFF  FEF,268
44C0:  MOVFF  FEC,269
44C4:  MOVFF  FEC,26A
44C8:  MOVFF  FEC,26B
44CC:  MOVLW  14
44CE:  ADDWF  x68,F
44D0:  MOVLW  00
44D2:  ADDWFC x69,F
44D4:  ADDWFC x6A,F
44D6:  ADDWFC x6B,F
44D8:  MOVFF  26B,3C0
44DC:  MOVFF  26A,3BF
44E0:  MOVFF  269,3BE
44E4:  MOVFF  268,3BD
44E8:  MOVLB  3
44EA:  CLRF   xC2
44EC:  MOVLW  02
44EE:  MOVWF  xC1
44F0:  MOVWF  xC4
44F2:  MOVLW  66
44F4:  MOVWF  xC3
44F6:  MOVLB  0
44F8:  CALL   0A80
44FC:  MOVF   01,W
44FE:  MOVLB  2
4500:  ADDWF  x63,F
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
4502:  MOVLW  08
4504:  ADDWF  x61,W
4506:  MOVWF  FE9
4508:  MOVLW  00
450A:  ADDWFC x62,W
450C:  MOVWF  FEA
450E:  MOVFF  FEF,268
4512:  MOVFF  FEC,269
4516:  MOVFF  FEC,26A
451A:  MOVFF  FEC,26B
451E:  MOVLW  1A
4520:  ADDWF  x68,F
4522:  MOVLW  00
4524:  ADDWFC x69,F
4526:  ADDWFC x6A,F
4528:  ADDWFC x6B,F
452A:  MOVFF  26B,3C0
452E:  MOVFF  26A,3BF
4532:  MOVFF  269,3BE
4536:  MOVFF  268,3BD
453A:  MOVLB  3
453C:  CLRF   xC2
453E:  MOVLW  02
4540:  MOVWF  xC1
4542:  MOVWF  xC4
4544:  MOVLW  64
4546:  MOVWF  xC3
4548:  MOVLB  0
454A:  CALL   0A80
454E:  MOVF   01,W
4550:  MOVLB  2
4552:  ADDWF  x63,F
....................  
....................       if(ec != GOODEC) 
4554:  MOVF   x63,F
4556:  BZ    4570
....................       { 
....................          stream->Flags |= Read_Error; 
4558:  MOVLW  19
455A:  ADDWF  x61,W
455C:  MOVWF  FE9
455E:  MOVLW  00
4560:  ADDWFC x62,W
4562:  MOVWF  FEA
4564:  MOVF   FEF,W
4566:  IORLW  20
4568:  MOVWF  FEF
....................          return EOF; 
456A:  MOVLW  FF
456C:  MOVWF  01
456E:  BRA    4722
....................       } 
....................  
....................       // write the first cluster to the entry if needed 
....................       if(first_cluster == 0) 
4570:  MOVF   x64,F
4572:  BTFSS  FD8.2
4574:  BRA    467A
4576:  MOVF   x65,F
4578:  BTFSS  FD8.2
457A:  BRA    467A
457C:  MOVF   x66,F
457E:  BTFSS  FD8.2
4580:  BRA    467A
4582:  MOVF   x67,F
4584:  BNZ   467A
....................       { 
....................          // convert the start address to a cluster number 
....................          first_cluster = addr_to_cluster(stream->Start_Addr); 
4586:  MOVLW  14
4588:  ADDWF  x61,W
458A:  MOVWF  FE9
458C:  MOVLW  00
458E:  ADDWFC x62,W
4590:  MOVWF  FEA
4592:  MOVFF  FEF,3A0
4596:  MOVFF  FEC,3A1
459A:  MOVFF  FEC,3A2
459E:  MOVFF  FEC,3A3
45A2:  MOVLB  0
45A4:  CALL   1268
45A8:  MOVFF  03,267
45AC:  MOVFF  02,266
45B0:  MOVFF  01,265
45B4:  MOVFF  00,264
....................  
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
45B8:  MOVLW  08
45BA:  MOVLB  2
45BC:  ADDWF  x61,W
45BE:  MOVWF  FE9
45C0:  MOVLW  00
45C2:  ADDWFC x62,W
45C4:  MOVWF  FEA
45C6:  MOVFF  FEF,268
45CA:  MOVFF  FEC,269
45CE:  MOVFF  FEC,26A
45D2:  MOVFF  FEC,26B
45D6:  MOVLW  14
45D8:  ADDWF  x68,F
45DA:  MOVLW  00
45DC:  ADDWFC x69,F
45DE:  ADDWFC x6A,F
45E0:  ADDWFC x6B,F
45E2:  MOVFF  26B,3D9
45E6:  MOVFF  26A,3D8
45EA:  MOVFF  269,3D7
45EE:  MOVFF  268,3D6
45F2:  MOVLB  3
45F4:  CLRF   xDB
45F6:  MOVLW  02
45F8:  MOVWF  xDA
45FA:  MOVWF  xDD
45FC:  MOVLW  66
45FE:  MOVWF  xDC
4600:  MOVLB  0
4602:  CALL   198E
4606:  MOVF   01,W
4608:  MOVLB  2
460A:  ADDWF  x63,F
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
460C:  MOVLW  08
460E:  ADDWF  x61,W
4610:  MOVWF  FE9
4612:  MOVLW  00
4614:  ADDWFC x62,W
4616:  MOVWF  FEA
4618:  MOVFF  FEF,268
461C:  MOVFF  FEC,269
4620:  MOVFF  FEC,26A
4624:  MOVFF  FEC,26B
4628:  MOVLW  1A
462A:  ADDWF  x68,F
462C:  MOVLW  00
462E:  ADDWFC x69,F
4630:  ADDWFC x6A,F
4632:  ADDWFC x6B,F
4634:  MOVFF  26B,3D9
4638:  MOVFF  26A,3D8
463C:  MOVFF  269,3D7
4640:  MOVFF  268,3D6
4644:  MOVLB  3
4646:  CLRF   xDB
4648:  MOVLW  02
464A:  MOVWF  xDA
464C:  MOVWF  xDD
464E:  MOVLW  64
4650:  MOVWF  xDC
4652:  MOVLB  0
4654:  CALL   198E
4658:  MOVF   01,W
465A:  MOVLB  2
465C:  ADDWF  x63,F
....................  
....................          if(ec != GOODEC) 
465E:  MOVF   x63,F
4660:  BZ    467A
....................          { 
....................             stream->Flags |= Write_Error; 
4662:  MOVLW  19
4664:  ADDWF  x61,W
4666:  MOVWF  FE9
4668:  MOVLW  00
466A:  ADDWFC x62,W
466C:  MOVWF  FEA
466E:  MOVF   FEF,W
4670:  IORLW  40
4672:  MOVWF  FEF
....................             return EOF; 
4674:  MOVLW  FF
4676:  MOVWF  01
4678:  BRA    4722
....................          } 
....................       } 
....................        
....................       // dump the remaining buffer to the card 
....................       if(fatflush(stream) == EOF) 
467A:  MOVFF  262,269
467E:  MOVFF  261,268
4682:  MOVLB  0
4684:  BRA    426E
4686:  MOVF   01,W
4688:  SUBLW  FF
468A:  BNZ   4696
....................          return EOF; 
468C:  MOVLW  FF
468E:  MOVWF  01
4690:  MOVLB  2
4692:  BRA    4722
4694:  MOVLB  0
....................    } 
....................    // nullify the data 
....................    stream->Cur_Char = 0; 
4696:  MOVLW  04
4698:  MOVLB  2
469A:  ADDWF  x61,W
469C:  MOVWF  FE9
469E:  MOVLW  00
46A0:  ADDWFC x62,W
46A2:  MOVWF  FEA
46A4:  MOVF   FEE,F
46A6:  MOVF   FEE,F
46A8:  CLRF   FEC
46AA:  MOVF   FED,F
46AC:  CLRF   FEF
46AE:  MOVF   FED,F
46B0:  CLRF   FEF
46B2:  MOVF   FED,F
46B4:  CLRF   FEF
....................    stream->Entry_Addr = 0; 
46B6:  MOVLW  08
46B8:  ADDWF  x61,W
46BA:  MOVWF  FE9
46BC:  MOVLW  00
46BE:  ADDWFC x62,W
46C0:  MOVWF  FEA
46C2:  MOVF   FEE,F
46C4:  MOVF   FEE,F
46C6:  CLRF   FEC
46C8:  MOVF   FED,F
46CA:  CLRF   FEF
46CC:  MOVF   FED,F
46CE:  CLRF   FEF
46D0:  MOVF   FED,F
46D2:  CLRF   FEF
....................    stream->Size = 0; 
46D4:  MOVLW  10
46D6:  ADDWF  x61,W
46D8:  MOVWF  FE9
46DA:  MOVLW  00
46DC:  ADDWFC x62,W
46DE:  MOVWF  FEA
46E0:  MOVF   FEE,F
46E2:  MOVF   FEE,F
46E4:  CLRF   FEC
46E6:  MOVF   FED,F
46E8:  CLRF   FEF
46EA:  MOVF   FED,F
46EC:  CLRF   FEF
46EE:  MOVF   FED,F
46F0:  CLRF   FEF
....................    stream->Start_Addr = 0; 
46F2:  MOVLW  14
46F4:  ADDWF  x61,W
46F6:  MOVWF  FE9
46F8:  MOVLW  00
46FA:  ADDWFC x62,W
46FC:  MOVWF  FEA
46FE:  MOVF   FEE,F
4700:  MOVF   FEE,F
4702:  CLRF   FEC
4704:  MOVF   FED,F
4706:  CLRF   FEF
4708:  MOVF   FED,F
470A:  CLRF   FEF
470C:  MOVF   FED,F
470E:  CLRF   FEF
....................    stream->Flags = 0; 
4710:  MOVLW  19
4712:  ADDWF  x61,W
4714:  MOVWF  FE9
4716:  MOVLW  00
4718:  ADDWFC x62,W
471A:  MOVWF  FEA
471C:  CLRF   FEF
....................    return 0; 
471E:  MOVLW  00
4720:  MOVWF  01
4722:  MOVLB  0
4724:  GOTO   4736 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatgetc(FILE* stream) 
.................... Summary: Gets a character from a stream. 
.................... Param: The stream to get a character from. 
.................... Returns: The character that was gotten from the stream, 
....................           EOF if the stream has reached the end of the file or doesn't have permissions to read, 
.................... */ 
.................... signed int fatgetc(FILE* stream) 
.................... { 
....................    char ch; // character read in 
....................  
....................    // check to see if the stream has proper permissions to read 
....................    if(stream->Flags & Read) 
*
4850:  MOVLW  19
4852:  MOVLB  2
4854:  ADDWF  x71,W
4856:  MOVWF  FE9
4858:  MOVLW  00
485A:  ADDWFC x72,W
485C:  MOVWF  FEA
485E:  BTFSS  FEF.0
4860:  BRA    495E
....................    { 
....................       // when the number of bytes until eof hit zero, we know we are at the end of any file 
....................       if(stream->Bytes_Until_EOF == 0) 
4862:  MOVFF  271,FE9
4866:  MOVFF  272,FEA
486A:  MOVFF  FEF,274
486E:  MOVFF  FEC,275
4872:  MOVFF  FEC,276
4876:  MOVFF  FEC,277
487A:  MOVF   x74,F
487C:  BNZ   48A2
487E:  MOVF   x75,F
4880:  BNZ   48A2
4882:  MOVF   x76,F
4884:  BNZ   48A2
4886:  MOVF   x77,F
4888:  BNZ   48A2
....................       { 
....................          stream->Flags |= EOF_Reached; 
488A:  MOVLW  19
488C:  ADDWF  x71,W
488E:  MOVWF  FE9
4890:  MOVLW  00
4892:  ADDWFC x72,W
4894:  MOVWF  FEA
4896:  MOVF   FEF,W
4898:  IORLW  10
489A:  MOVWF  FEF
....................          return EOF; 
489C:  MOVLW  FF
489E:  MOVWF  01
48A0:  BRA    4962
....................       } 
....................  
....................       // read in the next byte in the buffer 
....................       if(read_buffer(stream, &ch) == EOF) 
48A2:  MOVFF  272,275
48A6:  MOVFF  271,274
48AA:  MOVLW  02
48AC:  MOVWF  x77
48AE:  MOVLW  73
48B0:  MOVWF  x76
48B2:  MOVLB  0
48B4:  BRA    474C
48B6:  MOVF   01,W
48B8:  SUBLW  FF
48BA:  BNZ   48C6
....................          return EOF; 
48BC:  MOVLW  FF
48BE:  MOVWF  01
48C0:  MOVLB  2
48C2:  BRA    4962
48C4:  MOVLB  0
....................  
....................       // a 0x00 will signify the end of a non-binary file 
....................       if((ch == '\0') && !(stream->Flags & Binary)) 
48C6:  MOVLB  2
48C8:  MOVF   x73,F
48CA:  BNZ   48F4
48CC:  MOVLW  19
48CE:  ADDWF  x71,W
48D0:  MOVWF  FE9
48D2:  MOVLW  00
48D4:  ADDWFC x72,W
48D6:  MOVWF  FEA
48D8:  BTFSC  FEF.3
48DA:  BRA    48F4
....................       { 
....................          stream->Flags |= EOF_Reached; 
48DC:  MOVLW  19
48DE:  ADDWF  x71,W
48E0:  MOVWF  FE9
48E2:  MOVLW  00
48E4:  ADDWFC x72,W
48E6:  MOVWF  FEA
48E8:  MOVF   FEF,W
48EA:  IORLW  10
48EC:  MOVWF  FEF
....................          return EOF; 
48EE:  MOVLW  FF
48F0:  MOVWF  01
48F2:  BRA    4962
....................       } 
....................  
....................       // get the next contiguous address of the stream 
....................       if(get_next_addr(&(stream->Cur_Char)) != GOODEC) 
48F4:  MOVLW  04
48F6:  ADDWF  x71,W
48F8:  MOVWF  01
48FA:  MOVLW  00
48FC:  ADDWFC x72,W
48FE:  MOVWF  03
4900:  MOVFF  01,274
4904:  MOVWF  x75
4906:  MOVFF  FE8,396
490A:  MOVFF  01,395
490E:  MOVLB  0
4910:  CALL   1F52
4914:  MOVF   01,F
4916:  BZ    4922
....................          return EOF; 
4918:  MOVLW  FF
491A:  MOVWF  01
491C:  MOVLB  2
491E:  BRA    4962
4920:  MOVLB  0
....................           
....................       // we just got 1 byte closer to the end of the file 
....................       stream->Bytes_Until_EOF -= 1; 
4922:  MOVLB  2
4924:  MOVFF  271,FE9
4928:  MOVFF  272,FEA
492C:  MOVLW  01
492E:  SUBWF  FEF,W
4930:  MOVWF  00
4932:  MOVLW  00
4934:  SUBWFB FEC,W
4936:  MOVWF  01
4938:  MOVLW  00
493A:  SUBWFB FEC,W
493C:  MOVWF  02
493E:  MOVLW  00
4940:  SUBWFB FEC,W
4942:  MOVF   FED,F
4944:  MOVF   FED,F
4946:  MOVF   FED,F
4948:  MOVFF  00,FEF
494C:  MOVFF  01,FEC
4950:  MOVFF  02,FEC
4954:  MOVWF  FEC
....................       return ch; 
4956:  MOVFF  273,01
495A:  BRA    4962
....................    } 
495C:  BRA    4962
....................  
....................    // if the stream doesn't have proper permissions to read, return an EOF 
....................    else 
....................       return EOF; 
495E:  MOVLW  FF
4960:  MOVWF  01
4962:  MOVLB  0
4964:  GOTO   4972 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatputc(int ch, FILE* stream) 
.................... Summary: Puts a character into a stream. 
.................... Param ch: The character to put into the stream. 
.................... Param stream: The stream to put a character into. 
.................... Returns: The character that was put into the stream, 
....................           EOF if the stream doesn't have permissions to write, or if a problem happened. 
.................... */ 
.................... signed int fatputc(int ch, FILE* stream) 
.................... { 
....................    // check to see if the stream has proper permissions to write 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->File_Type == Data_File)) 
*
2248:  MOVLW  19
224A:  MOVLB  3
224C:  ADDWF  x91,W
224E:  MOVWF  FE9
2250:  MOVLW  00
2252:  ADDWFC x92,W
2254:  MOVWF  FEA
2256:  BTFSC  FEF.1
2258:  BRA    226A
225A:  MOVLW  19
225C:  ADDWF  x91,W
225E:  MOVWF  FE9
2260:  MOVLW  00
2262:  ADDWFC x92,W
2264:  MOVWF  FEA
2266:  BTFSS  FEF.2
2268:  BRA    251C
226A:  MOVLW  18
226C:  ADDWF  x91,W
226E:  MOVWF  FE9
2270:  MOVLW  00
2272:  ADDWFC x92,W
2274:  MOVWF  FEA
2276:  MOVF   FEF,F
2278:  BTFSS  FD8.2
227A:  BRA    251C
....................    { 
....................       // if there isn't any space allocated yet, allocate some 
....................       if(stream->Cur_Char < Data_Start) 
227C:  MOVLW  04
227E:  ADDWF  x91,W
2280:  MOVWF  FE9
2282:  MOVLW  00
2284:  ADDWFC x92,W
2286:  MOVWF  FEA
2288:  MOVFF  FEF,393
228C:  MOVFF  FEC,394
2290:  MOVFF  FEC,395
2294:  MOVFF  FEC,396
2298:  MOVF   x96,W
229A:  MOVLB  2
229C:  SUBWF  x15,W
229E:  BTFSS  FD8.0
22A0:  BRA    23A4
22A2:  BNZ   22D0
22A4:  MOVLB  3
22A6:  MOVF   x95,W
22A8:  MOVLB  2
22AA:  SUBWF  x14,W
22AC:  BTFSS  FD8.0
22AE:  BRA    23A4
22B0:  BNZ   22D0
22B2:  MOVLB  3
22B4:  MOVF   x94,W
22B6:  MOVLB  2
22B8:  SUBWF  x13,W
22BA:  BTFSS  FD8.0
22BC:  BRA    23A4
22BE:  BNZ   22D0
22C0:  MOVF   x12,W
22C2:  MOVLB  3
22C4:  SUBWF  x93,W
22C6:  BTFSS  FD8.0
22C8:  BRA    22CE
22CA:  MOVLB  2
22CC:  BRA    23A4
22CE:  MOVLB  2
....................       { 
....................          if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
22D0:  MOVLW  02
22D2:  MOVLB  3
22D4:  MOVWF  xA8
22D6:  MOVLW  1A
22D8:  MOVWF  xA7
22DA:  MOVLB  0
22DC:  RCALL  1BB0
22DE:  MOVF   01,W
22E0:  SUBLW  FF
22E2:  BNZ   22EA
....................             return EOF; 
22E4:  MOVLW  FF
22E6:  MOVWF  01
22E8:  BRA    2522
.................... #ifdef FAT32 
....................          if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
22EA:  MOVFF  21D,3AA
22EE:  MOVFF  21C,3A9
22F2:  MOVFF  21B,3A8
22F6:  MOVFF  21A,3A7
22FA:  MOVLW  0F
22FC:  MOVLB  3
22FE:  MOVWF  xAE
2300:  SETF   xAD
2302:  SETF   xAC
2304:  SETF   xAB
2306:  MOVLB  0
2308:  CALL   1A14
230C:  MOVF   01,W
230E:  SUBLW  FF
2310:  BNZ   2318
....................             return EOF; 
2312:  MOVLW  FF
2314:  MOVWF  01
2316:  BRA    2522
.................... #else // FAT16 
....................          if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................             return EOF; 
.................... #endif // #ifdef FAT32 
....................          if(clear_cluster(Next_Free_Clust) == EOF) 
2318:  MOVFF  21D,3AA
231C:  MOVFF  21C,3A9
2320:  MOVFF  21B,3A8
2324:  MOVFF  21A,3A7
2328:  RCALL  1D3C
232A:  MOVF   01,W
232C:  SUBLW  FF
232E:  BNZ   2336
....................             return EOF; 
2330:  MOVLW  FF
2332:  MOVWF  01
2334:  BRA    2522
....................          stream->Cur_Char = stream->Start_Addr = cluster_to_addr(Next_Free_Clust); 
2336:  MOVLW  04
2338:  MOVLB  3
233A:  ADDWF  x91,W
233C:  MOVWF  01
233E:  MOVLW  00
2340:  ADDWFC x92,W
2342:  MOVWF  03
2344:  MOVFF  01,393
2348:  MOVWF  x94
234A:  MOVLW  14
234C:  ADDWF  x91,W
234E:  MOVWF  01
2350:  MOVLW  00
2352:  ADDWFC x92,W
2354:  MOVWF  03
2356:  MOVFF  01,395
235A:  MOVWF  x96
235C:  MOVFF  21D,3D5
2360:  MOVFF  21C,3D4
2364:  MOVFF  21B,3D3
2368:  MOVFF  21A,3D2
236C:  MOVLB  0
236E:  CALL   13BE
2372:  MOVFF  396,FEA
2376:  MOVFF  395,FE9
237A:  MOVFF  00,FEF
237E:  MOVFF  01,FEC
2382:  MOVFF  02,FEC
2386:  MOVFF  03,FEC
238A:  MOVFF  394,FEA
238E:  MOVFF  393,FE9
2392:  MOVFF  00,FEF
2396:  MOVFF  01,FEC
239A:  MOVFF  02,FEC
239E:  MOVFF  03,FEC
23A2:  MOVLB  2
....................       } 
....................  
....................       // write the next character to the buffer 
....................       if(write_buffer(stream, ch) == EOF) 
23A4:  MOVFF  392,394
23A8:  MOVFF  391,393
23AC:  MOVFF  390,395
23B0:  MOVLB  0
23B2:  BRA    1DF8
23B4:  MOVF   01,W
23B6:  SUBLW  FF
23B8:  BNZ   23C0
....................          return EOF; 
23BA:  MOVLW  FF
23BC:  MOVWF  01
23BE:  BRA    2522
....................  
....................       // get the next address, increment Cur_Char 
....................       if(get_next_addr(&(stream->Cur_Char)) == EOF) 
23C0:  MOVLW  04
23C2:  MOVLB  3
23C4:  ADDWF  x91,W
23C6:  MOVWF  01
23C8:  MOVLW  00
23CA:  ADDWFC x92,W
23CC:  MOVWF  03
23CE:  MOVFF  01,393
23D2:  MOVWF  x94
23D4:  MOVWF  x96
23D6:  MOVFF  01,395
23DA:  MOVLB  0
23DC:  RCALL  1F52
23DE:  MOVF   01,W
23E0:  SUBLW  FF
23E2:  BTFSS  FD8.2
23E4:  BRA    24D8
....................       { 
....................          // write the current buffer to the end of the current cluster 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE + 1, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
23E6:  MOVLW  04
23E8:  MOVLB  3
23EA:  ADDWF  x91,W
23EC:  MOVWF  FE9
23EE:  MOVLW  00
23F0:  ADDWFC x92,W
23F2:  MOVWF  FEA
23F4:  MOVFF  FEF,393
23F8:  MOVFF  FEC,394
23FC:  MOVFF  FEC,395
2400:  MOVFF  FEC,396
2404:  MOVLW  20
2406:  SUBWF  x93,F
2408:  MOVLW  00
240A:  SUBWFB x94,F
240C:  SUBWFB x95,F
240E:  SUBWFB x96,F
2410:  MOVLW  01
2412:  ADDWF  x93,F
2414:  MOVLW  00
2416:  ADDWFC x94,F
2418:  ADDWFC x95,F
241A:  ADDWFC x96,F
241C:  MOVLW  1A
241E:  ADDWF  x91,W
2420:  MOVWF  01
2422:  MOVLW  00
2424:  ADDWFC x92,W
2426:  MOVWF  03
2428:  MOVFF  01,397
242C:  MOVWF  x98
242E:  MOVFF  396,3D9
2432:  MOVFF  395,3D8
2436:  MOVFF  394,3D7
243A:  MOVFF  393,3D6
243E:  CLRF   xDB
2440:  MOVLW  20
2442:  MOVWF  xDA
2444:  MOVFF  03,3DD
2448:  MOVFF  01,3DC
244C:  MOVLB  0
244E:  CALL   198E
2452:  MOVF   01,F
2454:  BZ    2472
....................          { 
....................             stream->Flags |= Write_Error; 
2456:  MOVLW  19
2458:  MOVLB  3
245A:  ADDWF  x91,W
245C:  MOVWF  FE9
245E:  MOVLW  00
2460:  ADDWFC x92,W
2462:  MOVWF  FEA
2464:  MOVF   FEF,W
2466:  IORLW  40
2468:  MOVWF  FEF
....................             return EOF; 
246A:  MOVLW  FF
246C:  MOVWF  01
246E:  MOVLB  0
2470:  BRA    2522
....................          } 
....................          // start looking for a new cluster to allocate 
....................          if(alloc_clusters(addr_to_cluster(stream->Cur_Char), &(stream->Cur_Char)) == EOF) 
2472:  MOVLW  04
2474:  MOVLB  3
2476:  ADDWF  x91,W
2478:  MOVWF  FE9
247A:  MOVLW  00
247C:  ADDWFC x92,W
247E:  MOVWF  FEA
2480:  MOVFF  FEF,3A0
2484:  MOVFF  FEC,3A1
2488:  MOVFF  FEC,3A2
248C:  MOVFF  FEC,3A3
2490:  MOVLB  0
2492:  CALL   1268
2496:  MOVFF  03,39C
249A:  MOVFF  02,395
249E:  MOVFF  01,39A
24A2:  MOVFF  00,393
24A6:  MOVLW  04
24A8:  MOVLB  3
24AA:  ADDWF  x91,W
24AC:  MOVWF  01
24AE:  MOVLW  00
24B0:  ADDWFC x92,W
24B2:  MOVWF  03
24B4:  MOVFF  01,397
24B8:  MOVWF  x98
24BA:  MOVFF  02,39B
24BE:  MOVFF  00,399
24C2:  MOVWF  x9E
24C4:  MOVFF  01,39D
24C8:  MOVLB  0
24CA:  RCALL  2156
24CC:  MOVF   01,W
24CE:  SUBLW  FF
24D0:  BNZ   24D8
....................             return EOF; 
24D2:  MOVLW  FF
24D4:  MOVWF  01
24D6:  BRA    2522
....................       } 
....................  
....................       // our file just got bigger by 1 byte 
....................       stream->Size += 1; 
24D8:  MOVLW  10
24DA:  MOVLB  3
24DC:  ADDWF  x91,W
24DE:  MOVWF  FE9
24E0:  MOVLW  00
24E2:  ADDWFC x92,W
24E4:  MOVWF  FEA
24E6:  MOVLW  01
24E8:  ADDWF  FEF,W
24EA:  MOVWF  00
24EC:  MOVLW  00
24EE:  ADDWFC FEC,W
24F0:  MOVWF  01
24F2:  MOVLW  00
24F4:  ADDWFC FEC,W
24F6:  MOVWF  02
24F8:  MOVLW  00
24FA:  ADDWFC FEC,W
24FC:  MOVF   FED,F
24FE:  MOVF   FED,F
2500:  MOVF   FED,F
2502:  MOVFF  00,FEF
2506:  MOVFF  01,FEC
250A:  MOVFF  02,FEC
250E:  MOVWF  FEC
....................  
....................       return ch; 
2510:  MOVFF  390,01
2514:  MOVLB  0
2516:  BRA    2522
....................    } 
2518:  BRA    2522
251A:  MOVLB  3
....................  
....................    // if the stream doesn't have proper permissions to write, return an EOF 
....................    else 
....................       return EOF; 
251C:  MOVLW  FF
251E:  MOVWF  01
2520:  MOVLB  0
2522:  RETURN 0
.................... } 
....................  
.................... /* 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... Summary: Reads characters from a stream into a string. 
.................... Param str: A pointer to the beginning of the string to put characters into. 
.................... Param num: The number of characters to put into the string - 1. 
.................... Param stream: The stream to read from. 
.................... Returns: A pointer to the most recently added character, or NULL if there was an error. 
.................... Note: If a newline is read from the stream, then str will be terminated with a newline. 
....................        If num - 1 or EOF is reached, then str will be null terminated. 
.................... */ 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... { 
....................    int i;   // counter for loops 
....................  
....................    // loop until num - 1 
....................    for(i = 0; i < num - 1; i += 1) 
....................    { 
....................       str[i] = fatgetc(stream); 
....................       if(str[i] == '\n') 
....................          return str; 
....................       if(str[i] == EOF) 
....................          break; 
....................    } 
....................  
....................    // close off str with a null terminator 
....................    str[i] = '\0'; 
....................  
....................    return str; 
.................... } 
....................  
.................... /* 
.................... signed int fatputs(char* str, FILE* stream) 
.................... Summary: Writes characters from a string into a stream. 
.................... Param str: A pointer to the beginning of the string to write into the stream. 
.................... Param stream: The stream to write into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatputs(char* str, FILE* stream) 
*
4188:  MOVLB  2
418A:  CLRF   x98
.................... { 
....................    int i = 0;   // counter for loops 
....................  
....................    // fatputc every character in the stream 
....................    while(str[i] != '\0') 
418C:  MOVF   x98,W
418E:  ADDWF  x94,W
4190:  MOVWF  FE9
4192:  MOVLW  00
4194:  ADDWFC x95,W
4196:  MOVWF  FEA
4198:  MOVF   FEF,F
419A:  BZ    41CE
....................    { 
....................       if(fatputc(str[i], stream) == EOF) 
419C:  MOVF   x98,W
419E:  ADDWF  x94,W
41A0:  MOVWF  FE9
41A2:  MOVLW  00
41A4:  ADDWFC x95,W
41A6:  MOVWF  FEA
41A8:  MOVFF  FEF,390
41AC:  MOVFF  297,392
41B0:  MOVFF  296,391
41B4:  MOVLB  0
41B6:  CALL   2248
41BA:  MOVF   01,W
41BC:  SUBLW  FF
41BE:  BNZ   41C6
....................         return EOF; 
41C0:  MOVLW  FF
41C2:  MOVWF  01
41C4:  BRA    41D4
....................       i += 1; 
41C6:  MOVLW  01
41C8:  MOVLB  2
41CA:  ADDWF  x98,F
41CC:  BRA    418C
....................    } 
....................  
....................    return GOODEC; 
41CE:  MOVLW  00
41D0:  MOVWF  01
41D2:  MOVLB  0
41D4:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatprintf(FILE* stream) 
.................... Summary: This will print off the entire contents of the stream to the console. 
.................... Param: The stream to print off. 
.................... Returns: The last character printed off to the console. 
.................... */ 
.................... signed int fatprintf(FILE* stream) 
.................... { 
....................    signed int ch; // character read in 
....................  
....................    // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................    do 
....................    { 
....................       ch = fatgetc(stream); 
*
4968:  MOVFF  26F,272
496C:  MOVFF  26E,271
4970:  BRA    4850
4972:  MOVFF  01,270
....................       printf("%c", ch); 
4976:  MOVFF  270,296
497A:  CALL   02E4
....................    } while(ch != EOF); 
497E:  MOVLB  2
4980:  MOVF   x70,W
4982:  SUBLW  FF
4984:  BTFSC  FD8.2
4986:  BRA    498C
4988:  MOVLB  0
498A:  BRA    4968
....................  
....................    return ch; 
498C:  MOVFF  270,01
4990:  MOVLB  0
4992:  GOTO   49F6 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param stream: The stream to get the position of. 
.................... Param position: A pointer to a variable put the current position of the pointer into. 
.................... Returns: 0 on success. 
.................... */ 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... { 
....................    *position = stream->Size - stream->Bytes_Until_EOF; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Sets the current position of where the stream is pointing to in memory relative to the beginning of the stream. 
.................... Param stream: The stream to set the position of. 
.................... Param position: A pointer the a variable that has the value of the new position. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... { 
.................... #ifndef FAST_FAT 
.................... #ifdef FAT32 
....................    int32 cur_cluster; // the current cluster we're pointing to 
.................... #else // FAT16 
....................    int16 cur_cluster; // the current cluster we're pointing to 
.................... #endif // #ifdef FAT32 
....................    int32 i;    // pointer to memory 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // check to see if we want to just rewind the file 
....................    if(*position == 0) 
*
2524:  MOVFF  387,03
2528:  MOVLB  3
252A:  MOVFF  386,FE9
252E:  MOVFF  387,FEA
2532:  MOVFF  FEF,390
2536:  MOVFF  FEC,391
253A:  MOVFF  FEC,392
253E:  MOVFF  FEC,393
2542:  MOVF   x90,F
2544:  BNZ   2568
2546:  MOVF   x91,F
2548:  BNZ   2568
254A:  MOVF   x92,F
254C:  BNZ   2568
254E:  MOVF   x93,F
2550:  BNZ   2568
....................    { 
....................       rewind(stream); 
2552:  MOVFF  385,391
2556:  MOVFF  384,390
255A:  MOVLB  0
255C:  GOTO   1B2E
....................       return GOODEC; 
2560:  MOVLW  00
2562:  MOVWF  01
2564:  BRA    2914
2566:  MOVLB  3
....................    } 
....................     
....................    // this whole process is much different and easier if we're writing or appending at a spot after EOF 
....................    //  this will essentially write null characters to the file from EOF to the desired position 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->Size < *position)) 
2568:  MOVLW  19
256A:  ADDWF  x84,W
256C:  MOVWF  FE9
256E:  MOVLW  00
2570:  ADDWFC x85,W
2572:  MOVWF  FEA
2574:  BTFSC  FEF.1
2576:  BRA    2588
2578:  MOVLW  19
257A:  ADDWF  x84,W
257C:  MOVWF  FE9
257E:  MOVLW  00
2580:  ADDWFC x85,W
2582:  MOVWF  FEA
2584:  BTFSS  FEF.2
2586:  BRA    2654
2588:  MOVLW  10
258A:  ADDWF  x84,W
258C:  MOVWF  FE9
258E:  MOVLW  00
2590:  ADDWFC x85,W
2592:  MOVWF  FEA
2594:  MOVFF  FEF,390
2598:  MOVFF  FEC,391
259C:  MOVFF  FEC,392
25A0:  MOVFF  FEC,393
25A4:  MOVFF  386,FE9
25A8:  MOVFF  387,FEA
25AC:  MOVFF  FEF,00
25B0:  MOVFF  FEC,01
25B4:  MOVFF  FEC,02
25B8:  MOVFF  FEC,03
25BC:  MOVF   x93,W
25BE:  SUBWF  03,W
25C0:  BNC   2654
25C2:  BNZ   25DA
25C4:  MOVF   x92,W
25C6:  SUBWF  02,W
25C8:  BNC   2654
25CA:  BNZ   25DA
25CC:  MOVF   x91,W
25CE:  SUBWF  01,W
25D0:  BNC   2654
25D2:  BNZ   25DA
25D4:  MOVF   00,W
25D6:  SUBWF  x90,W
25D8:  BC    2654
....................    { 
....................       while(stream->Size < *position) 
25DA:  MOVLW  10
25DC:  ADDWF  x84,W
25DE:  MOVWF  FE9
25E0:  MOVLW  00
25E2:  ADDWFC x85,W
25E4:  MOVWF  FEA
25E6:  MOVFF  FEF,390
25EA:  MOVFF  FEC,391
25EE:  MOVFF  FEC,392
25F2:  MOVFF  FEC,393
25F6:  MOVFF  386,FE9
25FA:  MOVFF  387,FEA
25FE:  MOVFF  FEF,00
2602:  MOVFF  FEC,01
2606:  MOVFF  FEC,02
260A:  MOVFF  FEC,03
260E:  MOVF   x93,W
2610:  SUBWF  03,W
2612:  BNC   264A
2614:  BNZ   262C
2616:  MOVF   x92,W
2618:  SUBWF  02,W
261A:  BNC   264A
261C:  BNZ   262C
261E:  MOVF   x91,W
2620:  SUBWF  01,W
2622:  BNC   264A
2624:  BNZ   262C
2626:  MOVF   00,W
2628:  SUBWF  x90,W
262A:  BC    264A
....................          if(fatputc('\0', stream) == EOF) 
262C:  CLRF   x90
262E:  MOVFF  385,392
2632:  MOVFF  384,391
2636:  MOVLB  0
2638:  RCALL  2248
263A:  MOVF   01,W
263C:  SUBLW  FF
263E:  BNZ   2646
....................             return EOF; 
2640:  MOVLW  FF
2642:  MOVWF  01
2644:  BRA    2914
2646:  MOVLB  3
2648:  BRA    25DA
....................        
....................       return 0; 
264A:  MOVLW  00
264C:  MOVWF  01
264E:  MOVLB  0
2650:  BRA    2914
2652:  MOVLB  3
....................    } 
....................  
.................... #ifdef FAST_FAT 
....................    stream->Cur_Char = stream->Start_Addr + *position; 
.................... #else // NO FAST_FAT 
....................    // figure out how many clusters into the file the position is to be set to 
....................    i = *position / Bytes_Per_Cluster; 
2654:  MOVFF  387,03
2658:  MOVFF  386,FE9
265C:  MOVFF  387,FEA
2660:  MOVFF  FEF,3A8
2664:  MOVFF  FEC,3A9
2668:  MOVFF  FEC,3AA
266C:  MOVFF  FEC,3AB
2670:  MOVFF  FEA,395
2674:  MOVFF  FE9,394
2678:  BCF    FD8.1
267A:  CLRF   xAF
267C:  CLRF   xAE
267E:  MOVFF  20D,3AD
2682:  MOVFF  20C,3AC
2686:  MOVLB  0
2688:  CALL   11D4
268C:  MOVFF  395,FEA
2690:  MOVFF  394,FE9
2694:  MOVFF  03,38F
2698:  MOVFF  02,38E
269C:  MOVFF  01,38D
26A0:  MOVFF  00,38C
....................    cur_cluster = addr_to_cluster(stream->Start_Addr); 
26A4:  MOVLW  14
26A6:  MOVLB  3
26A8:  ADDWF  x84,W
26AA:  MOVWF  FE9
26AC:  MOVLW  00
26AE:  ADDWFC x85,W
26B0:  MOVWF  FEA
26B2:  MOVFF  FEF,3A0
26B6:  MOVFF  FEC,3A1
26BA:  MOVFF  FEC,3A2
26BE:  MOVFF  FEC,3A3
26C2:  MOVLB  0
26C4:  CALL   1268
26C8:  MOVFF  03,38B
26CC:  MOVFF  02,38A
26D0:  MOVFF  01,389
26D4:  MOVFF  00,388
....................  
....................    // head to that cluster 
....................    while(i > 0) 
26D8:  MOVLB  3
26DA:  MOVF   x8C,F
26DC:  BNZ   26EA
26DE:  MOVF   x8D,F
26E0:  BNZ   26EA
26E2:  MOVF   x8E,F
26E4:  BNZ   26EA
26E6:  MOVF   x8F,F
26E8:  BZ    2712
....................    { 
....................       if(get_next_cluster(&cur_cluster) != GOODEC) 
26EA:  MOVLW  03
26EC:  MOVWF  x9C
26EE:  MOVLW  88
26F0:  MOVWF  x9B
26F2:  MOVLB  0
26F4:  CALL   18BA
26F8:  MOVF   01,F
26FA:  BZ    2702
....................          return EOF; 
26FC:  MOVLW  FF
26FE:  MOVWF  01
2700:  BRA    2914
....................       i -= 1; 
2702:  MOVLW  01
2704:  MOVLB  3
2706:  SUBWF  x8C,F
2708:  MOVLW  00
270A:  SUBWFB x8D,F
270C:  SUBWFB x8E,F
270E:  SUBWFB x8F,F
2710:  BRA    26DA
....................    } 
....................  
....................    // head to the correct cluster 
....................    stream->Cur_Char = cluster_to_addr(cur_cluster); 
2712:  MOVLW  04
2714:  ADDWF  x84,W
2716:  MOVWF  01
2718:  MOVLW  00
271A:  ADDWFC x85,W
271C:  MOVWF  03
271E:  MOVFF  01,390
2722:  MOVWF  x91
2724:  MOVFF  38B,3D5
2728:  MOVFF  38A,3D4
272C:  MOVFF  389,3D3
2730:  MOVFF  388,3D2
2734:  MOVLB  0
2736:  CALL   13BE
273A:  MOVFF  391,FEA
273E:  MOVFF  390,FE9
2742:  MOVFF  00,FEF
2746:  MOVFF  01,FEC
274A:  MOVFF  02,FEC
274E:  MOVFF  03,FEC
....................  
....................    // now that we're in the correct cluster, tack on the remaining position 
....................    stream->Cur_Char += (*position % Bytes_Per_Cluster); 
2752:  MOVLW  04
2754:  MOVLB  3
2756:  ADDWF  x84,W
2758:  MOVWF  01
275A:  MOVLW  00
275C:  ADDWFC x85,W
275E:  MOVFF  01,390
2762:  MOVWF  x91
2764:  MOVWF  FEA
2766:  MOVFF  01,FE9
276A:  MOVFF  FEF,392
276E:  MOVFF  FEC,393
2772:  MOVFF  FEC,394
2776:  MOVFF  FEC,395
277A:  MOVFF  387,03
277E:  MOVFF  386,FE9
2782:  MOVFF  387,FEA
2786:  MOVFF  FEF,3A8
278A:  MOVFF  FEC,3A9
278E:  MOVFF  FEC,3AA
2792:  MOVFF  FEC,3AB
2796:  MOVFF  FEA,39B
279A:  MOVFF  FE9,39A
279E:  BSF    FD8.1
27A0:  MOVLW  03
27A2:  MOVWF  FEA
27A4:  MOVLW  9C
27A6:  MOVWF  FE9
27A8:  CLRF   xAF
27AA:  CLRF   xAE
27AC:  MOVFF  20D,3AD
27B0:  MOVFF  20C,3AC
27B4:  MOVLB  0
27B6:  CALL   11D4
27BA:  MOVFF  39C,00
27BE:  MOVFF  39D,01
27C2:  MOVFF  39E,02
27C6:  MOVFF  39F,03
27CA:  MOVFF  39B,FEA
27CE:  MOVFF  39A,FE9
27D2:  MOVLB  3
27D4:  MOVF   x92,W
27D6:  ADDWF  00,F
27D8:  MOVF   x93,W
27DA:  ADDWFC 01,F
27DC:  MOVF   x94,W
27DE:  ADDWFC 02,F
27E0:  MOVF   x95,W
27E2:  ADDWFC 03,F
27E4:  MOVFF  391,FEA
27E8:  MOVFF  390,FE9
27EC:  MOVFF  00,FEF
27F0:  MOVFF  01,FEC
27F4:  MOVFF  02,FEC
27F8:  MOVFF  03,FEC
....................  
....................    if(stream->Flags & Read) 
27FC:  MOVLW  19
27FE:  ADDWF  x84,W
2800:  MOVWF  FE9
2802:  MOVLW  00
2804:  ADDWFC x85,W
2806:  MOVWF  FEA
2808:  BTFSS  FEF.0
280A:  BRA    28D2
....................    { 
....................       // we now need to change how far it is until EOF 
....................       stream->Bytes_Until_EOF = stream->Size - *position; 
280C:  MOVLW  10
280E:  ADDWF  x84,W
2810:  MOVWF  FE9
2812:  MOVLW  00
2814:  ADDWFC x85,W
2816:  MOVWF  FEA
2818:  MOVFF  FEF,392
281C:  MOVFF  FEC,393
2820:  MOVFF  FEC,394
2824:  MOVFF  FEC,395
2828:  MOVFF  386,FE9
282C:  MOVFF  387,FEA
2830:  MOVFF  FEF,00
2834:  MOVFF  FEC,01
2838:  MOVFF  FEC,02
283C:  MOVFF  FEC,03
2840:  MOVF   00,W
2842:  SUBWF  x92,W
2844:  MOVWF  00
2846:  MOVF   01,W
2848:  SUBWFB x93,W
284A:  MOVWF  01
284C:  MOVF   02,W
284E:  SUBWFB x94,W
2850:  MOVWF  02
2852:  MOVF   03,W
2854:  SUBWFB x95,W
2856:  MOVFF  385,FEA
285A:  MOVFF  384,FE9
285E:  MOVFF  00,FEF
2862:  MOVFF  01,FEC
2866:  MOVFF  02,FEC
286A:  MOVWF  FEC
....................  
....................       // fill up the buffer 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
286C:  MOVLW  04
286E:  ADDWF  x84,W
2870:  MOVWF  FE9
2872:  MOVLW  00
2874:  ADDWFC x85,W
2876:  MOVWF  FEA
2878:  MOVFF  FEF,3BD
287C:  MOVFF  FEC,3BE
2880:  MOVFF  FEC,3BF
2884:  MOVFF  FEC,3C0
2888:  MOVLW  1A
288A:  ADDWF  x84,W
288C:  MOVWF  01
288E:  MOVLW  00
2890:  ADDWFC x85,W
2892:  MOVWF  03
2894:  MOVFF  01,394
2898:  MOVWF  x95
289A:  CLRF   xC2
289C:  MOVLW  20
289E:  MOVWF  xC1
28A0:  MOVFF  03,3C4
28A4:  MOVFF  01,3C3
28A8:  MOVLB  0
28AA:  CALL   0A80
28AE:  MOVF   01,F
28B0:  BZ    28CE
....................       { 
....................          stream->Flags |= Read_Error; 
28B2:  MOVLW  19
28B4:  MOVLB  3
28B6:  ADDWF  x84,W
28B8:  MOVWF  FE9
28BA:  MOVLW  00
28BC:  ADDWFC x85,W
28BE:  MOVWF  FEA
28C0:  MOVF   FEF,W
28C2:  IORLW  20
28C4:  MOVWF  FEF
....................          return EOF; 
28C6:  MOVLW  FF
28C8:  MOVWF  01
28CA:  MOVLB  0
28CC:  BRA    2914
....................       } 
....................    } 
28CE:  BRA    2910
28D0:  MOVLB  3
....................  
....................    else 
....................       stream->Size = *position; 
28D2:  MOVLW  10
28D4:  ADDWF  x84,W
28D6:  MOVWF  01
28D8:  MOVLW  00
28DA:  ADDWFC x85,W
28DC:  MOVFF  01,390
28E0:  MOVFF  386,FE9
28E4:  MOVFF  387,FEA
28E8:  MOVFF  FEF,00
28EC:  MOVFF  FEC,01
28F0:  MOVFF  FEC,02
28F4:  MOVFF  FEC,03
28F8:  MOVWF  FEA
28FA:  MOVFF  390,FE9
28FE:  MOVFF  00,FEF
2902:  MOVFF  01,FEC
2906:  MOVFF  02,FEC
290A:  MOVFF  03,FEC
290E:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
....................    return 0; 
2910:  MOVLW  00
2912:  MOVWF  01
2914:  GOTO   2E04 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... Summary: This will set the position of the file stream according to the input. The EOF flag will also be cleared. 
.................... Param stream: The stream to set the position of. 
.................... Param offset: How many bytes relative of origin the file stream position will be set. 
.................... Param origin: This will be one of 3 values... 
....................                SEEK_CUR: Set position relative to the current stream position. 
....................                SEEK_END: Set position relative to the end of the stream. 
....................                SEEK_SET: Set position relative to the beginning of the stream. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... { 
....................    int32 myoffset;   // since fatsetpos requires a pointer to a variable, we need this here 
....................  
....................    switch(origin) 
....................    { 
....................       case SEEK_CUR: 
....................          myoffset = stream->Cur_Char + offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_END: 
....................          myoffset = stream->Size - offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_SET: 
....................          myoffset = offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // clear the EOF flag 
....................    stream->Flags &= 0xEF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fateof(FILE* stream) 
.................... Summary: Determines whether or not the stream is at the end of the file. 
.................... Param: The stream to query for EOF. 
.................... Returns: A non-zero value if the file is at EOF, 
....................           0 if the file is not at EOF. 
.................... */ 
.................... signed int fateof(FILE* stream) 
.................... { 
....................    return stream->Flags & EOF_Reached; 
.................... } 
....................  
.................... /* 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... Summary: Fills up an array with data from a stream. 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to fill in the array. 
.................... Param stream: The stream to read from. 
.................... Returns: How many values were written to the array. 
.................... */ 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // fill up every byte 
....................    for(i = 0; i < (num * size); i += 1) 
....................       buffer[i] = fatgetc(stream); 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... Summary: Fills up a stream with data from an array 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to write to the stream. 
.................... Param stream: The stream to write to. 
.................... Returns: How many values were written to the stream. 
.................... */ 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // write every byte 
....................    for(i = 0; i < (count * (int32)size); i += 1) 
....................       if(fatputc(buffer[i], stream) == EOF) 
....................          return EOF; 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatflush(FILE* stream) 
.................... Summary: Flushes the buffer of a given stream. 
.................... Param: The stream to flush the buffer of. 
.................... Returns: EOF if there was a problem, 0 if everything went okay 
.................... */ 
.................... signed int fatflush(FILE* stream) 
.................... { 
....................    // check to see if we have a buffer 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
*
426E:  MOVLW  19
4270:  MOVLB  2
4272:  ADDWF  x68,W
4274:  MOVWF  FE9
4276:  MOVLW  00
4278:  ADDWFC x69,W
427A:  MOVWF  FEA
427C:  BTFSC  FEF.1
427E:  BRA    4290
4280:  MOVLW  19
4282:  ADDWF  x68,W
4284:  MOVWF  FE9
4286:  MOVLW  00
4288:  ADDWFC x69,W
428A:  MOVWF  FEA
428C:  BTFSS  FEF.2
428E:  BRA    4400
....................    { 
....................       // check to see if we need to flush the buffer 
....................       if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
4290:  MOVLW  04
4292:  ADDWF  x68,W
4294:  MOVWF  FE9
4296:  MOVLW  00
4298:  ADDWFC x69,W
429A:  MOVWF  FEA
429C:  MOVFF  FEF,26A
42A0:  MOVFF  FEC,26B
42A4:  MOVFF  FEC,26C
42A8:  MOVFF  FEC,26D
42AC:  MOVLW  1F
42AE:  ANDWF  x6A,F
42B0:  CLRF   x6B
42B2:  CLRF   x6C
42B4:  CLRF   x6D
42B6:  MOVF   x6A,F
42B8:  BNZ   434A
42BA:  MOVF   x6B,F
42BC:  BNZ   434A
42BE:  MOVF   x6C,F
42C0:  BNZ   434A
42C2:  MOVF   x6D,F
42C4:  BNZ   434A
....................       { 
....................          // flush the buffer to the card 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
42C6:  MOVLW  04
42C8:  ADDWF  x68,W
42CA:  MOVWF  FE9
42CC:  MOVLW  00
42CE:  ADDWFC x69,W
42D0:  MOVWF  FEA
42D2:  MOVFF  FEF,26A
42D6:  MOVFF  FEC,26B
42DA:  MOVFF  FEC,26C
42DE:  MOVFF  FEC,26D
42E2:  MOVLW  20
42E4:  SUBWF  x6A,F
42E6:  MOVLW  00
42E8:  SUBWFB x6B,F
42EA:  SUBWFB x6C,F
42EC:  SUBWFB x6D,F
42EE:  MOVLW  1A
42F0:  ADDWF  x68,W
42F2:  MOVWF  01
42F4:  MOVLW  00
42F6:  ADDWFC x69,W
42F8:  MOVWF  03
42FA:  MOVFF  01,26E
42FE:  MOVWF  x6F
4300:  MOVFF  26D,3D9
4304:  MOVFF  26C,3D8
4308:  MOVFF  26B,3D7
430C:  MOVFF  26A,3D6
4310:  MOVLB  3
4312:  CLRF   xDB
4314:  MOVLW  20
4316:  MOVWF  xDA
4318:  MOVFF  03,3DD
431C:  MOVFF  01,3DC
4320:  MOVLB  0
4322:  CALL   198E
4326:  MOVF   01,F
4328:  BZ    4346
....................          { 
....................             stream->Flags |= Write_Error; 
432A:  MOVLW  19
432C:  MOVLB  2
432E:  ADDWF  x68,W
4330:  MOVWF  FE9
4332:  MOVLW  00
4334:  ADDWFC x69,W
4336:  MOVWF  FEA
4338:  MOVF   FEF,W
433A:  IORLW  40
433C:  MOVWF  FEF
....................             return EOF; 
433E:  MOVLW  FF
4340:  MOVWF  01
4342:  BRA    4404
4344:  MOVLB  0
....................          } 
....................       } 
4346:  BRA    43F6
4348:  MOVLB  2
....................       else 
....................       { 
....................          // flush the buffer to the card 
....................          //  we need to make sure that the buffer gets flushed into the proper location, hence all this weird % math 
....................          if(mmcsd_write_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
434A:  MOVLW  04
434C:  ADDWF  x68,W
434E:  MOVWF  FE9
4350:  MOVLW  00
4352:  ADDWFC x69,W
4354:  MOVWF  FEA
4356:  MOVFF  FEF,26A
435A:  MOVFF  FEC,26B
435E:  MOVFF  FEC,26C
4362:  MOVFF  FEC,26D
4366:  MOVLW  04
4368:  ADDWF  x68,W
436A:  MOVWF  FE9
436C:  MOVLW  00
436E:  ADDWFC x69,W
4370:  MOVWF  FEA
4372:  MOVFF  FEF,26E
4376:  MOVFF  FEC,26F
437A:  MOVFF  FEC,270
437E:  MOVFF  FEC,271
4382:  MOVF   x6E,W
4384:  ANDLW  1F
4386:  MOVWF  00
4388:  CLRF   01
438A:  CLRF   02
438C:  CLRF   03
438E:  MOVF   00,W
4390:  SUBWF  x6A,F
4392:  MOVF   01,W
4394:  SUBWFB x6B,F
4396:  MOVF   02,W
4398:  SUBWFB x6C,F
439A:  MOVF   03,W
439C:  SUBWFB x6D,F
439E:  MOVLW  1A
43A0:  ADDWF  x68,W
43A2:  MOVWF  01
43A4:  MOVLW  00
43A6:  ADDWFC x69,W
43A8:  MOVWF  03
43AA:  MOVFF  01,26E
43AE:  MOVWF  x6F
43B0:  MOVFF  26D,3D9
43B4:  MOVFF  26C,3D8
43B8:  MOVFF  26B,3D7
43BC:  MOVFF  26A,3D6
43C0:  MOVLB  3
43C2:  CLRF   xDB
43C4:  MOVLW  20
43C6:  MOVWF  xDA
43C8:  MOVFF  03,3DD
43CC:  MOVFF  01,3DC
43D0:  MOVLB  0
43D2:  CALL   198E
43D6:  MOVF   01,F
43D8:  BZ    43F6
....................          { 
....................             stream->Flags |= Write_Error; 
43DA:  MOVLW  19
43DC:  MOVLB  2
43DE:  ADDWF  x68,W
43E0:  MOVWF  FE9
43E2:  MOVLW  00
43E4:  ADDWFC x69,W
43E6:  MOVWF  FEA
43E8:  MOVF   FEF,W
43EA:  IORLW  40
43EC:  MOVWF  FEF
....................             return EOF; 
43EE:  MOVLW  FF
43F0:  MOVWF  01
43F2:  BRA    4404
43F4:  MOVLB  0
....................          } 
....................       } 
....................       return(mmcsd_flush_buffer()); 
43F6:  CALL   094A
43FA:  MOVF   01,W
43FC:  MOVLB  2
43FE:  BRA    4404
....................    } 
....................    return 0; 
4400:  MOVLW  00
4402:  MOVWF  01
4404:  MOVLB  0
4406:  GOTO   4686 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int remove(char* fname) 
.................... Summary: Removes a file from disk. 
.................... Param: The full path of the file to remove. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... Note: This function does not work for removing directories, use rm_dir instead. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int remove(char* fname) 
.................... { 
....................    if(rm_file(fname) == EOF) 
....................        return EOF; 
....................  
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int faterror(FILE* stream) 
.................... Summary: Checks for an error in a given stream. 
.................... Param: The stream to check for an error in. 
.................... Returns: A non-zero value of there is an error in the stream, 
....................           0 if there is no error in the stream 
.................... */ 
.................... signed int faterror(FILE* stream) 
.................... { 
....................    return stream->Flags & 0xF0; 
.................... } 
....................  
.................... /* 
.................... void clearerr(FILE* stream) 
.................... Summary: Clears off all error in a given stream. 
.................... Param: The stream to clear off the errors in. 
.................... Returns: Nothing. 
.................... */ 
.................... void clearerr(FILE* stream) 
.................... { 
....................    stream->Flags &= 0x0F; 
.................... } 
....................  
.................... /* 
.................... void rewind(FILE* stream) 
.................... Summary: Sets the stream to point back to the beginning of a file. 
.................... Param: The stream to rewind. 
.................... Returns: Nothing. 
.................... */ 
.................... void rewind(FILE* stream) 
.................... { 
....................    // set the stream back to the beginning 
....................    stream->Cur_Char = stream->Start_Addr; 
*
1B2E:  MOVLW  04
1B30:  MOVLB  3
1B32:  ADDWF  x90,W
1B34:  MOVWF  01
1B36:  MOVLW  00
1B38:  ADDWFC x91,W
1B3A:  MOVWF  03
1B3C:  MOVFF  01,392
1B40:  MOVWF  x93
1B42:  MOVLW  14
1B44:  ADDWF  x90,W
1B46:  MOVWF  FE9
1B48:  MOVLW  00
1B4A:  ADDWFC x91,W
1B4C:  MOVWF  FEA
1B4E:  MOVFF  FEF,00
1B52:  MOVFF  FEC,01
1B56:  MOVFF  FEC,02
1B5A:  MOVFF  FEC,03
1B5E:  MOVFF  393,FEA
1B62:  MOVFF  392,FE9
1B66:  MOVFF  00,FEF
1B6A:  MOVFF  01,FEC
1B6E:  MOVFF  02,FEC
1B72:  MOVFF  03,FEC
....................    stream->Bytes_Until_EOF = stream->Size; 
1B76:  MOVLW  10
1B78:  ADDWF  x90,W
1B7A:  MOVWF  FE9
1B7C:  MOVLW  00
1B7E:  ADDWFC x91,W
1B80:  MOVWF  FEA
1B82:  MOVFF  FEF,00
1B86:  MOVFF  FEC,01
1B8A:  MOVFF  FEC,02
1B8E:  MOVFF  FEC,03
1B92:  MOVFF  391,FEA
1B96:  MOVFF  390,FE9
1B9A:  MOVFF  00,FEF
1B9E:  MOVFF  01,FEC
1BA2:  MOVFF  02,FEC
1BA6:  MOVFF  03,FEC
1BAA:  MOVLB  0
1BAC:  GOTO   2560 (RETURN)
.................... } 
....................  
.................... /* 
.................... fatpos_t fattell(FILE* stream) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param: The stream to return the position of. 
.................... Returns: The position of where the stream is pointing to relative to the beginning of the stream, or 0 if there was a problem. 
.................... */ 
.................... fatpos_t fattell(FILE* stream) 
.................... { 
....................    fatpos_t retval; 
....................  
....................    if(fatgetpos(stream, &retval) != 0) 
....................       return 0; 
....................  
....................    return retval; 
.................... } 
....................  
.................... /// Non-Standard C Functions /// 
....................  
.................... /* 
.................... signed int rm_file(char fname[]) 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int rm_file(char fname[]) 
.................... { 
....................    int 
....................       order, 
....................       ulinked_entry = 0xE5; // 0xE5 is put into the file's entry to indicate unlinking 
....................  
....................    int32 i; 
....................  
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(fname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // we need to un-link the file's clusters from the FAT if there are clusters allocated 
....................    if(stream.Start_Addr > Root_Dir) 
....................    { 
....................       if(dealloc_clusters(addr_to_cluster(stream.Start_Addr)) == EOF) 
....................          return EOF; 
....................    } 
....................    // get rid of the first entry 
....................    i = stream.Entry_Addr; 
....................    if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................       return EOF; 
....................     
....................    // check to see if there is a long file name 
....................    get_prev_entry(&i); 
....................    if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................       return EOF; 
....................  
....................    // get rid of all of the long file name entries if they're there 
....................    while(order == 0x0F) 
....................    { 
....................       if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................          return EOF; 
....................  
....................       if(get_prev_entry(&i) == EOF) 
....................          return EOF; 
....................  
....................       if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................          return EOF; 
....................    } 
....................     
....................    if(fatclose(&stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int rm_dir(char dname[]) 
.................... Summary: Deletes a directory. 
.................... Param: The full path of the directory to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... Note: This function cannot remove all of the files 
....................        and subdirectories of the directory. Manually remove all subdirectories 
....................        and files before calling this command. 
.................... */ 
.................... signed int rm_dir(char dname[]) 
.................... { 
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(dname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // jump over the . and .. entries in the directory 
....................    stream.Entry_Addr = stream.Start_Addr + 64; 
....................     
....................    // check to make sure that there isn't stuff in this directory 
....................    if(get_next_file(&stream) != EOF) 
....................       return EOF; 
....................  
....................    // since removing files is a lot like removing directories, we 
....................    //  can just call rm_file 
....................    if(rm_file(dname) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int mk_file(char fname[]) 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int mk_file(char fname[]) 
*
3EA0:  CLRF   xB3
.................... { 
....................    char 
....................       filename[MAX_FILE_NAME_LENGTH],   // the file name we're trying to make 
....................       mode[] = "r";                     // reading is the safest mode to work in 
*
3E98:  MOVLW  72
3E9A:  MOVLB  2
3E9C:  MOVWF  x90
3E9E:  CLRF   x91
....................  
....................    int 
....................       buf,               // buffer to hold values 
....................       entire_entry[0x20],// entire first entry 
....................       filename_pos = 0,  // the current parse position of the file name we're trying to create 
....................       fname_pos;         // the current parse position of the input the the function 
....................  
....................    int32 i;      // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(fname, mode, &stream) == GOODEC) 
*
3EA2:  MOVFF  26F,2F4
3EA6:  MOVFF  26E,2F3
3EAA:  MOVLW  02
3EAC:  MOVWF  xF6
3EAE:  MOVLW  90
3EB0:  MOVWF  xF5
3EB2:  MOVLW  02
3EB4:  MOVWF  xF8
3EB6:  MOVLW  B9
3EB8:  MOVWF  xF7
3EBA:  MOVLB  0
3EBC:  CALL   304A
3EC0:  MOVF   01,F
3EC2:  BNZ   3ECA
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
3EC4:  MOVLW  FF
3EC6:  MOVWF  01
3EC8:  BRA    4012
....................  
....................    // check to see if the file is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
3ECA:  MOVLB  2
3ECC:  BTFSC  xD2.7
3ECE:  BRA    3EDA
....................       return EOF; 
3ED0:  MOVLW  FF
3ED2:  MOVWF  01
3ED4:  MOVLB  0
3ED6:  BRA    4012
3ED8:  MOVLB  2
....................  
....................    // make a file name 
....................    fname_pos = strrchr(fname, '/') - fname + 1; 
3EDA:  MOVFF  26F,2F4
3EDE:  MOVFF  26E,2F3
3EE2:  MOVLW  2F
3EE4:  MOVWF  xF5
3EE6:  MOVLB  0
3EE8:  GOTO   32F0
3EEC:  MOVFF  02,2F4
3EF0:  MOVFF  01,2F3
3EF4:  MOVLB  2
3EF6:  MOVF   x6E,W
3EF8:  SUBWF  xF3,F
3EFA:  MOVF   x6F,W
3EFC:  SUBWFB xF4,F
3EFE:  MOVLW  01
3F00:  ADDWF  xF3,W
3F02:  MOVWF  xB4
....................    while((fname[fname_pos] != '\0') && (filename_pos < MAX_FILE_NAME_LENGTH)) 
3F04:  MOVF   xB4,W
3F06:  ADDWF  x6E,W
3F08:  MOVWF  FE9
3F0A:  MOVLW  00
3F0C:  ADDWFC x6F,W
3F0E:  MOVWF  FEA
3F10:  MOVF   FEF,F
3F12:  BZ    3F4A
3F14:  MOVF   xB3,W
3F16:  SUBLW  1F
3F18:  BNC   3F4A
....................    { 
....................       filename[filename_pos] = fname[fname_pos]; 
3F1A:  CLRF   03
3F1C:  MOVF   xB3,W
3F1E:  ADDLW  70
3F20:  MOVWF  01
3F22:  MOVLW  02
3F24:  ADDWFC 03,F
3F26:  MOVF   xB4,W
3F28:  ADDWF  x6E,W
3F2A:  MOVWF  FE9
3F2C:  MOVLW  00
3F2E:  ADDWFC x6F,W
3F30:  MOVWF  FEA
3F32:  MOVFF  FEF,2F5
3F36:  MOVFF  03,FEA
3F3A:  MOVFF  01,FE9
3F3E:  MOVFF  2F5,FEF
....................       fname_pos += 1; 
3F42:  MOVLW  01
3F44:  ADDWF  xB4,F
....................       filename_pos += 1; 
3F46:  ADDWF  xB3,F
3F48:  BRA    3F04
....................    } 
....................    filename[filename_pos] = '\0'; 
3F4A:  CLRF   03
3F4C:  MOVF   xB3,W
3F4E:  ADDLW  70
3F50:  MOVWF  FE9
3F52:  MOVLW  02
3F54:  ADDWFC 03,W
3F56:  MOVWF  FEA
3F58:  CLRF   FEF
....................  
....................    // write the name 
....................    if(set_file_name(stream.Start_Addr, &i, filename) == EOF) 
3F5A:  MOVFF  2D0,2F6
3F5E:  MOVFF  2CF,2F5
3F62:  MOVFF  2CE,2F4
3F66:  MOVFF  2CD,2F3
3F6A:  MOVLW  02
3F6C:  MOVWF  xF8
3F6E:  MOVLW  B5
3F70:  MOVWF  xF7
3F72:  MOVLW  02
3F74:  MOVWF  xFA
3F76:  MOVLW  70
3F78:  MOVWF  xF9
3F7A:  MOVLB  0
3F7C:  BRA    3B88
3F7E:  MOVF   01,W
3F80:  SUBLW  FF
3F82:  BNZ   3F8A
....................       return EOF; 
3F84:  MOVLW  FF
3F86:  MOVWF  01
3F88:  BRA    4012
....................  
....................    // throw in some values in the file's first entry 
....................    for(buf = 0; buf < 0x20; buf += 1) 
3F8A:  MOVLB  2
3F8C:  CLRF   x92
3F8E:  MOVF   x92,W
3F90:  SUBLW  1F
3F92:  BNC   3FAA
....................       entire_entry[buf] = 0; 
3F94:  CLRF   03
3F96:  MOVF   x92,W
3F98:  ADDLW  93
3F9A:  MOVWF  FE9
3F9C:  MOVLW  02
3F9E:  ADDWFC 03,W
3FA0:  MOVWF  FEA
3FA2:  CLRF   FEF
3FA4:  MOVLW  01
3FA6:  ADDWF  x92,F
3FA8:  BRA    3F8E
....................  
....................    // this is a file 
....................    entire_entry[0x0B] = 0x20; 
3FAA:  MOVLW  20
3FAC:  MOVWF  x9E
....................  
....................    // read what set_file_name gave us for the short name 
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
3FAE:  MOVFF  2B8,3C0
3FB2:  MOVFF  2B7,3BF
3FB6:  MOVFF  2B6,3BE
3FBA:  MOVFF  2B5,3BD
3FBE:  MOVLB  3
3FC0:  CLRF   xC2
3FC2:  MOVLW  0B
3FC4:  MOVWF  xC1
3FC6:  MOVLW  02
3FC8:  MOVWF  xC4
3FCA:  MOVLW  93
3FCC:  MOVWF  xC3
3FCE:  MOVLB  0
3FD0:  CALL   0A80
3FD4:  MOVF   01,F
3FD6:  BZ    3FDE
....................       return EOF; 
3FD8:  MOVLW  FF
3FDA:  MOVWF  01
3FDC:  BRA    4012
....................  
....................    // write the entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
3FDE:  MOVFF  2B8,3D9
3FE2:  MOVFF  2B7,3D8
3FE6:  MOVFF  2B6,3D7
3FEA:  MOVFF  2B5,3D6
3FEE:  MOVLB  3
3FF0:  CLRF   xDB
3FF2:  MOVLW  20
3FF4:  MOVWF  xDA
3FF6:  MOVLW  02
3FF8:  MOVWF  xDD
3FFA:  MOVLW  93
3FFC:  MOVWF  xDC
3FFE:  MOVLB  0
4000:  CALL   198E
4004:  MOVF   01,F
4006:  BZ    400E
....................       return EOF; 
4008:  MOVLW  FF
400A:  MOVWF  01
400C:  BRA    4012
....................  
....................    return GOODEC; 
400E:  MOVLW  00
4010:  MOVWF  01
4012:  GOTO   4050 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int mk_dir(char dname[]) 
.................... Summary: Creates a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... */ 
.................... signed int mk_dir(char dname[]) 
.................... { 
....................    char 
....................       dirname[MAX_FILE_NAME_LENGTH],    // the directory name we're trying to make 
....................       entire_entry[0x20],               // used to hold the link entries (. and ..) to the directory and its parent 
....................       mode[] = "r";                     // reading is the safest mode to work in 
....................  
....................    int 
....................       dirname_pos = 0,   // the current parse position of the directory name we're trying to create 
....................       dname_pos,         // the current parse position of the input the the function 
....................       j;                 // counter for loops 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(dname, mode, &stream) == GOODEC) 
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
....................  
....................    // check to see if the directory is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
....................       return EOF; 
....................  
....................    // make the directory name 
....................    dname_pos = strrchr(dname, '/') - dname; 
....................    dname[dname_pos] = '\0'; 
....................    dname_pos = strrchr(dname, '/') - dname + 1; 
....................    while((dname[dname_pos] != '\0') && (dirname_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
....................       dirname[dirname_pos] = dname[dname_pos]; 
....................       dname_pos += 1; 
....................       dirname_pos += 1; 
....................    } 
....................    dirname[dirname_pos] = '\0'; 
....................    dname[dname_pos] = '/'; 
....................  
....................    // write the file's name 
....................    if(set_file_name(stream.Start_Addr, &i, dirname) == EOF) 
....................       return EOF; 
....................  
....................    // find and allocate an open cluster 
....................    if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
....................       return EOF; 
....................    if(clear_cluster(Next_Free_Clust) == EOF) 
....................       return EOF; 
.................... #ifdef FAT32 
....................    if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
....................       return EOF; 
.................... #else // FAT16 
....................    if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // throw in some values in the file's first entry 
....................    for(j = 0; j < 0x20; j += 1) 
....................       entire_entry[j] = 0; 
....................  
....................    // this is a directory 
....................    entire_entry[0x0B] = 0x10; 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // write the file's first entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // make the two links that point to the directory and the directory's parent 
....................    i = cluster_to_addr(Next_Free_Clust); 
....................  
....................    // put in the first link that points to the directory itself 
....................    for(j = 0; j < 0x20; j += 1) 
....................    { 
....................       if(j < 0x01) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else if(j == 0x0B) 
....................          entire_entry[j] = 0x10; 
....................       else 
....................          entire_entry[j] = 0x00; 
....................    } 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    for(j = 0; j < 0x0C; j += 1) 
....................    { 
....................       if(j < 0x02) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else 
....................          entire_entry[j] = 0x10; 
....................    } 
....................  
....................    if(stream.Parent_Start_Addr == Root_Dir) 
....................    { 
....................       entire_entry[0x14] = 0x00; 
....................       entire_entry[0x15] = 0x00; 
....................       entire_entry[0x1A] = 0x00; 
....................       entire_entry[0x1B] = 0x00; 
....................    } 
....................    else 
....................    { 
....................       entire_entry[0x1A] = make8(addr_to_cluster(stream.Parent_Start_Addr), 0); 
....................       entire_entry[0x1B] = make8(addr_to_cluster(stream.Parent_Start_Addr), 1); 
.................... #ifdef FAT32 
....................       entire_entry[0x14] = make8(addr_to_cluster(stream.Parent_Start_Addr), 2); 
....................       entire_entry[0x15] = make8(addr_to_cluster(stream.Parent_Start_Addr), 3); 
.................... #endif // #ifdef FAT32 
....................    } 
....................  
....................    if(mmcsd_write_data(i + 0x20, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Functions' Utility Functions /// 
.................... /// NOTE: A library user should not need to use any of the functions in this section /// 
....................  
.................... /* 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... Summary: This will set the stream to point to the specified file. 
.................... Param fname: The file name to search for. 
.................... Param attrib: The file attributes to search for. 0x10 is a directory, 0x20 is a file. 
.................... Param stream: The stream to set. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: The stream has to be pointing to the parent directory's start address when coming in to this function. 
.................... */ 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
*
297A:  MOVLB  3
297C:  CLRF   x5D
.................... { 
....................    int 
....................       cur_attrib,    // the attribute of the most recently read entry 
....................       cur_state,     // the state of the most recently read entry 
....................       ec = 0;        // error checking byte 
....................  
....................    int32 i;   // pointer to memory 
.................... #ifndef FAST_FAT 
....................    char name_buffer[MAX_FILE_NAME_LENGTH];   // buffer to hold in the most recently read in name 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set the memory pointer to the parent start address 
....................    i = stream->Start_Addr; 
297E:  MOVLW  14
2980:  ADDWF  x59,W
2982:  MOVWF  FE9
2984:  MOVLW  00
2986:  ADDWFC x5A,W
2988:  MOVWF  FEA
298A:  MOVFF  FEF,35E
298E:  MOVFF  FEC,35F
2992:  MOVFF  FEC,360
2996:  MOVFF  FEC,361
....................  
....................    // search for the name of our target file inside of the parent directory 
....................    do 
....................    { 
....................       // read the state and the attribute of the current entry 
....................       ec += mmcsd_read_data(i, 1, &cur_state); 
299A:  MOVFF  361,3C0
299E:  MOVFF  360,3BF
29A2:  MOVFF  35F,3BE
29A6:  MOVFF  35E,3BD
29AA:  CLRF   xC2
29AC:  MOVLW  01
29AE:  MOVWF  xC1
29B0:  MOVLW  03
29B2:  MOVWF  xC4
29B4:  MOVLW  5C
29B6:  MOVWF  xC3
29B8:  MOVLB  0
29BA:  CALL   0A80
29BE:  MOVF   01,W
29C0:  MOVLB  3
29C2:  ADDWF  x5D,F
....................       ec += mmcsd_read_data(i + 0x0B, 1, &cur_attrib); 
29C4:  MOVLW  0B
29C6:  ADDWF  x5E,W
29C8:  MOVWF  x82
29CA:  MOVLW  00
29CC:  ADDWFC x5F,W
29CE:  MOVWF  x83
29D0:  MOVLW  00
29D2:  ADDWFC x60,W
29D4:  MOVWF  x84
29D6:  MOVLW  00
29D8:  ADDWFC x61,W
29DA:  MOVWF  x85
29DC:  MOVWF  xC0
29DE:  MOVFF  384,3BF
29E2:  MOVFF  383,3BE
29E6:  MOVFF  382,3BD
29EA:  CLRF   xC2
29EC:  MOVLW  01
29EE:  MOVWF  xC1
29F0:  MOVLW  03
29F2:  MOVWF  xC4
29F4:  MOVLW  5B
29F6:  MOVWF  xC3
29F8:  MOVLB  0
29FA:  CALL   0A80
29FE:  MOVF   01,W
2A00:  MOVLB  3
2A02:  ADDWF  x5D,F
....................       if(ec != GOODEC) 
2A04:  MOVF   x5D,F
2A06:  BZ    2A20
....................       { 
....................          stream->Flags |= Read_Error; 
2A08:  MOVLW  19
2A0A:  ADDWF  x59,W
2A0C:  MOVWF  FE9
2A0E:  MOVLW  00
2A10:  ADDWFC x5A,W
2A12:  MOVWF  FEA
2A14:  MOVF   FEF,W
2A16:  IORLW  20
2A18:  MOVWF  FEF
....................          return EOF; 
2A1A:  MOVLW  FF
2A1C:  MOVWF  01
2A1E:  BRA    3046
....................       } 
....................  
....................        // check to make sure that this entry exists and the entry is the type we're looking for 
....................       if((cur_state != 0xE5) && (cur_attrib == attrib)) 
2A20:  MOVF   x5C,W
2A22:  SUBLW  E5
2A24:  BTFSC  FD8.2
2A26:  BRA    3008
2A28:  MOVF   x58,W
2A2A:  SUBWF  x5B,W
2A2C:  BTFSS  FD8.2
2A2E:  BRA    3008
....................       { 
.................... #ifndef FAST_FAT 
....................          // get the long file name of the current entry 
....................          if(get_file_name(i, name_buffer) == EOF) 
2A30:  MOVFF  361,385
2A34:  MOVFF  360,384
2A38:  MOVFF  35F,383
2A3C:  MOVFF  35E,382
2A40:  MOVLW  03
2A42:  MOVWF  x87
2A44:  MOVLW  62
2A46:  MOVWF  x86
2A48:  MOVLB  0
2A4A:  GOTO   16C4
2A4E:  MOVF   01,W
2A50:  SUBLW  FF
2A52:  BNZ   2A5E
....................             return EOF; 
2A54:  MOVLW  FF
2A56:  MOVWF  01
2A58:  MOVLB  3
2A5A:  BRA    3046
2A5C:  MOVLB  0
....................  
....................          // if the target entry and the long file name are equal, strcmp will return a zero 
....................          if(strcmp(fname, name_buffer) == 0) 
2A5E:  MOVFF  357,383
2A62:  MOVFF  356,382
2A66:  MOVLW  03
2A68:  MOVLB  3
2A6A:  MOVWF  x85
2A6C:  MOVLW  62
2A6E:  MOVWF  x84
2A70:  MOVLB  0
2A72:  CALL   1842
2A76:  MOVF   01,F
2A78:  BTFSS  FD8.2
2A7A:  BRA    300A
.................... #endif // #ifndef FAST_FAT 
....................          { 
....................             // we have found our target entry, set the current entry and break out of this function 
....................             // set stream's parent address 
....................             stream->Parent_Start_Addr = stream->Start_Addr; 
2A7C:  MOVLW  0C
2A7E:  MOVLB  3
2A80:  ADDWF  x59,W
2A82:  MOVWF  01
2A84:  MOVLW  00
2A86:  ADDWFC x5A,W
2A88:  MOVWF  03
2A8A:  MOVFF  01,382
2A8E:  MOVWF  x83
2A90:  MOVLW  14
2A92:  ADDWF  x59,W
2A94:  MOVWF  FE9
2A96:  MOVLW  00
2A98:  ADDWFC x5A,W
2A9A:  MOVWF  FEA
2A9C:  MOVFF  FEF,00
2AA0:  MOVFF  FEC,01
2AA4:  MOVFF  FEC,02
2AA8:  MOVFF  FEC,03
2AAC:  MOVFF  383,FEA
2AB0:  MOVFF  382,FE9
2AB4:  MOVFF  00,FEF
2AB8:  MOVFF  01,FEC
2ABC:  MOVFF  02,FEC
2AC0:  MOVFF  03,FEC
....................  
....................             ec += mmcsd_read_data(i + 0x1C, 4, &(stream->Size)); 
2AC4:  MOVLW  1C
2AC6:  ADDWF  x5E,W
2AC8:  MOVWF  x82
2ACA:  MOVLW  00
2ACC:  ADDWFC x5F,W
2ACE:  MOVWF  x83
2AD0:  MOVLW  00
2AD2:  ADDWFC x60,W
2AD4:  MOVWF  x84
2AD6:  MOVLW  00
2AD8:  ADDWFC x61,W
2ADA:  MOVWF  x85
2ADC:  MOVLW  10
2ADE:  ADDWF  x59,W
2AE0:  MOVWF  01
2AE2:  MOVLW  00
2AE4:  ADDWFC x5A,W
2AE6:  MOVWF  03
2AE8:  MOVFF  01,386
2AEC:  MOVWF  x87
2AEE:  MOVFF  385,3C0
2AF2:  MOVFF  384,3BF
2AF6:  MOVFF  383,3BE
2AFA:  MOVFF  382,3BD
2AFE:  CLRF   xC2
2B00:  MOVLW  04
2B02:  MOVWF  xC1
2B04:  MOVFF  03,3C4
2B08:  MOVFF  01,3C3
2B0C:  MOVLB  0
2B0E:  CALL   0A80
2B12:  MOVF   01,W
2B14:  MOVLB  3
2B16:  ADDWF  x5D,F
....................  
....................             // stream->Start_Addr is going to temporarily have a cluster number 
....................             ec += mmcsd_read_data(i + 0x14, 2, (int16*)&stream->Start_Addr + 1); 
2B18:  MOVLW  14
2B1A:  ADDWF  x5E,W
2B1C:  MOVWF  x82
2B1E:  MOVLW  00
2B20:  ADDWFC x5F,W
2B22:  MOVWF  x83
2B24:  MOVLW  00
2B26:  ADDWFC x60,W
2B28:  MOVWF  x84
2B2A:  MOVLW  00
2B2C:  ADDWFC x61,W
2B2E:  MOVWF  x85
2B30:  MOVLW  14
2B32:  ADDWF  x59,W
2B34:  MOVWF  01
2B36:  MOVLW  00
2B38:  ADDWFC x5A,W
2B3A:  MOVWF  03
2B3C:  MOVFF  01,386
2B40:  MOVWF  x87
2B42:  MOVLW  02
2B44:  ADDWF  x86,F
2B46:  MOVLW  00
2B48:  ADDWFC x87,F
2B4A:  MOVFF  385,3C0
2B4E:  MOVFF  384,3BF
2B52:  MOVFF  383,3BE
2B56:  MOVFF  382,3BD
2B5A:  CLRF   xC2
2B5C:  MOVLW  02
2B5E:  MOVWF  xC1
2B60:  MOVFF  387,3C4
2B64:  MOVFF  386,3C3
2B68:  MOVLB  0
2B6A:  CALL   0A80
2B6E:  MOVF   01,W
2B70:  MOVLB  3
2B72:  ADDWF  x5D,F
....................             ec += mmcsd_read_data(i + 0x1A, 2, &stream->Start_Addr); 
2B74:  MOVLW  1A
2B76:  ADDWF  x5E,W
2B78:  MOVWF  x82
2B7A:  MOVLW  00
2B7C:  ADDWFC x5F,W
2B7E:  MOVWF  x83
2B80:  MOVLW  00
2B82:  ADDWFC x60,W
2B84:  MOVWF  x84
2B86:  MOVLW  00
2B88:  ADDWFC x61,W
2B8A:  MOVWF  x85
2B8C:  MOVLW  14
2B8E:  ADDWF  x59,W
2B90:  MOVWF  01
2B92:  MOVLW  00
2B94:  ADDWFC x5A,W
2B96:  MOVWF  03
2B98:  MOVFF  01,386
2B9C:  MOVWF  x87
2B9E:  MOVFF  385,3C0
2BA2:  MOVFF  384,3BF
2BA6:  MOVFF  383,3BE
2BAA:  MOVFF  382,3BD
2BAE:  CLRF   xC2
2BB0:  MOVLW  02
2BB2:  MOVWF  xC1
2BB4:  MOVFF  03,3C4
2BB8:  MOVFF  01,3C3
2BBC:  MOVLB  0
2BBE:  CALL   0A80
2BC2:  MOVF   01,W
2BC4:  MOVLB  3
2BC6:  ADDWF  x5D,F
....................  
....................             if(ec != GOODEC) 
2BC8:  MOVF   x5D,F
2BCA:  BZ    2BE4
....................             { 
....................                stream->Flags |= Read_Error; 
2BCC:  MOVLW  19
2BCE:  ADDWF  x59,W
2BD0:  MOVWF  FE9
2BD2:  MOVLW  00
2BD4:  ADDWFC x5A,W
2BD6:  MOVWF  FEA
2BD8:  MOVF   FEF,W
2BDA:  IORLW  20
2BDC:  MOVWF  FEF
....................                return EOF; 
2BDE:  MOVLW  FF
2BE0:  MOVWF  01
2BE2:  BRA    3046
....................             } 
....................  
....................             // convert stream->Start_Addr to an address 
....................             stream->Start_Addr = cluster_to_addr(stream->Start_Addr); 
2BE4:  MOVLW  14
2BE6:  ADDWF  x59,W
2BE8:  MOVWF  01
2BEA:  MOVLW  00
2BEC:  ADDWFC x5A,W
2BEE:  MOVWF  03
2BF0:  MOVFF  01,382
2BF4:  MOVWF  x83
2BF6:  MOVLW  14
2BF8:  ADDWF  x59,W
2BFA:  MOVWF  FE9
2BFC:  MOVLW  00
2BFE:  ADDWFC x5A,W
2C00:  MOVWF  FEA
2C02:  MOVFF  FEF,3D2
2C06:  MOVFF  FEC,3D3
2C0A:  MOVFF  FEC,3D4
2C0E:  MOVFF  FEC,3D5
2C12:  MOVLB  0
2C14:  CALL   13BE
2C18:  MOVFF  383,FEA
2C1C:  MOVFF  382,FE9
2C20:  MOVFF  00,FEF
2C24:  MOVFF  01,FEC
2C28:  MOVFF  02,FEC
2C2C:  MOVFF  03,FEC
....................  
....................             stream->Entry_Addr = i; 
2C30:  MOVLW  08
2C32:  MOVLB  3
2C34:  ADDWF  x59,W
2C36:  MOVWF  FE9
2C38:  MOVLW  00
2C3A:  ADDWFC x5A,W
2C3C:  MOVWF  FEA
2C3E:  MOVFF  35E,FEF
2C42:  MOVFF  35F,FEC
2C46:  MOVFF  360,FEC
2C4A:  MOVFF  361,FEC
....................             stream->Bytes_Until_EOF = stream->Size; 
2C4E:  MOVLW  10
2C50:  ADDWF  x59,W
2C52:  MOVWF  FE9
2C54:  MOVLW  00
2C56:  ADDWFC x5A,W
2C58:  MOVWF  FEA
2C5A:  MOVFF  FEF,00
2C5E:  MOVFF  FEC,01
2C62:  MOVFF  FEC,02
2C66:  MOVFF  FEC,03
2C6A:  MOVFF  35A,FEA
2C6E:  MOVFF  359,FE9
2C72:  MOVFF  00,FEF
2C76:  MOVFF  01,FEC
2C7A:  MOVFF  02,FEC
2C7E:  MOVFF  03,FEC
....................  
....................             // set up some permission-specific parameters if we're at a file 
....................             if(attrib == 0x20) 
2C82:  MOVF   x58,W
2C84:  SUBLW  20
2C86:  BTFSS  FD8.2
2C88:  BRA    2FF2
....................             { 
....................                stream->File_Type = Data_File; 
2C8A:  MOVLW  18
2C8C:  ADDWF  x59,W
2C8E:  MOVWF  FE9
2C90:  MOVLW  00
2C92:  ADDWFC x5A,W
2C94:  MOVWF  FEA
2C96:  CLRF   FEF
....................                if(stream->Flags & Write) 
2C98:  MOVLW  19
2C9A:  ADDWF  x59,W
2C9C:  MOVWF  FE9
2C9E:  MOVLW  00
2CA0:  ADDWFC x5A,W
2CA2:  MOVWF  FEA
2CA4:  BTFSS  FEF.1
2CA6:  BRA    2DA0
....................                { 
....................                   // delete all previous data in the file 
....................                   stream->Bytes_Until_EOF = stream->Size = 0; 
2CA8:  MOVLW  10
2CAA:  ADDWF  x59,W
2CAC:  MOVWF  FE9
2CAE:  MOVLW  00
2CB0:  ADDWFC x5A,W
2CB2:  MOVWF  FEA
2CB4:  MOVF   FEE,F
2CB6:  MOVF   FEE,F
2CB8:  CLRF   FEC
2CBA:  MOVF   FED,F
2CBC:  CLRF   FEF
2CBE:  MOVF   FED,F
2CC0:  CLRF   FEF
2CC2:  MOVF   FED,F
2CC4:  CLRF   FEF
2CC6:  MOVLW  00
2CC8:  MOVFF  35A,FEA
2CCC:  MOVFF  359,FE9
2CD0:  MOVFF  00,FEF
2CD4:  MOVFF  359,FEC
2CD8:  MOVFF  02,FEC
2CDC:  MOVFF  35A,FEC
....................  
....................                   // if there is already space allocated, get rid of it 
....................                   if(stream->Start_Addr >= Data_Start) 
2CE0:  MOVLW  14
2CE2:  ADDWF  x59,W
2CE4:  MOVWF  FE9
2CE6:  MOVLW  00
2CE8:  ADDWFC x5A,W
2CEA:  MOVWF  FEA
2CEC:  MOVFF  FEF,382
2CF0:  MOVFF  FEC,383
2CF4:  MOVFF  FEC,384
2CF8:  MOVFF  FEC,385
2CFC:  MOVLB  2
2CFE:  MOVF   x15,W
2D00:  MOVLB  3
2D02:  SUBWF  x85,W
2D04:  BNC   2D7E
2D06:  BNZ   2D2A
2D08:  MOVLB  2
2D0A:  MOVF   x14,W
2D0C:  MOVLB  3
2D0E:  SUBWF  x84,W
2D10:  BNC   2D7E
2D12:  BNZ   2D2A
2D14:  MOVLB  2
2D16:  MOVF   x13,W
2D18:  MOVLB  3
2D1A:  SUBWF  x83,W
2D1C:  BNC   2D7E
2D1E:  BNZ   2D2A
2D20:  MOVLB  2
2D22:  MOVF   x12,W
2D24:  MOVLB  3
2D26:  SUBWF  x82,W
2D28:  BNC   2D7E
....................                      if(dealloc_clusters(addr_to_cluster(stream->Start_Addr)) == EOF) 
2D2A:  MOVLW  14
2D2C:  ADDWF  x59,W
2D2E:  MOVWF  FE9
2D30:  MOVLW  00
2D32:  ADDWFC x5A,W
2D34:  MOVWF  FEA
2D36:  MOVFF  FEF,3A0
2D3A:  MOVFF  FEC,3A1
2D3E:  MOVFF  FEC,3A2
2D42:  MOVFF  FEC,3A3
2D46:  MOVLB  0
2D48:  CALL   1268
2D4C:  MOVFF  03,385
2D50:  MOVFF  02,384
2D54:  MOVFF  01,383
2D58:  MOVFF  00,382
2D5C:  MOVFF  03,389
2D60:  MOVFF  02,388
2D64:  MOVFF  01,387
2D68:  MOVFF  00,386
2D6C:  GOTO   1A84
2D70:  MOVF   01,W
2D72:  SUBLW  FF
2D74:  BNZ   2D80
....................                         return EOF; 
2D76:  MOVLW  FF
2D78:  MOVWF  01
2D7A:  MOVLB  3
2D7C:  BRA    3046
2D7E:  MOVLB  0
....................                   stream->Cur_Char = 0; 
2D80:  MOVLW  04
2D82:  MOVLB  3
2D84:  ADDWF  x59,W
2D86:  MOVWF  FE9
2D88:  MOVLW  00
2D8A:  ADDWFC x5A,W
2D8C:  MOVWF  FEA
2D8E:  MOVF   FEE,F
2D90:  MOVF   FEE,F
2D92:  CLRF   FEC
2D94:  MOVF   FED,F
2D96:  CLRF   FEF
2D98:  MOVF   FED,F
2D9A:  CLRF   FEF
2D9C:  MOVF   FED,F
2D9E:  CLRF   FEF
....................                } 
....................  
....................                if((stream->Flags & Append) && (stream->Size != 0)) 
2DA0:  MOVLW  19
2DA2:  ADDWF  x59,W
2DA4:  MOVWF  FE9
2DA6:  MOVLW  00
2DA8:  ADDWFC x5A,W
2DAA:  MOVWF  FEA
2DAC:  BTFSS  FEF.2
2DAE:  BRA    2F36
2DB0:  MOVLW  10
2DB2:  ADDWF  x59,W
2DB4:  MOVWF  FE9
2DB6:  MOVLW  00
2DB8:  ADDWFC x5A,W
2DBA:  MOVWF  FEA
2DBC:  MOVFF  FEF,382
2DC0:  MOVFF  FEC,383
2DC4:  MOVFF  FEC,384
2DC8:  MOVFF  FEC,385
2DCC:  MOVF   x82,F
2DCE:  BNZ   2DDE
2DD0:  MOVF   x83,F
2DD2:  BNZ   2DDE
2DD4:  MOVF   x84,F
2DD6:  BNZ   2DDE
2DD8:  MOVF   x85,F
2DDA:  BTFSC  FD8.2
2DDC:  BRA    2F36
....................                { 
....................                   // set the position to the end of the file and fill the buffer with the contents of the end of the file 
....................                   ec = fatsetpos(stream, &(stream->Size)); 
2DDE:  MOVLW  10
2DE0:  ADDWF  x59,W
2DE2:  MOVWF  01
2DE4:  MOVLW  00
2DE6:  ADDWFC x5A,W
2DE8:  MOVWF  03
2DEA:  MOVFF  01,382
2DEE:  MOVWF  x83
2DF0:  MOVFF  35A,385
2DF4:  MOVFF  359,384
2DF8:  MOVWF  x87
2DFA:  MOVFF  01,386
2DFE:  MOVLB  0
2E00:  GOTO   2524
2E04:  MOVFF  01,35D
....................                   if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
2E08:  MOVLW  04
2E0A:  MOVLB  3
2E0C:  ADDWF  x59,W
2E0E:  MOVWF  FE9
2E10:  MOVLW  00
2E12:  ADDWFC x5A,W
2E14:  MOVWF  FEA
2E16:  MOVFF  FEF,382
2E1A:  MOVFF  FEC,383
2E1E:  MOVFF  FEC,384
2E22:  MOVFF  FEC,385
2E26:  MOVLW  1F
2E28:  ANDWF  x82,F
2E2A:  CLRF   x83
2E2C:  CLRF   x84
2E2E:  CLRF   x85
2E30:  MOVF   x82,F
2E32:  BNZ   2EA6
2E34:  MOVF   x83,F
2E36:  BNZ   2EA6
2E38:  MOVF   x84,F
2E3A:  BNZ   2EA6
2E3C:  MOVF   x85,F
2E3E:  BNZ   2EA6
....................                      ec += mmcsd_read_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf); 
2E40:  MOVLW  04
2E42:  ADDWF  x59,W
2E44:  MOVWF  FE9
2E46:  MOVLW  00
2E48:  ADDWFC x5A,W
2E4A:  MOVWF  FEA
2E4C:  MOVFF  FEF,382
2E50:  MOVFF  FEC,383
2E54:  MOVFF  FEC,384
2E58:  MOVFF  FEC,385
2E5C:  MOVLW  20
2E5E:  SUBWF  x82,F
2E60:  MOVLW  00
2E62:  SUBWFB x83,F
2E64:  SUBWFB x84,F
2E66:  SUBWFB x85,F
2E68:  MOVLW  1A
2E6A:  ADDWF  x59,W
2E6C:  MOVWF  01
2E6E:  MOVLW  00
2E70:  ADDWFC x5A,W
2E72:  MOVWF  03
2E74:  MOVFF  01,386
2E78:  MOVWF  x87
2E7A:  MOVFF  385,3C0
2E7E:  MOVFF  384,3BF
2E82:  MOVFF  383,3BE
2E86:  MOVFF  382,3BD
2E8A:  CLRF   xC2
2E8C:  MOVLW  20
2E8E:  MOVWF  xC1
2E90:  MOVFF  03,3C4
2E94:  MOVFF  01,3C3
2E98:  MOVLB  0
2E9A:  CALL   0A80
2E9E:  MOVF   01,W
2EA0:  MOVLB  3
2EA2:  ADDWF  x5D,F
2EA4:  BRA    2F36
....................                   else 
....................                      ec += mmcsd_read_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf); 
2EA6:  MOVLW  04
2EA8:  ADDWF  x59,W
2EAA:  MOVWF  FE9
2EAC:  MOVLW  00
2EAE:  ADDWFC x5A,W
2EB0:  MOVWF  FEA
2EB2:  MOVFF  FEF,382
2EB6:  MOVFF  FEC,383
2EBA:  MOVFF  FEC,384
2EBE:  MOVFF  FEC,385
2EC2:  MOVLW  04
2EC4:  ADDWF  x59,W
2EC6:  MOVWF  FE9
2EC8:  MOVLW  00
2ECA:  ADDWFC x5A,W
2ECC:  MOVWF  FEA
2ECE:  MOVFF  FEF,386
2ED2:  MOVFF  FEC,387
2ED6:  MOVFF  FEC,388
2EDA:  MOVFF  FEC,389
2EDE:  MOVF   x86,W
2EE0:  ANDLW  1F
2EE2:  MOVWF  00
2EE4:  CLRF   01
2EE6:  CLRF   02
2EE8:  CLRF   03
2EEA:  MOVF   00,W
2EEC:  SUBWF  x82,F
2EEE:  MOVF   01,W
2EF0:  SUBWFB x83,F
2EF2:  MOVF   02,W
2EF4:  SUBWFB x84,F
2EF6:  MOVF   03,W
2EF8:  SUBWFB x85,F
2EFA:  MOVLW  1A
2EFC:  ADDWF  x59,W
2EFE:  MOVWF  01
2F00:  MOVLW  00
2F02:  ADDWFC x5A,W
2F04:  MOVWF  03
2F06:  MOVFF  01,386
2F0A:  MOVWF  x87
2F0C:  MOVFF  385,3C0
2F10:  MOVFF  384,3BF
2F14:  MOVFF  383,3BE
2F18:  MOVFF  382,3BD
2F1C:  CLRF   xC2
2F1E:  MOVLW  20
2F20:  MOVWF  xC1
2F22:  MOVFF  03,3C4
2F26:  MOVFF  01,3C3
2F2A:  MOVLB  0
2F2C:  CALL   0A80
2F30:  MOVF   01,W
2F32:  MOVLB  3
2F34:  ADDWF  x5D,F
....................                } 
.................... #ifndef FAST_FAT 
....................                if(stream->Flags & Read) 
2F36:  MOVLW  19
2F38:  ADDWF  x59,W
2F3A:  MOVWF  FE9
2F3C:  MOVLW  00
2F3E:  ADDWFC x5A,W
2F40:  MOVWF  FEA
2F42:  BTFSS  FEF.0
2F44:  BRA    2FD4
....................                { 
....................                   stream->Cur_Char = stream->Start_Addr; 
2F46:  MOVLW  04
2F48:  ADDWF  x59,W
2F4A:  MOVWF  01
2F4C:  MOVLW  00
2F4E:  ADDWFC x5A,W
2F50:  MOVWF  03
2F52:  MOVFF  01,382
2F56:  MOVWF  x83
2F58:  MOVLW  14
2F5A:  ADDWF  x59,W
2F5C:  MOVWF  FE9
2F5E:  MOVLW  00
2F60:  ADDWFC x5A,W
2F62:  MOVWF  FEA
2F64:  MOVFF  FEF,00
2F68:  MOVFF  FEC,01
2F6C:  MOVFF  FEC,02
2F70:  MOVFF  FEC,03
2F74:  MOVFF  383,FEA
2F78:  MOVFF  382,FE9
2F7C:  MOVFF  00,FEF
2F80:  MOVFF  01,FEC
2F84:  MOVFF  02,FEC
2F88:  MOVFF  03,FEC
....................  
....................                   // fill up the read buffer for reading 
....................                   ec = mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf); 
2F8C:  MOVLW  04
2F8E:  ADDWF  x59,W
2F90:  MOVWF  FE9
2F92:  MOVLW  00
2F94:  ADDWFC x5A,W
2F96:  MOVWF  FEA
2F98:  MOVFF  FEF,3BD
2F9C:  MOVFF  FEC,3BE
2FA0:  MOVFF  FEC,3BF
2FA4:  MOVFF  FEC,3C0
2FA8:  MOVLW  1A
2FAA:  ADDWF  x59,W
2FAC:  MOVWF  01
2FAE:  MOVLW  00
2FB0:  ADDWFC x5A,W
2FB2:  MOVWF  03
2FB4:  MOVFF  01,386
2FB8:  MOVWF  x87
2FBA:  CLRF   xC2
2FBC:  MOVLW  20
2FBE:  MOVWF  xC1
2FC0:  MOVFF  03,3C4
2FC4:  MOVFF  01,3C3
2FC8:  MOVLB  0
2FCA:  CALL   0A80
2FCE:  MOVFF  01,35D
2FD2:  MOVLB  3
....................                } 
.................... #endif // #ifndef FAST_FAT 
....................                if(ec != GOODEC) 
2FD4:  MOVF   x5D,F
2FD6:  BZ    2FF0
....................                { 
....................                   stream->Flags |= Read_Error; 
2FD8:  MOVLW  19
2FDA:  ADDWF  x59,W
2FDC:  MOVWF  FE9
2FDE:  MOVLW  00
2FE0:  ADDWFC x5A,W
2FE2:  MOVWF  FEA
2FE4:  MOVF   FEF,W
2FE6:  IORLW  20
2FE8:  MOVWF  FEF
....................                   return EOF; 
2FEA:  MOVLW  FF
2FEC:  MOVWF  01
2FEE:  BRA    3046
....................                }                
....................             } 
2FF0:  BRA    3002
....................             else 
....................                stream->File_Type = Directory; 
2FF2:  MOVLW  18
2FF4:  ADDWF  x59,W
2FF6:  MOVWF  FE9
2FF8:  MOVLW  00
2FFA:  ADDWFC x5A,W
2FFC:  MOVWF  FEA
2FFE:  MOVLW  01
3000:  MOVWF  FEF
....................             return GOODEC; 
3002:  MOVLW  00
3004:  MOVWF  01
3006:  BRA    3046
3008:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // check to make sure that the next iteration will give us a contiguous cluster 
....................       if(get_next_entry(&i) == EOF) 
300A:  MOVLW  03
300C:  MOVLB  3
300E:  MOVWF  x83
3010:  MOVLW  5E
3012:  MOVWF  x82
3014:  MOVLB  0
3016:  RCALL  2918
3018:  MOVF   01,W
301A:  SUBLW  FF
301C:  BNZ   3028
....................          return EOF; 
301E:  MOVLW  FF
3020:  MOVWF  01
3022:  MOVLB  3
3024:  BRA    3046
3026:  MOVLB  0
....................  
....................    } while(cur_state != 0x00); 
3028:  MOVLB  3
302A:  MOVF   x5C,F
302C:  BTFSS  FD8.2
302E:  BRA    299A
....................  
....................    // if we reach this point, we know that the file won't be found 
....................    stream->Flags |= File_Not_Found; 
3030:  MOVLW  19
3032:  ADDWF  x59,W
3034:  MOVWF  FE9
3036:  MOVLW  00
3038:  ADDWFC x5A,W
303A:  MOVWF  FEA
303C:  MOVF   FEF,W
303E:  IORLW  80
3040:  MOVWF  FEF
....................    return EOF; 
3042:  MOVLW  FF
3044:  MOVWF  01
3046:  MOVLB  0
3048:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... Summary: This will get a name of a file. 
.................... Param file_entry_addr: The position in memory that the file's entry is. 
.................... Param name[]: The place to put the name of the file into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
*
16C4:  MOVLB  3
16C6:  CLRF   x89
.................... { 
....................    int 
....................       j,       // counter for loops 
....................       k = 0,   // current character in array 
....................       order,   // byte to hold the current long file name order 
....................       type;    // the type of entry that was just read in 
....................  
....................    int32 i;          // pointer for memory 
....................  
....................    // the long file name isn't fragmented across clusters 
....................    i = file_entry_addr; 
16C8:  MOVFF  385,38F
16CC:  MOVFF  384,38E
16D0:  MOVFF  383,38D
16D4:  MOVFF  382,38C
....................  
....................    // check to make sure that this file has a long file name 
....................    if(mmcsd_read_data(i - 0x15, 1, &type) != GOODEC) 
16D8:  MOVLW  15
16DA:  SUBWF  x8C,W
16DC:  MOVWF  x90
16DE:  MOVLW  00
16E0:  SUBWFB x8D,W
16E2:  MOVWF  x91
16E4:  MOVLW  00
16E6:  SUBWFB x8E,W
16E8:  MOVWF  x92
16EA:  MOVLW  00
16EC:  SUBWFB x8F,W
16EE:  MOVWF  x93
16F0:  MOVWF  xC0
16F2:  MOVFF  392,3BF
16F6:  MOVFF  391,3BE
16FA:  MOVFF  390,3BD
16FE:  CLRF   xC2
1700:  MOVLW  01
1702:  MOVWF  xC1
1704:  MOVLW  03
1706:  MOVWF  xC4
1708:  MOVLW  8B
170A:  MOVWF  xC3
170C:  MOVLB  0
170E:  CALL   0A80
1712:  MOVF   01,F
1714:  BZ    171C
....................       return EOF; 
1716:  MOVLW  FF
1718:  MOVWF  01
171A:  BRA    183C
....................  
....................    if(type != 0x0F) 
171C:  MOVLB  3
171E:  MOVF   x8B,W
1720:  SUBLW  0F
1722:  BZ    1758
....................    { 
....................       // this file doesn't have a long file name 
....................       if(get_short_file_name(i, name, type) == EOF) 
1724:  MOVFF  38F,393
1728:  MOVFF  38E,392
172C:  MOVFF  38D,391
1730:  MOVFF  38C,390
1734:  MOVFF  387,395
1738:  MOVFF  386,394
173C:  MOVFF  38B,396
1740:  MOVLB  0
1742:  BRA    109C
1744:  MOVF   01,W
1746:  SUBLW  FF
1748:  BNZ   1750
....................          return EOF; 
174A:  MOVLW  FF
174C:  MOVWF  01
174E:  BRA    183C
....................       return GOODEC; 
1750:  MOVLW  00
1752:  MOVWF  01
1754:  BRA    183C
1756:  MOVLB  3
....................    } 
....................  
....................    do 
....................    { 
....................       // head to the previous entry 
....................       if(get_prev_entry(&i) == EOF) 
1758:  MOVLW  03
175A:  MOVWF  x91
175C:  MOVLW  8C
175E:  MOVWF  x90
1760:  MOVLB  0
1762:  BRA    1662
1764:  MOVF   01,W
1766:  SUBLW  FF
1768:  BNZ   1770
....................          return EOF; 
176A:  MOVLW  FF
176C:  MOVWF  01
176E:  BRA    183C
....................  
....................       for(j = 1; j < 0x20; j += 2, k += 1) 
1770:  MOVLW  01
1772:  MOVLB  3
1774:  MOVWF  x88
1776:  MOVF   x88,W
1778:  SUBLW  1F
177A:  BNC   17F6
....................       { 
....................          if(j == 11) 
177C:  MOVF   x88,W
177E:  SUBLW  0B
1780:  BNZ   1788
....................             j = 14; 
1782:  MOVLW  0E
1784:  MOVWF  x88
1786:  BRA    1792
....................          else if(j == 26) 
1788:  MOVF   x88,W
178A:  SUBLW  1A
178C:  BNZ   1792
....................             j = 28; 
178E:  MOVLW  1C
1790:  MOVWF  x88
....................          if(mmcsd_read_data(j + i, 1, &(name[k])) != GOODEC) 
1792:  MOVF   x88,W
1794:  ADDWF  x8C,W
1796:  MOVWF  x90
1798:  MOVLW  00
179A:  ADDWFC x8D,W
179C:  MOVWF  x91
179E:  MOVLW  00
17A0:  ADDWFC x8E,W
17A2:  MOVWF  x92
17A4:  MOVLW  00
17A6:  ADDWFC x8F,W
17A8:  MOVWF  x93
17AA:  MOVF   x89,W
17AC:  ADDWF  x86,W
17AE:  MOVWF  01
17B0:  MOVLW  00
17B2:  ADDWFC x87,W
17B4:  MOVWF  03
17B6:  MOVFF  01,394
17BA:  MOVWF  x95
17BC:  MOVFF  393,3C0
17C0:  MOVFF  392,3BF
17C4:  MOVFF  391,3BE
17C8:  MOVFF  390,3BD
17CC:  CLRF   xC2
17CE:  MOVLW  01
17D0:  MOVWF  xC1
17D2:  MOVFF  03,3C4
17D6:  MOVFF  01,3C3
17DA:  MOVLB  0
17DC:  CALL   0A80
17E0:  MOVF   01,F
17E2:  BZ    17EA
....................             return EOF; 
17E4:  MOVLW  FF
17E6:  MOVWF  01
17E8:  BRA    183C
17EA:  MOVLW  02
17EC:  MOVLB  3
17EE:  ADDWF  x88,F
17F0:  MOVLW  01
17F2:  ADDWF  x89,F
17F4:  BRA    1776
....................       } 
....................  
....................       // now that that's done with, get the entry's order 
....................       if(mmcsd_read_data(i, 1, &order) != GOODEC) 
17F6:  MOVFF  38F,3C0
17FA:  MOVFF  38E,3BF
17FE:  MOVFF  38D,3BE
1802:  MOVFF  38C,3BD
1806:  CLRF   xC2
1808:  MOVLW  01
180A:  MOVWF  xC1
180C:  MOVLW  03
180E:  MOVWF  xC4
1810:  MOVLW  8A
1812:  MOVWF  xC3
1814:  MOVLB  0
1816:  CALL   0A80
181A:  MOVF   01,F
181C:  BZ    1824
....................          return EOF; 
181E:  MOVLW  FF
1820:  MOVWF  01
1822:  BRA    183C
....................  
....................    } while(!(order & 0x40));  // the last entry will be 0b01xxxxxx 
1824:  MOVLB  3
1826:  BTFSS  x8A.6
1828:  BRA    1758
....................  
....................    // end the name[] buffer with a \0 
....................    name[k] = '\0'; 
182A:  MOVF   x89,W
182C:  ADDWF  x86,W
182E:  MOVWF  FE9
1830:  MOVLW  00
1832:  ADDWFC x87,W
1834:  MOVWF  FEA
1836:  CLRF   FEF
....................  
....................    return GOODEC; 
1838:  MOVLW  00
183A:  MOVWF  01
183C:  MOVLB  0
183E:  GOTO   2A4E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int set_file_name(int32 parent_dir_addr, int32 entry_addr, char name[]) 
.................... Summary: Creates both a short and long file name at the first free entry in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param entry_addr: The address the function put the short file name entry. 
.................... Param name: The full file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]) 
*
3B88:  MOVLB  3
3B8A:  CLRF   x07
3B8C:  MOVLW  01
3B8E:  MOVWF  x2A
.................... { 
....................    char sname[12];   // place to hold the short file name 
....................  
....................    signed int name_pos = 0;   // the current parse position of name[] 
....................  
....................    int 
....................       chksum,               // the long file name checksum 
....................       entire_entry[0x20],   // the entire entry to put write onto the media 
....................       entry_pos,            // the current position inside of entire_entry 
....................       long_entry = 1;       // the current long entry number we're on 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    // check for invalid characters 
....................    if(check_invalid_char(name) == EOF) 
3B90:  MOVFF  2FA,330
3B94:  MOVFF  2F9,32F
3B98:  MOVLB  0
3B9A:  GOTO   3338
3B9E:  MOVF   01,W
3BA0:  SUBLW  FF
3BA2:  BNZ   3BAA
....................       return EOF; 
3BA4:  MOVLW  FF
3BA6:  MOVWF  01
3BA8:  BRA    3E92
....................  
....................    // make a short file name of this 
....................    if(make_short_file_name(parent_dir_addr, name, sname) == EOF) 
3BAA:  MOVFF  2F6,332
3BAE:  MOVFF  2F5,331
3BB2:  MOVFF  2F4,330
3BB6:  MOVFF  2F3,32F
3BBA:  MOVFF  2FA,334
3BBE:  MOVFF  2F9,333
3BC2:  MOVLW  02
3BC4:  MOVLB  3
3BC6:  MOVWF  x36
3BC8:  MOVLW  FB
3BCA:  MOVWF  x35
3BCC:  MOVLB  0
3BCE:  BRA    34D8
3BD0:  MOVF   01,W
3BD2:  SUBLW  FF
3BD4:  BNZ   3BDC
....................       return EOF; 
3BD6:  MOVLW  FF
3BD8:  MOVWF  01
3BDA:  BRA    3E92
....................  
....................    // get a checksum for the long file name entries 
....................    chksum = long_name_chksum(sname); 
3BDC:  MOVLW  02
3BDE:  MOVLB  3
3BE0:  MOVWF  x30
3BE2:  MOVLW  FB
3BE4:  MOVWF  x2F
3BE6:  MOVLB  0
3BE8:  BRA    3946
3BEA:  MOVFF  01,308
....................  
....................    // start writing the long file name 
....................    // zero out entry[] 
....................    for(entry_pos = 0; entry_pos < 0x20; entry_pos += 1) 
3BEE:  MOVLB  3
3BF0:  CLRF   x29
3BF2:  MOVF   x29,W
3BF4:  SUBLW  1F
3BF6:  BNC   3C0E
....................       entire_entry[entry_pos] = 0;    
3BF8:  CLRF   03
3BFA:  MOVF   x29,W
3BFC:  ADDLW  09
3BFE:  MOVWF  FE9
3C00:  MOVLW  03
3C02:  ADDWFC 03,W
3C04:  MOVWF  FEA
3C06:  CLRF   FEF
3C08:  MOVLW  01
3C0A:  ADDWF  x29,F
3C0C:  BRA    3BF2
....................  
....................    i = parent_dir_addr; 
3C0E:  MOVFF  2F6,32E
3C12:  MOVFF  2F5,32D
3C16:  MOVFF  2F4,32C
3C1A:  MOVFF  2F3,32B
....................    if(get_next_free_entry(&i) == EOF) 
3C1E:  MOVLW  03
3C20:  MOVWF  x30
3C22:  MOVLW  2B
3C24:  MOVWF  x2F
3C26:  MOVLB  0
3C28:  RCALL  398C
3C2A:  MOVF   01,W
3C2C:  SUBLW  FF
3C2E:  BNZ   3C36
....................       return EOF; 
3C30:  MOVLW  FF
3C32:  MOVWF  01
3C34:  BRA    3E92
....................  
....................    // 0x0F signifies an file entry 
....................    entire_entry[11] = 0x0F; 
3C36:  MOVLW  0F
3C38:  MOVLB  3
3C3A:  MOVWF  x14
....................  
....................    // since we're working in reverse, write the final long name entry 
....................    name_pos = strlen(name); 
3C3C:  MOVFF  2FA,39B
3C40:  MOVFF  2F9,39A
3C44:  MOVLB  0
3C46:  CALL   1060
3C4A:  MOVFF  01,307
....................    name_pos %= 13; 
3C4E:  MOVFF  307,32F
3C52:  MOVLW  0D
3C54:  MOVLB  3
3C56:  MOVWF  x30
3C58:  MOVLB  0
3C5A:  RCALL  3A9E
3C5C:  MOVFF  00,307
....................  
....................    if(name_pos != 0) 
3C60:  MOVLB  3
3C62:  MOVF   x07,F
3C64:  BZ    3C7E
....................    { 
....................       // add 1 to account for the \0 terminator 
....................       name_pos += 1; 
3C66:  MOVLW  01
3C68:  ADDWF  x07,F
....................  
....................       fill_entry(entire_entry, 0xFF, name_pos); 
3C6A:  MOVLW  03
3C6C:  MOVWF  x30
3C6E:  MOVLW  09
3C70:  MOVWF  x2F
3C72:  SETF   x31
3C74:  MOVFF  307,332
3C78:  MOVLB  0
3C7A:  RCALL  3AEA
3C7C:  MOVLB  3
....................    } 
....................  
....................    // start writing the long file name entries 
....................    name_pos = strlen(name); 
3C7E:  MOVFF  2FA,39B
3C82:  MOVFF  2F9,39A
3C86:  MOVLB  0
3C88:  CALL   1060
3C8C:  MOVFF  01,307
....................  
....................    // figure out how many entries this name will take up 
....................    long_entry = (name_pos / 13) + 1; 
3C90:  MOVFF  307,32F
3C94:  MOVLW  0D
3C96:  MOVLB  3
3C98:  MOVWF  x30
3C9A:  MOVLB  0
3C9C:  RCALL  3A9E
3C9E:  MOVLW  01
3CA0:  ADDWF  01,W
3CA2:  MOVLB  3
3CA4:  MOVWF  x2A
....................  
....................    if(name_pos % 13 == 0) 
3CA6:  MOVFF  307,32F
3CAA:  MOVLW  0D
3CAC:  MOVWF  x30
3CAE:  MOVLB  0
3CB0:  RCALL  3A9E
3CB2:  MOVF   00,F
3CB4:  BNZ   3CBE
....................       long_entry -= 1; 
3CB6:  MOVLW  01
3CB8:  MOVLB  3
3CBA:  SUBWF  x2A,F
3CBC:  MOVLB  0
....................  
....................    // set the bit to signify this is the final entry 
....................    long_entry |= 0x40; 
3CBE:  MOVLB  3
3CC0:  BSF    x2A.6
....................  
....................    while(name_pos >= 0) 
3CC2:  BTFSC  x07.7
3CC4:  BRA    3E46
....................    { 
....................       entry_pos = name_pos % 13; 
3CC6:  MOVFF  307,32F
3CCA:  MOVLW  0D
3CCC:  MOVWF  x30
3CCE:  MOVLB  0
3CD0:  RCALL  3A9E
3CD2:  MOVFF  00,329
3CD6:  MOVLB  3
....................  
....................       if(entry_pos < 5) 
3CD8:  MOVF   x29,W
3CDA:  SUBLW  04
3CDC:  BNC   3D20
....................          entire_entry[(entry_pos << 1) + 1] = name[name_pos]; 
3CDE:  BCF    FD8.0
3CE0:  RLCF   x29,W
3CE2:  ADDLW  01
3CE4:  CLRF   03
3CE6:  ADDLW  09
3CE8:  MOVWF  01
3CEA:  MOVLW  03
3CEC:  ADDWFC 03,F
3CEE:  MOVFF  01,32F
3CF2:  MOVFF  03,330
3CF6:  CLRF   03
3CF8:  MOVF   x07,W
3CFA:  MOVWF  00
3CFC:  BTFSC  FE8.7
3CFE:  DECF   03,F
3D00:  MOVLB  2
3D02:  ADDWF  xF9,W
3D04:  MOVWF  FE9
3D06:  MOVF   xFA,W
3D08:  ADDWFC 03,W
3D0A:  MOVWF  FEA
3D0C:  MOVFF  FEF,331
3D10:  MOVLB  3
3D12:  MOVFF  330,FEA
3D16:  MOVFF  01,FE9
3D1A:  MOVFF  331,FEF
3D1E:  BRA    3DA2
....................  
....................       else if(entry_pos < 11) 
3D20:  MOVF   x29,W
3D22:  SUBLW  0A
3D24:  BNC   3D68
....................          entire_entry[(entry_pos << 1) + 4] = name[name_pos]; 
3D26:  BCF    FD8.0
3D28:  RLCF   x29,W
3D2A:  ADDLW  04
3D2C:  CLRF   03
3D2E:  ADDLW  09
3D30:  MOVWF  01
3D32:  MOVLW  03
3D34:  ADDWFC 03,F
3D36:  MOVFF  01,32F
3D3A:  MOVFF  03,330
3D3E:  CLRF   03
3D40:  MOVF   x07,W
3D42:  MOVWF  00
3D44:  BTFSC  FE8.7
3D46:  DECF   03,F
3D48:  MOVLB  2
3D4A:  ADDWF  xF9,W
3D4C:  MOVWF  FE9
3D4E:  MOVF   xFA,W
3D50:  ADDWFC 03,W
3D52:  MOVWF  FEA
3D54:  MOVFF  FEF,331
3D58:  MOVLB  3
3D5A:  MOVFF  330,FEA
3D5E:  MOVFF  01,FE9
3D62:  MOVFF  331,FEF
3D66:  BRA    3DA2
....................  
....................       else 
....................          entire_entry[(entry_pos << 1) + 6] = name[name_pos]; 
3D68:  BCF    FD8.0
3D6A:  RLCF   x29,W
3D6C:  ADDLW  06
3D6E:  CLRF   03
3D70:  ADDLW  09
3D72:  MOVWF  01
3D74:  MOVLW  03
3D76:  ADDWFC 03,F
3D78:  MOVFF  03,330
3D7C:  CLRF   03
3D7E:  MOVF   x07,W
3D80:  BTFSC  FE8.7
3D82:  DECF   03,F
3D84:  MOVLB  2
3D86:  ADDWF  xF9,W
3D88:  MOVWF  FE9
3D8A:  MOVF   xFA,W
3D8C:  ADDWFC 03,W
3D8E:  MOVWF  FEA
3D90:  MOVFF  FEF,331
3D94:  MOVLB  3
3D96:  MOVFF  330,FEA
3D9A:  MOVFF  01,FE9
3D9E:  MOVFF  331,FEF
....................  
....................       if((entry_pos == 0) 
....................          && (name_pos != strlen (name))) 
3DA2:  MOVF   x29,F
3DA4:  BNZ   3E40
3DA6:  MOVFF  2FA,39B
3DAA:  MOVFF  2F9,39A
3DAE:  MOVLB  0
3DB0:  CALL   1060
3DB4:  MOVLB  3
3DB6:  CLRF   x30
3DB8:  MOVFF  01,32F
3DBC:  CLRF   03
3DBE:  MOVF   x07,W
3DC0:  MOVWF  00
3DC2:  BTFSC  FE8.7
3DC4:  DECF   03,F
3DC6:  SUBWF  01,W
3DC8:  BNZ   3DD0
3DCA:  MOVF   x30,W
3DCC:  SUBWF  03,W
3DCE:  BZ    3E40
....................       { 
....................          entire_entry[0] = long_entry; 
3DD0:  MOVFF  32A,309
....................  
....................          // clear off the bits at positions 6 and 7 if the most recent entry was the final one. 
....................          if(name_pos != 0) 
3DD4:  MOVF   x07,F
3DD6:  BZ    3DDC
....................             long_entry &= 0x3F; 
3DD8:  MOVLW  3F
3DDA:  ANDWF  x2A,F
....................  
....................          long_entry -= 1; 
3DDC:  MOVLW  01
3DDE:  SUBWF  x2A,F
....................  
....................          entire_entry[13] = chksum; 
3DE0:  MOVFF  308,316
....................          if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
3DE4:  MOVFF  32E,3D9
3DE8:  MOVFF  32D,3D8
3DEC:  MOVFF  32C,3D7
3DF0:  MOVFF  32B,3D6
3DF4:  CLRF   xDB
3DF6:  MOVLW  20
3DF8:  MOVWF  xDA
3DFA:  MOVLW  03
3DFC:  MOVWF  xDD
3DFE:  MOVLW  09
3E00:  MOVWF  xDC
3E02:  MOVLB  0
3E04:  CALL   198E
3E08:  MOVF   01,F
3E0A:  BZ    3E12
....................             return EOF; 
3E0C:  MOVLW  FF
3E0E:  MOVWF  01
3E10:  BRA    3E92
....................          if(get_next_free_entry(&i) == EOF) 
3E12:  MOVLW  03
3E14:  MOVLB  3
3E16:  MOVWF  x30
3E18:  MOVLW  2B
3E1A:  MOVWF  x2F
3E1C:  MOVLB  0
3E1E:  RCALL  398C
3E20:  MOVF   01,W
3E22:  SUBLW  FF
3E24:  BNZ   3E2C
....................             return EOF; 
3E26:  MOVLW  FF
3E28:  MOVWF  01
3E2A:  BRA    3E92
....................          fill_entry(entire_entry, 0x00, 0); 
3E2C:  MOVLW  03
3E2E:  MOVLB  3
3E30:  MOVWF  x30
3E32:  MOVLW  09
3E34:  MOVWF  x2F
3E36:  CLRF   x31
3E38:  CLRF   x32
3E3A:  MOVLB  0
3E3C:  RCALL  3AEA
3E3E:  MOVLB  3
....................       } 
....................       name_pos -= 1; 
3E40:  MOVLW  01
3E42:  SUBWF  x07,F
3E44:  BRA    3CC2
....................    } 
....................  
....................    // write the short file name to the entry 
....................    if(mmcsd_write_data(i, 11, sname) != GOODEC) 
3E46:  MOVFF  32E,3D9
3E4A:  MOVFF  32D,3D8
3E4E:  MOVFF  32C,3D7
3E52:  MOVFF  32B,3D6
3E56:  CLRF   xDB
3E58:  MOVLW  0B
3E5A:  MOVWF  xDA
3E5C:  MOVLW  02
3E5E:  MOVWF  xDD
3E60:  MOVLW  FB
3E62:  MOVWF  xDC
3E64:  MOVLB  0
3E66:  CALL   198E
3E6A:  MOVF   01,F
3E6C:  BZ    3E74
....................       return EOF; 
3E6E:  MOVLW  FF
3E70:  MOVWF  01
3E72:  BRA    3E92
....................  
....................    // set the new entry addr 
....................    *entry_addr = i; 
3E74:  MOVLB  2
3E76:  MOVFF  2F7,FE9
3E7A:  MOVFF  2F8,FEA
3E7E:  MOVFF  32B,FEF
3E82:  MOVFF  32C,FEC
3E86:  MOVFF  32D,FEC
3E8A:  MOVFF  32E,FEC
....................  
....................    return GOODEC; 
3E8E:  MOVLW  00
3E90:  MOVWF  01
3E92:  MOVLB  0
3E94:  GOTO   3F7E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... Summary: Reads a file's short file name, puts all the characters into lower case, and puts it into a buffer. 
.................... Param file_entry_addr: Where the file's entry address is located. 
.................... Param sname: The buffer to put the short file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
*
109C:  MOVLB  3
109E:  CLRF   x99
.................... { 
....................    int 
....................       buf, 
....................       i, 
....................       j = 0; 
....................  
....................    // one short file name has, at the most, 11 characters 
....................    for(i = 0; i < 11; i += 1) 
10A0:  CLRF   x98
10A2:  MOVF   x98,W
10A4:  SUBLW  0A
10A6:  BNC   111E
....................    {       
....................       // read in a character 
....................       if(mmcsd_read_data(i + file_entry_addr, 1, &buf) != GOODEC) 
10A8:  MOVF   x98,W
10AA:  ADDWF  x90,W
10AC:  MOVWF  x9A
10AE:  MOVLW  00
10B0:  ADDWFC x91,W
10B2:  MOVWF  x9B
10B4:  MOVLW  00
10B6:  ADDWFC x92,W
10B8:  MOVWF  x9C
10BA:  MOVLW  00
10BC:  ADDWFC x93,W
10BE:  MOVWF  x9D
10C0:  MOVWF  xC0
10C2:  MOVFF  39C,3BF
10C6:  MOVFF  39B,3BE
10CA:  MOVFF  39A,3BD
10CE:  CLRF   xC2
10D0:  MOVLW  01
10D2:  MOVWF  xC1
10D4:  MOVLW  03
10D6:  MOVWF  xC4
10D8:  MOVLW  97
10DA:  MOVWF  xC3
10DC:  MOVLB  0
10DE:  RCALL  0A80
10E0:  MOVF   01,F
10E2:  BZ    10EA
....................          return EOF; 
10E4:  MOVLW  FF
10E6:  MOVWF  01
10E8:  BRA    11CE
....................        
....................       // convert the character 
....................       if(buf != ' ') 
10EA:  MOVLB  3
10EC:  MOVF   x97,W
10EE:  SUBLW  20
10F0:  BZ    1118
....................       {          
....................          sname[j] = tolower(buf); 
10F2:  MOVF   x99,W
10F4:  ADDWF  x94,W
10F6:  MOVWF  FE9
10F8:  MOVLW  00
10FA:  ADDWFC x95,W
10FC:  MOVWF  FEA
10FE:  MOVF   x97,W
1100:  SUBLW  40
1102:  BC    1110
1104:  MOVF   x97,W
1106:  SUBLW  5A
1108:  BNC   1110
110A:  MOVF   x97,W
110C:  IORLW  20
110E:  BRA    1112
1110:  MOVF   x97,W
1112:  MOVWF  FEF
....................          j += 1; 
1114:  MOVLW  01
1116:  ADDWF  x99,F
....................       } 
1118:  MOVLW  01
111A:  ADDWF  x98,F
111C:  BRA    10A2
....................        
....................    }    
....................  
....................    // tack on a null terminator 
....................    sname[j] = '\0'; 
111E:  MOVF   x99,W
1120:  ADDWF  x94,W
1122:  MOVWF  FE9
1124:  MOVLW  00
1126:  ADDWFC x95,W
1128:  MOVWF  FEA
112A:  CLRF   FEF
....................     
....................    //printf("\r\n%s, %u\r\n",sname, strlen(sname)); 
....................  
....................    if(type != 0x10 && strlen(sname) > 3) 
112C:  MOVF   x96,W
112E:  SUBLW  10
1130:  BZ    11BA
1132:  MOVFF  395,39B
1136:  MOVFF  394,39A
113A:  MOVLB  0
113C:  RCALL  1060
113E:  MOVFF  02,39B
1142:  MOVFF  01,39A
1146:  MOVLB  3
1148:  MOVF   x9B,F
114A:  BNZ   1152
114C:  MOVF   x9A,W
114E:  SUBLW  03
1150:  BC    11BA
....................    { 
....................       j = strlen(sname); 
1152:  MOVFF  395,39B
1156:  MOVFF  394,39A
115A:  MOVLB  0
115C:  RCALL  1060
115E:  MOVFF  01,399
....................       for(i=j; i > j-3; --i) 
1162:  MOVFF  399,398
1166:  MOVLW  03
1168:  MOVLB  3
116A:  SUBWF  x99,W
116C:  SUBWF  x98,W
116E:  BZ    11AA
1170:  BNC   11AA
....................          sname[i] = sname[i-1]; 
1172:  MOVF   x98,W
1174:  ADDWF  x94,W
1176:  MOVWF  01
1178:  MOVLW  00
117A:  ADDWFC x95,W
117C:  MOVWF  03
117E:  MOVFF  01,39A
1182:  MOVWF  x9B
1184:  MOVLW  01
1186:  SUBWF  x98,W
1188:  ADDWF  x94,W
118A:  MOVWF  FE9
118C:  MOVLW  00
118E:  ADDWFC x95,W
1190:  MOVWF  FEA
1192:  MOVFF  FEF,39C
1196:  MOVFF  03,FEA
119A:  MOVFF  01,FE9
119E:  MOVFF  39C,FEF
11A2:  DECF   x98,F
11A4:  MOVLB  0
11A6:  BRA    1166
11A8:  MOVLB  3
....................       sname[i] = '.'; 
11AA:  MOVF   x98,W
11AC:  ADDWF  x94,W
11AE:  MOVWF  FE9
11B0:  MOVLW  00
11B2:  ADDWFC x95,W
11B4:  MOVWF  FEA
11B6:  MOVLW  2E
11B8:  MOVWF  FEF
....................    } 
....................     
....................    sname[j+1] = '\0'; 
11BA:  MOVLW  01
11BC:  ADDWF  x99,W
11BE:  ADDWF  x94,W
11C0:  MOVWF  FE9
11C2:  MOVLW  00
11C4:  ADDWFC x95,W
11C6:  MOVWF  FEA
11C8:  CLRF   FEF
....................  
....................    return GOODEC; 
11CA:  MOVLW  00
11CC:  MOVWF  01
11CE:  MOVLB  0
11D0:  GOTO   1744 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... Summary: Creates a unique short file name in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param fname: The full file name. 
.................... Param sname: Character array that will hold the short file name upon function completion. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
*
351A:  CLRF   x58
351C:  CLRF   x59
351E:  CLRF   x5D
3520:  CLRF   x5C
3522:  CLRF   x5B
3524:  CLRF   x5A
.................... { 
....................    char 
....................       val[12] = "           ", 
*
34D8:  MOVLW  20
34DA:  MOVLB  3
34DC:  MOVWF  x37
34DE:  MOVWF  x38
34E0:  MOVWF  x39
34E2:  MOVWF  x3A
34E4:  MOVWF  x3B
34E6:  MOVWF  x3C
34E8:  MOVWF  x3D
34EA:  MOVWF  x3E
34EC:  MOVWF  x3F
34EE:  MOVWF  x40
34F0:  MOVWF  x41
34F2:  CLRF   x42
....................       cur_fname[12] = "           ", 
34F4:  MOVWF  x43
34F6:  MOVWF  x44
34F8:  MOVWF  x45
34FA:  MOVWF  x46
34FC:  MOVWF  x47
34FE:  MOVWF  x48
3500:  MOVWF  x49
3502:  MOVWF  x4A
3504:  MOVWF  x4B
3506:  MOVWF  x4C
3508:  MOVWF  x4D
350A:  CLRF   x4E
....................       cur_fnum[7] = "      "; 
350C:  MOVWF  x4F
350E:  MOVWF  x50
3510:  MOVWF  x51
3512:  MOVWF  x52
3514:  MOVWF  x53
3516:  MOVWF  x54
3518:  CLRF   x55
....................  
....................    int 
....................       buf, 
....................       ext_pos, 
....................       fname_parse_pos = 0, 
....................       val_parse_pos = 0; 
....................  
....................    int32 
....................       fnum = 0, 
....................       i; 
....................  
....................    // figure out where the extension position is 
....................    ext_pos = strchr(fname, '.'); 
*
3526:  MOVFF  334,363
352A:  MOVFF  333,362
352E:  MOVLW  2E
3530:  MOVWF  x64
3532:  MOVLB  0
3534:  RCALL  33AE
3536:  MOVFF  01,357
....................  
....................    // check to see if this file has an extension 
....................    if(ext_pos == 0) 
353A:  MOVLB  3
353C:  MOVF   x57,F
353E:  BNZ   35CC
....................    { 
....................       while((val_parse_pos < 8) && (fname[fname_parse_pos] != '\0')) 
3540:  MOVF   x59,W
3542:  SUBLW  07
3544:  BNC   35CA
3546:  MOVF   x58,W
3548:  ADDWF  x33,W
354A:  MOVWF  FE9
354C:  MOVLW  00
354E:  ADDWFC x34,W
3550:  MOVWF  FEA
3552:  MOVF   FEF,F
3554:  BZ    35CA
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
3556:  CLRF   03
3558:  MOVF   x59,W
355A:  ADDLW  37
355C:  MOVWF  01
355E:  MOVLW  03
3560:  ADDWFC 03,F
3562:  MOVFF  01,362
3566:  MOVFF  03,363
356A:  MOVF   x58,W
356C:  ADDWF  x33,W
356E:  MOVWF  FE9
3570:  MOVLW  00
3572:  ADDWFC x34,W
3574:  MOVWF  FEA
3576:  MOVFF  FEF,364
357A:  MOVF   x64,W
357C:  SUBLW  60
357E:  BC    358C
3580:  MOVF   x64,W
3582:  SUBLW  7A
3584:  BNC   358C
3586:  MOVF   x64,W
3588:  ANDLW  DF
358A:  BRA    358E
358C:  MOVF   x64,W
358E:  MOVFF  363,FEA
3592:  MOVFF  362,FE9
3596:  MOVWF  FEF
....................          val_parse_pos += 1; 
3598:  MOVLW  01
359A:  ADDWF  x59,F
....................          fname_parse_pos += 1; 
359C:  ADDWF  x58,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
359E:  MOVF   x58,W
35A0:  ADDWF  x33,W
35A2:  MOVWF  FE9
35A4:  MOVLW  00
35A6:  ADDWFC x34,W
35A8:  MOVWF  FEA
35AA:  MOVF   FEF,W
35AC:  SUBLW  2E
35AE:  BZ    35C2
35B0:  MOVF   x58,W
35B2:  ADDWF  x33,W
35B4:  MOVWF  FE9
35B6:  MOVLW  00
35B8:  ADDWFC x34,W
35BA:  MOVWF  FEA
35BC:  MOVF   FEF,W
35BE:  SUBLW  20
35C0:  BNZ   35C8
....................             fname_parse_pos += 1; 
35C2:  MOVLW  01
35C4:  ADDWF  x58,F
35C6:  BRA    359E
35C8:  BRA    3540
....................       } 
....................    } 
35CA:  BRA    367A
....................    else 
....................    { 
....................       ext_pos -= fname - 1; 
35CC:  MOVLW  01
35CE:  SUBWF  x33,W
35D0:  MOVWF  00
35D2:  MOVLW  00
35D4:  SUBWFB x34,W
35D6:  MOVF   00,W
35D8:  SUBWF  x57,F
....................       while((val_parse_pos < 11) && (fname[fname_parse_pos] != '\0')) 
35DA:  MOVF   x59,W
35DC:  SUBLW  0A
35DE:  BNC   367A
35E0:  MOVF   x58,W
35E2:  ADDWF  x33,W
35E4:  MOVWF  FE9
35E6:  MOVLW  00
35E8:  ADDWFC x34,W
35EA:  MOVWF  FEA
35EC:  MOVF   FEF,F
35EE:  BZ    367A
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
35F0:  CLRF   03
35F2:  MOVF   x59,W
35F4:  ADDLW  37
35F6:  MOVWF  01
35F8:  MOVLW  03
35FA:  ADDWFC 03,F
35FC:  MOVFF  01,362
3600:  MOVFF  03,363
3604:  MOVF   x58,W
3606:  ADDWF  x33,W
3608:  MOVWF  FE9
360A:  MOVLW  00
360C:  ADDWFC x34,W
360E:  MOVWF  FEA
3610:  MOVFF  FEF,364
3614:  MOVF   x64,W
3616:  SUBLW  60
3618:  BC    3626
361A:  MOVF   x64,W
361C:  SUBLW  7A
361E:  BNC   3626
3620:  MOVF   x64,W
3622:  ANDLW  DF
3624:  BRA    3628
3626:  MOVF   x64,W
3628:  MOVFF  363,FEA
362C:  MOVFF  362,FE9
3630:  MOVWF  FEF
....................          val_parse_pos += 1; 
3632:  MOVLW  01
3634:  ADDWF  x59,F
....................          fname_parse_pos += 1; 
3636:  ADDWF  x58,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
3638:  MOVF   x58,W
363A:  ADDWF  x33,W
363C:  MOVWF  FE9
363E:  MOVLW  00
3640:  ADDWFC x34,W
3642:  MOVWF  FEA
3644:  MOVF   FEF,W
3646:  SUBLW  2E
3648:  BZ    365C
364A:  MOVF   x58,W
364C:  ADDWF  x33,W
364E:  MOVWF  FE9
3650:  MOVLW  00
3652:  ADDWFC x34,W
3654:  MOVWF  FEA
3656:  MOVF   FEF,W
3658:  SUBLW  20
365A:  BNZ   3662
....................             fname_parse_pos += 1; 
365C:  MOVLW  01
365E:  ADDWF  x58,F
3660:  BRA    3638
....................  
....................          // check to see if it's time to skip val_parse_pos ahead to the file extension 
....................          if(fname_parse_pos == ext_pos) 
3662:  MOVF   x57,W
3664:  SUBWF  x58,W
3666:  BNZ   366E
....................             val_parse_pos = 8; 
3668:  MOVLW  08
366A:  MOVWF  x59
366C:  BRA    3678
....................  
....................          // check to see if it's time to skip name_parse_pos ahead to the file extension 
....................          else if(val_parse_pos == 8) 
366E:  MOVF   x59,W
3670:  SUBLW  08
3672:  BNZ   3678
....................             fname_parse_pos = ext_pos; 
3674:  MOVFF  357,358
3678:  BRA    35DA
....................       } 
....................    } 
....................  
....................    // now that we've got the short file name, we need to make it unique 
....................    i = parent_dir_addr; 
367A:  MOVFF  332,361
367E:  MOVFF  331,360
3682:  MOVFF  330,35F
3686:  MOVFF  32F,35E
....................    if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
368A:  MOVLW  0B
368C:  ADDWF  x5E,W
368E:  MOVWF  x62
3690:  MOVLW  00
3692:  ADDWFC x5F,W
3694:  MOVWF  x63
3696:  MOVLW  00
3698:  ADDWFC x60,W
369A:  MOVWF  x64
369C:  MOVLW  00
369E:  ADDWFC x61,W
36A0:  MOVWF  x65
36A2:  MOVWF  xC0
36A4:  MOVFF  364,3BF
36A8:  MOVFF  363,3BE
36AC:  MOVFF  362,3BD
36B0:  CLRF   xC2
36B2:  MOVLW  01
36B4:  MOVWF  xC1
36B6:  MOVLW  03
36B8:  MOVWF  xC4
36BA:  MOVLW  56
36BC:  MOVWF  xC3
36BE:  MOVLB  0
36C0:  CALL   0A80
36C4:  MOVF   01,F
36C6:  BZ    36CE
....................       return EOF; 
36C8:  MOVLW  FF
36CA:  MOVWF  01
36CC:  BRA    3940
....................  
....................    // keep reading until we hit empty space 
....................    while(buf != 0x00) 
36CE:  MOVLB  3
36D0:  MOVF   x56,F
36D2:  BTFSC  FD8.2
36D4:  BRA    38E6
....................    { 
....................       // check to see if this is a short file name entry 
....................       if((buf == 0x20) || (buf == 0x10)) 
36D6:  MOVF   x56,W
36D8:  SUBLW  20
36DA:  BZ    36E4
36DC:  MOVF   x56,W
36DE:  SUBLW  10
36E0:  BTFSS  FD8.2
36E2:  BRA    3834
....................       { 
....................          // read in the short file name that we're currently pointing at 
....................          if(mmcsd_read_data(i, 11, cur_fname) != GOODEC) 
36E4:  MOVFF  361,3C0
36E8:  MOVFF  360,3BF
36EC:  MOVFF  35F,3BE
36F0:  MOVFF  35E,3BD
36F4:  CLRF   xC2
36F6:  MOVLW  0B
36F8:  MOVWF  xC1
36FA:  MOVLW  03
36FC:  MOVWF  xC4
36FE:  MOVLW  43
3700:  MOVWF  xC3
3702:  MOVLB  0
3704:  CALL   0A80
3708:  MOVF   01,F
370A:  BZ    3712
....................             return EOF; 
370C:  MOVLW  FF
370E:  MOVWF  01
3710:  BRA    3940
....................  
....................          cur_fname[11] = '\0'; 
3712:  MOVLB  3
3714:  CLRF   x4E
....................  
....................          // strcmp will return a 0 if the file name we're currently pointing at and the file name that we created above are the same 
....................          if(strcmp(cur_fname, val) == 0) 
3716:  MOVLW  03
3718:  MOVWF  x83
371A:  MOVLW  43
371C:  MOVWF  x82
371E:  MOVLW  03
3720:  MOVWF  x85
3722:  MOVLW  37
3724:  MOVWF  x84
3726:  MOVLB  0
3728:  CALL   1842
372C:  MOVF   01,F
372E:  BTFSS  FD8.2
3730:  BRA    3836
....................          { 
....................             // we now need to create a unique file name 
....................             //  increment the unique file number by one 
....................             fnum += 1; 
3732:  MOVLW  01
3734:  MOVLB  3
3736:  ADDWF  x5A,F
3738:  MOVLW  00
373A:  ADDWFC x5B,F
373C:  ADDWFC x5C,F
373E:  ADDWFC x5D,F
....................  
....................             // convert the unique file number to a string 
....................             sprintf(cur_fnum, "%lu", fnum); 
3740:  MOVLW  03
3742:  MOVLB  2
3744:  MOVWF  x23
3746:  MOVLW  4F
3748:  MOVWF  x22
374A:  MOVLW  41
374C:  MOVWF  FE9
374E:  MOVFF  35D,365
3752:  MOVFF  35C,364
3756:  MOVFF  35B,363
375A:  MOVFF  35A,362
375E:  MOVLB  0
3760:  BRA    3414
....................  
....................             // put the unique file number, along with a '~' into our short file name 
....................             fname_parse_pos = 0; 
3762:  MOVLB  3
3764:  CLRF   x58
....................  
....................             // find out the last posiiton of a space 
....................             val_parse_pos = strchr(val, ' '); 
3766:  MOVLW  03
3768:  MOVWF  x63
376A:  MOVLW  37
376C:  MOVWF  x62
376E:  MOVLW  20
3770:  MOVWF  x64
3772:  MOVLB  0
3774:  RCALL  33AE
3776:  MOVFF  01,359
....................             if(val_parse_pos == 0) 
377A:  MOVLB  3
377C:  MOVF   x59,F
377E:  BNZ   379E
....................                // if there isn't a space, then we're going to have to put the ~x at the end of the short name 
....................                val_parse_pos = 7 - strlen(cur_fnum); 
3780:  MOVLW  03
3782:  MOVWF  x9B
3784:  MOVLW  4F
3786:  MOVWF  x9A
3788:  MOVLB  0
378A:  CALL   1060
378E:  MOVFF  02,03
3792:  MOVF   01,W
3794:  XORLW  FF
3796:  ADDLW  08
3798:  MOVLB  3
379A:  MOVWF  x59
379C:  BRA    37A2
....................             else 
....................                // if there is a space, then put the ~x there 
....................                val_parse_pos -= val + 2; 
379E:  MOVLW  39
37A0:  SUBWF  x59,F
....................  
....................             // make some room for extra digits 
....................             buf = 10; 
37A2:  MOVLW  0A
37A4:  MOVWF  x56
....................             while(fnum >= buf) 
37A6:  MOVF   x5D,F
37A8:  BNZ   37B8
37AA:  MOVF   x5C,F
37AC:  BNZ   37B8
37AE:  MOVF   x5B,F
37B0:  BNZ   37B8
37B2:  MOVF   x56,W
37B4:  SUBWF  x5A,W
37B6:  BNC   37C6
....................             { 
....................                val_parse_pos -= 1; 
37B8:  MOVLW  01
37BA:  SUBWF  x59,F
....................                buf *= 10; 
37BC:  MOVF   x56,W
37BE:  MULLW  0A
37C0:  MOVFF  FF3,356
37C4:  BRA    37A6
....................             } 
....................  
....................             // write in the ~ 
....................             val[val_parse_pos] = '~'; 
37C6:  CLRF   03
37C8:  MOVF   x59,W
37CA:  ADDLW  37
37CC:  MOVWF  FE9
37CE:  MOVLW  03
37D0:  ADDWFC 03,W
37D2:  MOVWF  FEA
37D4:  MOVLW  7E
37D6:  MOVWF  FEF
....................  
....................             // write in the number 
....................             val_parse_pos += 1; 
37D8:  MOVLW  01
37DA:  ADDWF  x59,F
....................             while(cur_fnum[fname_parse_pos] != '\0') 
37DC:  CLRF   03
37DE:  MOVF   x58,W
37E0:  ADDLW  4F
37E2:  MOVWF  FE9
37E4:  MOVLW  03
37E6:  ADDWFC 03,W
37E8:  MOVWF  FEA
37EA:  MOVF   FEF,F
37EC:  BZ    3824
....................             { 
....................                val[val_parse_pos] = cur_fnum[fname_parse_pos]; 
37EE:  CLRF   03
37F0:  MOVF   x59,W
37F2:  ADDLW  37
37F4:  MOVWF  01
37F6:  MOVLW  03
37F8:  ADDWFC 03,F
37FA:  MOVFF  03,363
37FE:  CLRF   03
3800:  MOVF   x58,W
3802:  ADDLW  4F
3804:  MOVWF  FE9
3806:  MOVLW  03
3808:  ADDWFC 03,W
380A:  MOVWF  FEA
380C:  MOVFF  FEF,364
3810:  MOVFF  363,FEA
3814:  MOVFF  01,FE9
3818:  MOVFF  364,FEF
....................                val_parse_pos += 1; 
381C:  MOVLW  01
381E:  ADDWF  x59,F
....................                fname_parse_pos += 1; 
3820:  ADDWF  x58,F
3822:  BRA    37DC
....................             } 
....................  
....................             // start the search over again to see if that unique file name/number combination is still taken up 
....................             i = parent_dir_addr; 
3824:  MOVFF  332,361
3828:  MOVFF  331,360
382C:  MOVFF  330,35F
3830:  MOVFF  32F,35E
3834:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // head to the next entry 
....................       if(get_next_entry(&i) == EOF) 
3836:  MOVLW  03
3838:  MOVLB  3
383A:  MOVWF  x83
383C:  MOVLW  5E
383E:  MOVWF  x82
3840:  MOVLB  0
3842:  CALL   2918
3846:  MOVF   01,W
3848:  SUBLW  FF
384A:  BNZ   389C
....................       { 
....................          // we're going to have to allocate another cluster 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
384C:  MOVFF  361,3A3
3850:  MOVFF  360,3A2
3854:  MOVFF  35F,3A1
3858:  MOVFF  35E,3A0
385C:  CALL   1268
3860:  MOVFF  03,365
3864:  MOVFF  02,364
3868:  MOVFF  01,363
386C:  MOVFF  00,362
3870:  MOVFF  03,39C
3874:  MOVFF  02,39B
3878:  MOVFF  01,39A
387C:  MOVFF  00,399
3880:  MOVLW  03
3882:  MOVLB  3
3884:  MOVWF  x9E
3886:  MOVLW  5E
3888:  MOVWF  x9D
388A:  MOVLB  0
388C:  CALL   2156
3890:  MOVF   01,W
3892:  SUBLW  FF
3894:  BNZ   389C
....................             return EOF;          
3896:  MOVLW  FF
3898:  MOVWF  01
389A:  BRA    3940
....................       } 
....................       if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
389C:  MOVLW  0B
389E:  MOVLB  3
38A0:  ADDWF  x5E,W
38A2:  MOVWF  x62
38A4:  MOVLW  00
38A6:  ADDWFC x5F,W
38A8:  MOVWF  x63
38AA:  MOVLW  00
38AC:  ADDWFC x60,W
38AE:  MOVWF  x64
38B0:  MOVLW  00
38B2:  ADDWFC x61,W
38B4:  MOVWF  x65
38B6:  MOVWF  xC0
38B8:  MOVFF  364,3BF
38BC:  MOVFF  363,3BE
38C0:  MOVFF  362,3BD
38C4:  CLRF   xC2
38C6:  MOVLW  01
38C8:  MOVWF  xC1
38CA:  MOVLW  03
38CC:  MOVWF  xC4
38CE:  MOVLW  56
38D0:  MOVWF  xC3
38D2:  MOVLB  0
38D4:  CALL   0A80
38D8:  MOVF   01,F
38DA:  BZ    38E2
....................          return EOF; 
38DC:  MOVLW  FF
38DE:  MOVWF  01
38E0:  BRA    3940
38E2:  BRA    36CE
38E4:  MOVLB  3
....................    } 
....................  
....................    // copy the short name into the input buffer 
....................    for(i = 0; i < 12; i += 1) 
38E6:  CLRF   x61
38E8:  CLRF   x60
38EA:  CLRF   x5F
38EC:  CLRF   x5E
38EE:  MOVF   x61,F
38F0:  BNZ   393C
38F2:  MOVF   x60,F
38F4:  BNZ   393C
38F6:  MOVF   x5F,F
38F8:  BNZ   393C
38FA:  MOVF   x5E,W
38FC:  SUBLW  0B
38FE:  BNC   393C
....................       sname[i] = val[i]; 
3900:  MOVF   x35,W
3902:  ADDWF  x5E,W
3904:  MOVWF  01
3906:  MOVF   x36,W
3908:  ADDWFC x5F,W
390A:  MOVWF  03
390C:  MOVFF  01,362
3910:  MOVWF  x63
3912:  MOVLW  37
3914:  ADDWF  x5E,W
3916:  MOVWF  FE9
3918:  MOVLW  03
391A:  ADDWFC x5F,W
391C:  MOVWF  FEA
391E:  MOVFF  FEF,364
3922:  MOVFF  03,FEA
3926:  MOVFF  01,FE9
392A:  MOVFF  364,FEF
392E:  MOVLW  01
3930:  ADDWF  x5E,F
3932:  MOVLW  00
3934:  ADDWFC x5F,F
3936:  ADDWFC x60,F
3938:  ADDWFC x61,F
393A:  BRA    38EE
....................  
....................    return GOODEC; 
393C:  MOVLW  00
393E:  MOVWF  01
3940:  MOVLB  0
3942:  GOTO   3BD0 (RETURN)
.................... } 
....................  
.................... /* 
.................... int long_name_chksum (int* FcbName) 
.................... Summary: Returns an unsigned byte checksum computed on an unsigned byte 
....................           array. The array must be 11 bytes long and is assumed to contain 
....................           a name stored in the format of a MS-DOS directory entry. 
.................... Param: Pointer to an unsigned byte array assumed to be 11 bytes long. 
.................... Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName. 
.................... */ 
.................... int long_name_chksum (int* pFcbName) 
3946:  MOVLB  3
3948:  CLRF   x32
.................... { 
....................    int 
....................       FcbNameLen, 
....................       Sum = 0; 
....................  
....................    for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen -= 1) 
394A:  MOVLW  0B
394C:  MOVWF  x31
394E:  MOVF   x31,F
3950:  BZ    3982
....................       // The operation is an unsigned char rotate right 
....................       Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++; 
3952:  BTFSS  x32.0
3954:  BRA    395A
3956:  MOVLW  80
3958:  BRA    395C
395A:  MOVLW  00
395C:  MOVWF  x33
395E:  BCF    FD8.0
3960:  RRCF   x32,W
3962:  ADDWF  x33,F
3964:  MOVFF  330,03
3968:  MOVF   x2F,W
396A:  INCF   x2F,F
396C:  BTFSC  FD8.2
396E:  INCF   x30,F
3970:  MOVWF  FE9
3972:  MOVFF  03,FEA
3976:  MOVF   FEF,W
3978:  ADDWF  x33,W
397A:  MOVWF  x32
397C:  MOVLW  01
397E:  SUBWF  x31,F
3980:  BRA    394E
....................  
....................    return Sum; 
3982:  MOVFF  332,01
3986:  MOVLB  0
3988:  GOTO   3BEA (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int check_invalid_char(char fname[]) 
.................... Summary: Checks the filename for any invalid characters. 
.................... Param: The name of the file to check. 
.................... Returns: EOF if an invalid character was found, GOODEC otherwise. 
.................... */ 
.................... signed int check_invalid_char(char fname[]) 
.................... { 
....................    int fname_pos; 
....................  
....................    for(fname_pos = 0; (fname[fname_pos] != '\0') && (fname_pos < MAX_FILE_NAME_LENGTH); fname_pos += 1) 
*
3338:  MOVLB  3
333A:  CLRF   x31
333C:  MOVF   x31,W
333E:  ADDWF  x2F,W
3340:  MOVWF  FE9
3342:  MOVLW  00
3344:  ADDWFC x30,W
3346:  MOVWF  FEA
3348:  MOVF   FEF,F
334A:  BZ    33A4
334C:  MOVF   x31,W
334E:  SUBLW  1F
3350:  BNC   33A4
....................       if(isamoung(fname[fname_pos], "\\/:*?\"<>|")) 
3352:  MOVF   x31,W
3354:  ADDWF  x2F,W
3356:  MOVWF  FE9
3358:  MOVLW  00
335A:  ADDWFC x30,W
335C:  MOVWF  FEA
335E:  MOVFF  FEF,332
3362:  MOVF   x32,W
3364:  SUBLW  22
3366:  BZ    3398
3368:  MOVF   x32,W
336A:  SUBLW  2A
336C:  BZ    3398
336E:  MOVF   x32,W
3370:  SUBLW  2F
3372:  BZ    3398
3374:  MOVF   x32,W
3376:  SUBLW  3A
3378:  BZ    3398
337A:  MOVF   x32,W
337C:  SUBLW  3C
337E:  BZ    3398
3380:  MOVF   x32,W
3382:  SUBLW  3D
3384:  BC    338C
3386:  MOVF   x32,W
3388:  SUBLW  3F
338A:  BC    3398
338C:  MOVF   x32,W
338E:  SUBLW  5C
3390:  BZ    3398
3392:  MOVF   x32,W
3394:  SUBLW  7C
3396:  BNZ   339E
....................          return EOF; 
3398:  MOVLW  FF
339A:  MOVWF  01
339C:  BRA    33A8
339E:  MOVLW  01
33A0:  ADDWF  x31,F
33A2:  BRA    333C
....................  
....................    return GOODEC; 
33A4:  MOVLW  00
33A6:  MOVWF  01
33A8:  MOVLB  0
33AA:  GOTO   3B9E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... Summary: Will go through the FAT and find the first unallocated cluster. 
.................... Param: Pointer to a variable that will the the starting cluster of the serach. 
....................         When a free cluster is found, the cluster number will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This gets a little slow when dealing with a card with lots of stuff on it; sorry about that. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAST_FAT 
....................    *my_cluster += 1; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................  
.................... #ifdef FAT32 
....................    int val[4];            // buffer to hold values 
....................  
....................    int32 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 2) + FAT_Start; 
*
1BB0:  MOVLB  3
1BB2:  MOVFF  3A7,FE9
1BB6:  MOVFF  3A8,FEA
1BBA:  MOVFF  FEF,3B9
1BBE:  MOVFF  FEC,3BA
1BC2:  MOVFF  FEC,3BB
1BC6:  MOVFF  FEC,3BC
1BCA:  RLCF   xB9,F
1BCC:  RLCF   xBA,F
1BCE:  RLCF   xBB,F
1BD0:  RLCF   xBC,F
1BD2:  RLCF   xB9,F
1BD4:  RLCF   xBA,F
1BD6:  RLCF   xBB,F
1BD8:  RLCF   xBC,F
1BDA:  MOVLW  FC
1BDC:  ANDWF  xB9,F
1BDE:  MOVLB  2
1BE0:  MOVF   x0E,W
1BE2:  MOVLB  3
1BE4:  ADDWF  xB9,W
1BE6:  MOVWF  xB1
1BE8:  MOVLB  2
1BEA:  MOVF   x0F,W
1BEC:  MOVLB  3
1BEE:  ADDWFC xBA,W
1BF0:  MOVWF  xB2
1BF2:  MOVLB  2
1BF4:  MOVF   x10,W
1BF6:  MOVLB  3
1BF8:  ADDWFC xBB,W
1BFA:  MOVWF  xB3
1BFC:  MOVLB  2
1BFE:  MOVF   x11,W
1C00:  MOVLB  3
1C02:  ADDWFC xBC,W
1C04:  MOVWF  xB4
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 4) 
1C06:  CLRF   xB8
1C08:  CLRF   xB7
1C0A:  CLRF   xB6
1C0C:  CLRF   xB5
1C0E:  MOVF   xB8,W
1C10:  MOVLB  2
1C12:  SUBWF  x19,W
1C14:  BTFSS  FD8.0
1C16:  BRA    1D34
1C18:  BNZ   1C46
1C1A:  MOVLB  3
1C1C:  MOVF   xB7,W
1C1E:  MOVLB  2
1C20:  SUBWF  x18,W
1C22:  BTFSS  FD8.0
1C24:  BRA    1D34
1C26:  BNZ   1C46
1C28:  MOVLB  3
1C2A:  MOVF   xB6,W
1C2C:  MOVLB  2
1C2E:  SUBWF  x17,W
1C30:  BTFSS  FD8.0
1C32:  BRA    1D34
1C34:  BNZ   1C46
1C36:  MOVF   x16,W
1C38:  MOVLB  3
1C3A:  SUBWF  xB5,W
1C3C:  BTFSS  FD8.0
1C3E:  BRA    1C44
1C40:  MOVLB  2
1C42:  BRA    1D34
1C44:  MOVLB  2
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 4, val) != GOODEC) 
1C46:  MOVLB  3
1C48:  MOVF   xB5,W
1C4A:  ADDWF  xB1,W
1C4C:  MOVWF  xB9
1C4E:  MOVF   xB6,W
1C50:  ADDWFC xB2,W
1C52:  MOVWF  xBA
1C54:  MOVF   xB7,W
1C56:  ADDWFC xB3,W
1C58:  MOVWF  xBB
1C5A:  MOVF   xB8,W
1C5C:  ADDWFC xB4,W
1C5E:  MOVWF  xBC
1C60:  MOVWF  xC0
1C62:  MOVFF  3BB,3BF
1C66:  MOVFF  3BA,3BE
1C6A:  MOVFF  3B9,3BD
1C6E:  CLRF   xC2
1C70:  MOVLW  04
1C72:  MOVWF  xC1
1C74:  MOVLW  03
1C76:  MOVWF  xC4
1C78:  MOVLW  A9
1C7A:  MOVWF  xC3
1C7C:  MOVLB  0
1C7E:  CALL   0A80
1C82:  MOVF   01,F
1C84:  BZ    1C8C
....................          return EOF; 
1C86:  MOVLW  FF
1C88:  MOVWF  01
1C8A:  BRA    1D3A
....................  
....................       cur_cluster = make32(val[3], val[2], val[1], val[0]); 
1C8C:  MOVFF  3AC,3B0
1C90:  MOVFF  3AB,3AF
1C94:  MOVFF  3AA,3AE
1C98:  MOVFF  3A9,3AD
....................  
....................       if(cur_cluster == 0) 
1C9C:  MOVLB  3
1C9E:  MOVF   xAD,F
1CA0:  BNZ   1D24
1CA2:  MOVF   xAE,F
1CA4:  BNZ   1D24
1CA6:  MOVF   xAF,F
1CA8:  BNZ   1D24
1CAA:  MOVF   xB0,F
1CAC:  BNZ   1D24
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
1CAE:  MOVF   xB5,W
1CB0:  ADDWF  xB1,F
1CB2:  MOVF   xB6,W
1CB4:  ADDWFC xB2,F
1CB6:  MOVF   xB7,W
1CB8:  ADDWFC xB3,F
1CBA:  MOVF   xB8,W
1CBC:  ADDWFC xB4,F
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 2; 
1CBE:  MOVFF  3A7,FE9
1CC2:  MOVFF  3A8,FEA
1CC6:  MOVLB  2
1CC8:  MOVF   x0E,W
1CCA:  MOVLB  3
1CCC:  SUBWF  xB1,W
1CCE:  MOVWF  xBB
1CD0:  MOVLB  2
1CD2:  MOVF   x0F,W
1CD4:  MOVLB  3
1CD6:  SUBWFB xB2,W
1CD8:  MOVWF  xBC
1CDA:  MOVLB  2
1CDC:  MOVF   x10,W
1CDE:  MOVLB  3
1CE0:  SUBWFB xB3,W
1CE2:  MOVWF  xBD
1CE4:  MOVLB  2
1CE6:  MOVF   x11,W
1CE8:  MOVLB  3
1CEA:  SUBWFB xB4,W
1CEC:  MOVWF  xBE
1CEE:  RRCF   xBE,W
1CF0:  MOVWF  03
1CF2:  RRCF   xBD,W
1CF4:  MOVWF  02
1CF6:  RRCF   xBC,W
1CF8:  MOVWF  01
1CFA:  RRCF   xBB,W
1CFC:  MOVWF  00
1CFE:  RRCF   03,F
1D00:  RRCF   02,F
1D02:  RRCF   01,F
1D04:  RRCF   00,F
1D06:  MOVLW  3F
1D08:  ANDWF  03,F
1D0A:  MOVFF  00,FEF
1D0E:  MOVFF  01,FEC
1D12:  MOVFF  02,FEC
1D16:  MOVFF  03,FEC
....................          return GOODEC; 
1D1A:  MOVLW  00
1D1C:  MOVWF  01
1D1E:  MOVLB  0
1D20:  BRA    1D3A
1D22:  MOVLB  3
....................       } 
1D24:  MOVLW  04
1D26:  ADDWF  xB5,F
1D28:  MOVLW  00
1D2A:  ADDWFC xB6,F
1D2C:  ADDWFC xB7,F
1D2E:  ADDWFC xB8,F
1D30:  BRA    1C0E
1D32:  MOVLB  2
....................    } 
.................... #else // FAT16 
....................    int val[2]; 
....................  
....................    int16 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 1) + FAT_Start; 
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 2) 
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 2, val) != GOODEC) 
....................          return EOF; 
....................  
....................       cur_cluster = make16(val[1], val[0]); 
....................  
....................       if(cur_cluster == 0) 
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 1; 
....................          return GOODEC; 
....................       } 
....................    } 
....................  
.................... #endif // #ifdef FAT32 
....................    // if we reach this point, we are out of disk space 
....................    return EOF; 
1D34:  MOVLW  FF
1D36:  MOVWF  01
1D38:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
1D3A:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the next file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_next_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry, 
....................       filetype; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go forward an entry 
....................       if(get_next_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................     
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  cluster_to_addr(cluster); 
....................     
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the previous file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_prev_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry = 0xE5, 
....................       filetype = 0; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go backward an entry 
....................       if(get_prev_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................  
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  addr_to_cluster(cluster); 
....................  
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... Summary: Finds the next unallocated address. 
.................... Param: Pointer to a variable that will the the starting address of the serach. 
....................         When a free address is found, the address will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... { 
....................    int val;   // buffer to hold values 
....................  
....................    int32 cur_addr;   // pointer to memory 
....................  
....................    // make a copy of *my_addr 
....................    cur_addr = *my_addr; 
....................  
....................    // keep on getting addresses until we hit a free one 
....................    do 
....................    { 
....................       if(mmcsd_read_data(cur_addr, 1, &val) != GOODEC) 
....................          return EOF; 
....................  
....................       if(get_next_addr(&cur_addr) == EOF) 
....................          return EOF; 
....................    } while(val != 0); 
....................  
....................    *my_addr = cur_addr; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_entry(int32* start_addr) 
.................... Summary: Gets the next entry in a directory. 
.................... Param: The address to start looking for an entry. 
....................    If an entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
2918:  MOVLB  3
291A:  MOVFF  382,FE9
291E:  MOVFF  383,FEA
2922:  MOVFF  FEF,384
2926:  MOVFF  FEC,385
292A:  MOVFF  FEC,386
292E:  MOVFF  FEC,387
....................     
....................    i += 0x1F; 
2932:  MOVLW  1F
2934:  ADDWF  x84,F
2936:  MOVLW  00
2938:  ADDWFC x85,F
293A:  ADDWFC x86,F
293C:  ADDWFC x87,F
....................     
....................    if(get_next_addr(&i) == EOF) 
293E:  MOVLW  03
2940:  MOVWF  x96
2942:  MOVLW  84
2944:  MOVWF  x95
2946:  MOVLB  0
2948:  CALL   1F52
294C:  MOVF   01,W
294E:  SUBLW  FF
2950:  BNZ   2958
....................       return EOF; 
2952:  MOVLW  FF
2954:  MOVWF  01
2956:  BRA    2978
....................     
....................    *start_addr = i; 
2958:  MOVLB  3
295A:  MOVFF  382,FE9
295E:  MOVFF  383,FEA
2962:  MOVFF  384,FEF
2966:  MOVFF  385,FEC
296A:  MOVFF  386,FEC
296E:  MOVFF  387,FEC
....................     
....................    return GOODEC; 
2972:  MOVLW  00
2974:  MOVWF  01
2976:  MOVLB  0
2978:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
1662:  MOVLB  3
1664:  MOVFF  390,FE9
1668:  MOVFF  391,FEA
166C:  MOVFF  FEF,392
1670:  MOVFF  FEC,393
1674:  MOVFF  FEC,394
1678:  MOVFF  FEC,395
....................  
....................    i -= 0x1F; 
167C:  MOVLW  1F
167E:  SUBWF  x92,F
1680:  MOVLW  00
1682:  SUBWFB x93,F
1684:  SUBWFB x94,F
1686:  SUBWFB x95,F
....................  
....................    if(get_prev_addr(&i) == EOF) 
1688:  MOVLW  03
168A:  MOVWF  x97
168C:  MOVLW  92
168E:  MOVWF  x96
1690:  MOVLB  0
1692:  BRA    141C
1694:  MOVF   01,W
1696:  SUBLW  FF
1698:  BNZ   16A0
....................       return EOF; 
169A:  MOVLW  FF
169C:  MOVWF  01
169E:  BRA    16BE
....................  
....................    *start_addr = i; 
16A0:  MOVLB  3
16A2:  MOVFF  390,FE9
16A6:  MOVFF  391,FEA
16AA:  MOVFF  392,FEF
16AE:  MOVFF  393,FEC
16B2:  MOVFF  394,FEC
16B6:  MOVFF  395,FEC
....................     
....................    return GOODEC; 
16BA:  MOVLW  00
16BC:  MOVWF  01
16BE:  MOVLB  0
16C0:  GOTO   1764 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... { 
....................    int buf; 
....................  
....................    int32 i; 
....................  
....................    i = *start_addr; 
*
398C:  MOVLB  3
398E:  MOVFF  32F,FE9
3992:  MOVFF  330,FEA
3996:  MOVFF  FEF,332
399A:  MOVFF  FEC,333
399E:  MOVFF  FEC,334
39A2:  MOVFF  FEC,335
....................  
....................    if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
39A6:  MOVFF  335,3C0
39AA:  MOVFF  334,3BF
39AE:  MOVFF  333,3BE
39B2:  MOVFF  332,3BD
39B6:  CLRF   xC2
39B8:  MOVLW  01
39BA:  MOVWF  xC1
39BC:  MOVLW  03
39BE:  MOVWF  xC4
39C0:  MOVLW  31
39C2:  MOVWF  xC3
39C4:  MOVLB  0
39C6:  CALL   0A80
39CA:  MOVF   01,F
39CC:  BZ    39D4
....................      return EOF; 
39CE:  MOVLW  FF
39D0:  MOVWF  01
39D2:  BRA    3A9C
....................  
....................    while(buf != 0) 
39D4:  MOVLB  3
39D6:  MOVF   x31,F
39D8:  BZ    3A7E
....................    { 
....................       i += 0x1F; 
39DA:  MOVLW  1F
39DC:  ADDWF  x32,F
39DE:  MOVLW  00
39E0:  ADDWFC x33,F
39E2:  ADDWFC x34,F
39E4:  ADDWFC x35,F
....................       // get the next address 
....................       if(get_next_addr(&i) == EOF) 
39E6:  MOVLW  03
39E8:  MOVWF  x96
39EA:  MOVLW  32
39EC:  MOVWF  x95
39EE:  MOVLB  0
39F0:  CALL   1F52
39F4:  MOVF   01,W
39F6:  SUBLW  FF
39F8:  BNZ   3A4A
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
39FA:  MOVFF  335,3A3
39FE:  MOVFF  334,3A2
3A02:  MOVFF  333,3A1
3A06:  MOVFF  332,3A0
3A0A:  CALL   1268
3A0E:  MOVFF  03,339
3A12:  MOVFF  02,338
3A16:  MOVFF  01,337
3A1A:  MOVFF  00,336
3A1E:  MOVFF  03,39C
3A22:  MOVFF  02,39B
3A26:  MOVFF  01,39A
3A2A:  MOVFF  00,399
3A2E:  MOVLW  03
3A30:  MOVLB  3
3A32:  MOVWF  x9E
3A34:  MOVLW  32
3A36:  MOVWF  x9D
3A38:  MOVLB  0
3A3A:  CALL   2156
3A3E:  MOVF   01,W
3A40:  SUBLW  FF
3A42:  BNZ   3A4A
....................             return EOF; 
3A44:  MOVLW  FF
3A46:  MOVWF  01
3A48:  BRA    3A9C
....................  
....................       if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
3A4A:  MOVFF  335,3C0
3A4E:  MOVFF  334,3BF
3A52:  MOVFF  333,3BE
3A56:  MOVFF  332,3BD
3A5A:  MOVLB  3
3A5C:  CLRF   xC2
3A5E:  MOVLW  01
3A60:  MOVWF  xC1
3A62:  MOVLW  03
3A64:  MOVWF  xC4
3A66:  MOVLW  31
3A68:  MOVWF  xC3
3A6A:  MOVLB  0
3A6C:  CALL   0A80
3A70:  MOVF   01,F
3A72:  BZ    3A7A
....................         return EOF; 
3A74:  MOVLW  FF
3A76:  MOVWF  01
3A78:  BRA    3A9C
3A7A:  BRA    39D4
3A7C:  MOVLB  3
....................    } 
....................  
....................    *start_addr = i; 
3A7E:  MOVFF  32F,FE9
3A82:  MOVFF  330,FEA
3A86:  MOVFF  332,FEF
3A8A:  MOVFF  333,FEC
3A8E:  MOVFF  334,FEC
3A92:  MOVFF  335,FEC
....................  
....................    return GOODEC; 
3A96:  MOVLW  00
3A98:  MOVWF  01
3A9A:  MOVLB  0
3A9C:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... Summary: Find, allocate, and link a free cluster. 
.................... Param start_cluster: The cluster to begin looking for free clusters. This cluster will be linked to the newfound cluster in the FAT. 
.................... Param new_cluster_addr: The address of the newly allocated cluster. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr) 
.................... #else 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster, 
....................       next_cluster; 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster, 
....................       next_cluster; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're at the end of the file's allocated space, then we need to allocate some more space 
....................    //  figure out where the current character is pointing to 
....................    next_cluster = cur_cluster = start_cluster; 
*
2156:  MOVFF  39C,3A2
215A:  MOVFF  39B,3A1
215E:  MOVFF  39A,3A0
2162:  MOVFF  399,39F
2166:  MOVFF  3A2,3A6
216A:  MOVFF  3A1,3A5
216E:  MOVFF  3A0,3A4
2172:  MOVFF  39F,3A3
....................  
....................    // get the next free cluster 
....................    if(get_next_free_cluster(&next_cluster) == EOF) 
2176:  MOVLW  03
2178:  MOVLB  3
217A:  MOVWF  xA8
217C:  MOVLW  A3
217E:  MOVWF  xA7
2180:  MOVLB  0
2182:  RCALL  1BB0
2184:  MOVF   01,W
2186:  SUBLW  FF
2188:  BNZ   2190
....................       return EOF; 
218A:  MOVLW  FF
218C:  MOVWF  01
218E:  BRA    2246
....................  
....................    if(write_fat(cur_cluster, next_cluster) == EOF) 
2190:  MOVFF  3A2,3AA
2194:  MOVFF  3A1,3A9
2198:  MOVFF  3A0,3A8
219C:  MOVFF  39F,3A7
21A0:  MOVFF  3A6,3AE
21A4:  MOVFF  3A5,3AD
21A8:  MOVFF  3A4,3AC
21AC:  MOVFF  3A3,3AB
21B0:  RCALL  1A14
21B2:  MOVF   01,W
21B4:  SUBLW  FF
21B6:  BNZ   21BE
....................       return EOF; 
21B8:  MOVLW  FF
21BA:  MOVWF  01
21BC:  BRA    2246
....................  
.................... #ifdef FAT32 
....................    if(write_fat(next_cluster, 0x0FFFFFFF) == EOF) 
21BE:  MOVFF  3A6,3AA
21C2:  MOVFF  3A5,3A9
21C6:  MOVFF  3A4,3A8
21CA:  MOVFF  3A3,3A7
21CE:  MOVLW  0F
21D0:  MOVLB  3
21D2:  MOVWF  xAE
21D4:  SETF   xAD
21D6:  SETF   xAC
21D8:  SETF   xAB
21DA:  MOVLB  0
21DC:  RCALL  1A14
21DE:  MOVF   01,W
21E0:  SUBLW  FF
21E2:  BNZ   21EA
....................       return EOF; 
21E4:  MOVLW  FF
21E6:  MOVWF  01
21E8:  BRA    2246
....................  
.................... #else // FAT16 
....................    if(write_fat(next_cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // erase all of the data in the newly linked cluster 
....................    if(clear_cluster(next_cluster) == EOF) 
21EA:  MOVFF  3A6,3AA
21EE:  MOVFF  3A5,3A9
21F2:  MOVFF  3A4,3A8
21F6:  MOVFF  3A3,3A7
21FA:  RCALL  1D3C
21FC:  MOVF   01,W
21FE:  SUBLW  FF
2200:  BNZ   2208
....................       return EOF; 
2202:  MOVLW  FF
2204:  MOVWF  01
2206:  BRA    2246
....................  
....................    // put the current character to this position 
....................    *new_cluster_addr = cluster_to_addr(next_cluster); 
2208:  MOVFF  39E,03
220C:  MOVFF  39D,3A7
2210:  MOVFF  39E,3A8
2214:  MOVFF  3A6,3D5
2218:  MOVFF  3A5,3D4
221C:  MOVFF  3A4,3D3
2220:  MOVFF  3A3,3D2
2224:  MOVLB  0
2226:  CALL   13BE
222A:  MOVFF  3A8,FEA
222E:  MOVFF  3A7,FE9
2232:  MOVFF  00,FEF
2236:  MOVFF  01,FEC
223A:  MOVFF  02,FEC
223E:  MOVFF  03,FEC
....................  
....................    return GOODEC; 
2242:  MOVLW  00
2244:  MOVWF  01
2246:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... Summary: De-allocates linked clusters from the FAT. 
.................... Param: The starting cluster to deallocate. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int dealloc_clusters(int32 start_cluster) 
.................... #else 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #endif // #ifdef FAT32 
....................  
....................    //  figure out where the first cluster is 
....................    next_cluster = cur_cluster = start_cluster; 
*
1A84:  MOVFF  389,38D
1A88:  MOVFF  388,38C
1A8C:  MOVFF  387,38B
1A90:  MOVFF  386,38A
1A94:  MOVFF  38D,391
1A98:  MOVFF  38C,390
1A9C:  MOVFF  38B,38F
1AA0:  MOVFF  38A,38E
....................    do 
....................    { 
....................       // get the next cluster 
....................       if(get_next_cluster(&next_cluster) == EOF) 
1AA4:  MOVLW  03
1AA6:  MOVLB  3
1AA8:  MOVWF  x9C
1AAA:  MOVLW  8E
1AAC:  MOVWF  x9B
1AAE:  MOVLB  0
1AB0:  RCALL  18BA
1AB2:  MOVF   01,W
1AB4:  SUBLW  FF
1AB6:  BNZ   1ABE
....................          return EOF; 
1AB8:  MOVLW  FF
1ABA:  MOVWF  01
1ABC:  BRA    1B28
....................  
....................       // unlink the current cluster in the FAT 
....................       if(write_fat(cur_cluster, 0) == EOF) 
1ABE:  MOVFF  38D,3AA
1AC2:  MOVFF  38C,3A9
1AC6:  MOVFF  38B,3A8
1ACA:  MOVFF  38A,3A7
1ACE:  MOVLB  3
1AD0:  CLRF   xAE
1AD2:  CLRF   xAD
1AD4:  CLRF   xAC
1AD6:  CLRF   xAB
1AD8:  MOVLB  0
1ADA:  RCALL  1A14
1ADC:  MOVF   01,W
1ADE:  SUBLW  FF
1AE0:  BNZ   1AE8
....................          return EOF; 
1AE2:  MOVLW  FF
1AE4:  MOVWF  01
1AE6:  BRA    1B28
....................  
....................       cur_cluster = next_cluster; 
1AE8:  MOVFF  391,38D
1AEC:  MOVFF  390,38C
1AF0:  MOVFF  38F,38B
1AF4:  MOVFF  38E,38A
....................    } 
.................... #ifdef FAT32 
....................     while(cur_cluster != 0x0FFFFFFF); 
1AF8:  MOVLB  3
1AFA:  INCFSZ x8A,W
1AFC:  BRA    1B00
1AFE:  BRA    1B04
1B00:  MOVLB  0
1B02:  BRA    1AA4
1B04:  INCFSZ x8B,W
1B06:  BRA    1B0A
1B08:  BRA    1B0E
1B0A:  MOVLB  0
1B0C:  BRA    1AA4
1B0E:  INCFSZ x8C,W
1B10:  BRA    1B14
1B12:  BRA    1B18
1B14:  MOVLB  0
1B16:  BRA    1AA4
1B18:  MOVF   x8D,W
1B1A:  SUBLW  0F
1B1C:  BTFSC  FD8.2
1B1E:  BRA    1B24
1B20:  MOVLB  0
1B22:  BRA    1AA4
.................... #else // FAT16 
....................     while(cur_cluster != 0xFFFF); 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
1B24:  MOVLW  00
1B26:  MOVWF  01
1B28:  MOVLB  0
1B2A:  GOTO   2D70 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int clear_cluster(int16 cluster) 
.................... Summary: Clears out all of the data in a given cluster. 
.................... Param: The cluster to clear out. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int clear_cluster(int32 cluster) 
.................... #else 
.................... signed int clear_cluster(int16 cluster) 
.................... #endif 
.................... { 
....................    int 
....................       clear_entry[0x20], 
....................       j; 
....................  
....................    int16 i; 
....................  
....................    int32 start_addr; 
....................  
....................    start_addr = cluster_to_addr(cluster); 
*
1D3C:  MOVFF  3AA,3D5
1D40:  MOVFF  3A9,3D4
1D44:  MOVFF  3A8,3D3
1D48:  MOVFF  3A7,3D2
1D4C:  CALL   13BE
1D50:  MOVFF  03,3D1
1D54:  MOVFF  02,3D0
1D58:  MOVFF  01,3CF
1D5C:  MOVFF  00,3CE
....................     
....................    for(j = 0; j < 0x20; j += 1) 
1D60:  MOVLB  3
1D62:  CLRF   xCB
1D64:  MOVF   xCB,W
1D66:  SUBLW  1F
1D68:  BNC   1D80
....................       clear_entry[j] = 0; 
1D6A:  CLRF   03
1D6C:  MOVF   xCB,W
1D6E:  ADDLW  AB
1D70:  MOVWF  FE9
1D72:  MOVLW  03
1D74:  ADDWFC 03,W
1D76:  MOVWF  FEA
1D78:  CLRF   FEF
1D7A:  MOVLW  01
1D7C:  ADDWF  xCB,F
1D7E:  BRA    1D64
....................  
....................    for(i = 0; i < Bytes_Per_Cluster; i += 0x20) 
1D80:  CLRF   xCD
1D82:  CLRF   xCC
1D84:  MOVF   xCD,W
1D86:  MOVLB  2
1D88:  SUBWF  x0D,W
1D8A:  BNC   1DF0
1D8C:  BNZ   1D9E
1D8E:  MOVF   x0C,W
1D90:  MOVLB  3
1D92:  SUBWF  xCC,W
1D94:  BTFSS  FD8.0
1D96:  BRA    1D9C
1D98:  MOVLB  2
1D9A:  BRA    1DF0
1D9C:  MOVLB  2
....................       if(mmcsd_write_data(start_addr + i, 0x20, clear_entry) != GOODEC) 
1D9E:  MOVLB  3
1DA0:  MOVF   xCC,W
1DA2:  ADDWF  xCE,W
1DA4:  MOVWF  xD2
1DA6:  MOVF   xCD,W
1DA8:  ADDWFC xCF,W
1DAA:  MOVWF  xD3
1DAC:  MOVLW  00
1DAE:  ADDWFC xD0,W
1DB0:  MOVWF  xD4
1DB2:  MOVLW  00
1DB4:  ADDWFC xD1,W
1DB6:  MOVWF  xD5
1DB8:  MOVWF  xD9
1DBA:  MOVFF  3D4,3D8
1DBE:  MOVFF  3D3,3D7
1DC2:  MOVFF  3D2,3D6
1DC6:  CLRF   xDB
1DC8:  MOVLW  20
1DCA:  MOVWF  xDA
1DCC:  MOVLW  03
1DCE:  MOVWF  xDD
1DD0:  MOVLW  AB
1DD2:  MOVWF  xDC
1DD4:  MOVLB  0
1DD6:  RCALL  198E
1DD8:  MOVF   01,F
1DDA:  BZ    1DE2
....................          return EOF; 
1DDC:  MOVLW  FF
1DDE:  MOVWF  01
1DE0:  BRA    1DF6
1DE2:  MOVLW  20
1DE4:  MOVLB  3
1DE6:  ADDWF  xCC,F
1DE8:  MOVLW  00
1DEA:  ADDWFC xCD,F
1DEC:  BRA    1D84
1DEE:  MOVLB  2
....................  
....................    return GOODEC; 
1DF0:  MOVLW  00
1DF2:  MOVWF  01
1DF4:  MOVLB  0
1DF6:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... Summary: Writes specified data about a cluster to the FAT. 
.................... Param cluster: The cluster to modify the in the FAT. 
.................... Param data: The data about the cluster to put into the FAT. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 2) + FAT_Start, 4, &data) != GOODEC) 
*
1A14:  MOVLB  3
1A16:  RLCF   xA7,W
1A18:  MOVWF  xB0
1A1A:  RLCF   xA8,W
1A1C:  MOVWF  xB1
1A1E:  RLCF   xA9,W
1A20:  MOVWF  xB2
1A22:  RLCF   xAA,W
1A24:  MOVWF  xB3
1A26:  RLCF   xB0,F
1A28:  RLCF   xB1,F
1A2A:  RLCF   xB2,F
1A2C:  RLCF   xB3,F
1A2E:  MOVLW  FC
1A30:  ANDWF  xB0,F
1A32:  MOVLB  2
1A34:  MOVF   x0E,W
1A36:  MOVLB  3
1A38:  ADDWF  xB0,F
1A3A:  MOVLB  2
1A3C:  MOVF   x0F,W
1A3E:  MOVLB  3
1A40:  ADDWFC xB1,F
1A42:  MOVLB  2
1A44:  MOVF   x10,W
1A46:  MOVLB  3
1A48:  ADDWFC xB2,F
1A4A:  MOVLB  2
1A4C:  MOVF   x11,W
1A4E:  MOVLB  3
1A50:  ADDWFC xB3,F
1A52:  MOVFF  3B3,3D9
1A56:  MOVFF  3B2,3D8
1A5A:  MOVFF  3B1,3D7
1A5E:  MOVFF  3B0,3D6
1A62:  CLRF   xDB
1A64:  MOVLW  04
1A66:  MOVWF  xDA
1A68:  MOVLW  03
1A6A:  MOVWF  xDD
1A6C:  MOVLW  AB
1A6E:  MOVWF  xDC
1A70:  MOVLB  0
1A72:  RCALL  198E
1A74:  MOVF   01,F
1A76:  BZ    1A7E
....................       return EOF; 
1A78:  MOVLW  FF
1A7A:  MOVWF  01
1A7C:  BRA    1A82
....................  
....................    return GOODEC; 
1A7E:  MOVLW  00
1A80:  MOVWF  01
1A82:  RETURN 0
.................... } 
.................... #else // FAT16 
.................... signed int write_fat(int16 cluster, int16 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 1) + FAT_Start, 2, &data) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
.................... #endif // #ifdef FAT32 
....................  
.................... /* 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... Summary: Reads from the buffer. 
.................... Param stream: The stream whose buffer to read from. 
.................... Param val: A pointer to a varaible to put the read data into. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... { 
....................    int i;    // counter for loops 
....................  
....................    // check to see if we need to populate the buffer 
....................    if((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
*
474C:  MOVLW  04
474E:  MOVLB  2
4750:  ADDWF  x74,W
4752:  MOVWF  FE9
4754:  MOVLW  00
4756:  ADDWFC x75,W
4758:  MOVWF  FEA
475A:  MOVFF  FEF,279
475E:  MOVFF  FEC,27A
4762:  MOVFF  FEC,27B
4766:  MOVFF  FEC,27C
476A:  MOVLW  1F
476C:  ANDWF  x79,F
476E:  CLRF   x7A
4770:  CLRF   x7B
4772:  CLRF   x7C
4774:  MOVF   x79,F
4776:  BNZ   47E6
4778:  MOVF   x7A,F
477A:  BNZ   47E6
477C:  MOVF   x7B,F
477E:  BNZ   47E6
4780:  MOVF   x7C,F
4782:  BNZ   47E6
....................    { 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
4784:  MOVLW  04
4786:  ADDWF  x74,W
4788:  MOVWF  FE9
478A:  MOVLW  00
478C:  ADDWFC x75,W
478E:  MOVWF  FEA
4790:  MOVFF  FEF,3BD
4794:  MOVFF  FEC,3BE
4798:  MOVFF  FEC,3BF
479C:  MOVFF  FEC,3C0
47A0:  MOVLW  1A
47A2:  ADDWF  x74,W
47A4:  MOVWF  01
47A6:  MOVLW  00
47A8:  ADDWFC x75,W
47AA:  MOVWF  03
47AC:  MOVFF  01,27D
47B0:  MOVWF  x7E
47B2:  MOVLB  3
47B4:  CLRF   xC2
47B6:  MOVLW  20
47B8:  MOVWF  xC1
47BA:  MOVFF  03,3C4
47BE:  MOVFF  01,3C3
47C2:  MOVLB  0
47C4:  CALL   0A80
47C8:  MOVF   01,F
47CA:  BZ    47E8
....................       { 
....................          stream->Flags |= Read_Error; 
47CC:  MOVLW  19
47CE:  MOVLB  2
47D0:  ADDWF  x74,W
47D2:  MOVWF  FE9
47D4:  MOVLW  00
47D6:  ADDWFC x75,W
47D8:  MOVWF  FEA
47DA:  MOVF   FEF,W
47DC:  IORLW  20
47DE:  MOVWF  FEF
....................          return EOF; 
47E0:  MOVLW  FF
47E2:  MOVWF  01
47E4:  BRA    484A
47E6:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // grab the value at the top of the buffer 
....................    *val = stream->Buf[0]; 
47E8:  MOVLB  2
47EA:  MOVLW  1A
47EC:  ADDWF  x74,W
47EE:  MOVWF  FE9
47F0:  MOVLW  00
47F2:  ADDWFC x75,W
47F4:  MOVWF  FEA
47F6:  MOVFF  FEF,27B
47FA:  MOVFF  277,FEA
47FE:  MOVFF  276,FE9
4802:  MOVFF  27B,FEF
....................  
....................    // shift everything over 1 byte to put a new value at the top of the buffer 
....................    for(i = 0; i < 8; i += 1) 
4806:  CLRF   x78
4808:  MOVF   x78,W
480A:  SUBLW  07
480C:  BNC   4846
....................       rotate_right(stream->Buf, STREAM_BUF_SIZE); 
480E:  MOVLW  1A
4810:  ADDWF  x74,W
4812:  MOVWF  01
4814:  MOVLW  00
4816:  ADDWFC x75,W
4818:  MOVWF  03
481A:  MOVFF  01,279
481E:  MOVWF  x7A
4820:  MOVLW  20
4822:  MOVWF  00
4824:  MOVFF  03,FEA
4828:  MOVFF  01,FE9
482C:  MOVFF  FEF,03
4830:  MOVLW  1F
4832:  ADDWF  FE9,F
4834:  MOVLW  00
4836:  ADDWFC FEA,F
4838:  RRCF   03,W
483A:  RRCF   FED,F
483C:  DECFSZ 00,F
483E:  BRA    483A
4840:  MOVLW  01
4842:  ADDWF  x78,F
4844:  BRA    4808
....................  
....................    return GOODEC; 
4846:  MOVLW  00
4848:  MOVWF  01
484A:  MOVLB  0
484C:  GOTO   48B6 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int write_buffer(FILE* stream, int val) 
.................... Summary: Writes to the buffer. 
.................... Param stream: The stream whose buffer to write to. 
.................... Param val: A variable to write to the buffer. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int write_buffer(FILE* stream, int val) 
.................... { 
....................    // check to see if we should dump the buffer to the card 
....................    if(((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................       && (stream->Cur_Char != stream->Start_Addr)) 
*
1DF8:  MOVLW  04
1DFA:  MOVLB  3
1DFC:  ADDWF  x93,W
1DFE:  MOVWF  FE9
1E00:  MOVLW  00
1E02:  ADDWFC x94,W
1E04:  MOVWF  FEA
1E06:  MOVFF  FEF,396
1E0A:  MOVFF  FEC,397
1E0E:  MOVFF  FEC,398
1E12:  MOVFF  FEC,399
1E16:  MOVLW  1F
1E18:  ANDWF  x96,F
1E1A:  CLRF   x97
1E1C:  CLRF   x98
1E1E:  CLRF   x99
1E20:  MOVF   x96,F
1E22:  BNZ   1EFA
1E24:  MOVF   x97,F
1E26:  BNZ   1EFA
1E28:  MOVF   x98,F
1E2A:  BNZ   1EFA
1E2C:  MOVF   x99,F
1E2E:  BNZ   1EFA
1E30:  MOVLW  04
1E32:  ADDWF  x93,W
1E34:  MOVWF  FE9
1E36:  MOVLW  00
1E38:  ADDWFC x94,W
1E3A:  MOVWF  FEA
1E3C:  MOVFF  FEF,396
1E40:  MOVFF  FEC,397
1E44:  MOVFF  FEC,398
1E48:  MOVFF  FEC,399
1E4C:  MOVLW  14
1E4E:  ADDWF  x93,W
1E50:  MOVWF  FE9
1E52:  MOVLW  00
1E54:  ADDWFC x94,W
1E56:  MOVWF  FEA
1E58:  MOVFF  FEF,00
1E5C:  MOVFF  FEC,01
1E60:  MOVFF  FEC,02
1E64:  MOVFF  FEC,03
1E68:  MOVF   00,W
1E6A:  SUBWF  x96,W
1E6C:  BNZ   1E80
1E6E:  MOVF   01,W
1E70:  SUBWF  x97,W
1E72:  BNZ   1E80
1E74:  MOVF   02,W
1E76:  SUBWF  x98,W
1E78:  BNZ   1E80
1E7A:  MOVF   03,W
1E7C:  SUBWF  x99,W
1E7E:  BZ    1EFA
....................    { 
....................       // dump the buffer to the card 
....................       if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
1E80:  MOVLW  04
1E82:  ADDWF  x93,W
1E84:  MOVWF  FE9
1E86:  MOVLW  00
1E88:  ADDWFC x94,W
1E8A:  MOVWF  FEA
1E8C:  MOVFF  FEF,396
1E90:  MOVFF  FEC,397
1E94:  MOVFF  FEC,398
1E98:  MOVFF  FEC,399
1E9C:  MOVLW  20
1E9E:  SUBWF  x96,F
1EA0:  MOVLW  00
1EA2:  SUBWFB x97,F
1EA4:  SUBWFB x98,F
1EA6:  SUBWFB x99,F
1EA8:  MOVLW  1A
1EAA:  ADDWF  x93,W
1EAC:  MOVWF  01
1EAE:  MOVLW  00
1EB0:  ADDWFC x94,W
1EB2:  MOVWF  03
1EB4:  MOVFF  01,39A
1EB8:  MOVWF  x9B
1EBA:  MOVFF  399,3D9
1EBE:  MOVFF  398,3D8
1EC2:  MOVFF  397,3D7
1EC6:  MOVFF  396,3D6
1ECA:  CLRF   xDB
1ECC:  MOVLW  20
1ECE:  MOVWF  xDA
1ED0:  MOVFF  03,3DD
1ED4:  MOVFF  01,3DC
1ED8:  MOVLB  0
1EDA:  RCALL  198E
1EDC:  MOVF   01,F
1EDE:  BZ    1EFC
....................       { 
....................          stream->Flags |= Write_Error; 
1EE0:  MOVLW  19
1EE2:  MOVLB  3
1EE4:  ADDWF  x93,W
1EE6:  MOVWF  FE9
1EE8:  MOVLW  00
1EEA:  ADDWFC x94,W
1EEC:  MOVWF  FEA
1EEE:  MOVF   FEF,W
1EF0:  IORLW  40
1EF2:  MOVWF  FEF
....................          return EOF; 
1EF4:  MOVLW  FF
1EF6:  MOVWF  01
1EF8:  BRA    1F4C
1EFA:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // fill up a byte on the buffer 
....................    stream->Buf[stream->Cur_Char % STREAM_BUF_SIZE] = val; 
1EFC:  MOVLW  04
1EFE:  MOVLB  3
1F00:  ADDWF  x93,W
1F02:  MOVWF  FE9
1F04:  MOVLW  00
1F06:  ADDWFC x94,W
1F08:  MOVWF  FEA
1F0A:  MOVFF  FEF,396
1F0E:  MOVFF  FEC,397
1F12:  MOVFF  FEC,398
1F16:  MOVFF  FEC,399
1F1A:  MOVLW  1F
1F1C:  ANDWF  x96,F
1F1E:  CLRF   x97
1F20:  CLRF   x98
1F22:  CLRF   x99
1F24:  MOVLW  1A
1F26:  ADDWF  x96,W
1F28:  MOVWF  00
1F2A:  MOVLW  00
1F2C:  ADDWFC x97,W
1F2E:  MOVWF  01
1F30:  MOVLW  00
1F32:  ADDWFC x98,W
1F34:  MOVLW  00
1F36:  ADDWFC x99,W
1F38:  MOVF   x93,W
1F3A:  ADDWF  00,W
1F3C:  MOVWF  FE9
1F3E:  MOVF   x94,W
1F40:  ADDWFC 01,W
1F42:  MOVWF  FEA
1F44:  MOVFF  395,FEF
....................  
....................    return GOODEC; 
1F48:  MOVLW  00
1F4A:  MOVWF  01
1F4C:  MOVLB  0
1F4E:  GOTO   23B4 (RETURN)
.................... } 
....................  
.................... /* 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... Summary: This will fill up the unused spots in a standard FAT entry with a value. 
.................... Param the_entry[]: The entry that will be modified. 
.................... Param val: The value to fill the entry with. 
.................... Param start_ind: The beginning index to start filling the_entry. 
.................... Returns: Nothing. 
.................... */ 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = start_ind; i < 13; i += 1) 
*
3AEA:  MOVFF  332,333
3AEE:  MOVLB  3
3AF0:  MOVF   x33,W
3AF2:  SUBLW  0C
3AF4:  BNC   3B84
....................    { 
....................       if(i < 5) 
3AF6:  MOVF   x33,W
3AF8:  SUBLW  04
3AFA:  BNC   3B26
....................       { 
....................          the_entry[(i << 1) + 1] = val; 
3AFC:  BCF    FD8.0
3AFE:  RLCF   x33,W
3B00:  ADDLW  01
3B02:  ADDWF  x2F,W
3B04:  MOVWF  FE9
3B06:  MOVLW  00
3B08:  ADDWFC x30,W
3B0A:  MOVWF  FEA
3B0C:  MOVFF  331,FEF
....................          the_entry[(i << 1) + 2] = val; 
3B10:  BCF    FD8.0
3B12:  RLCF   x33,W
3B14:  ADDLW  02
3B16:  ADDWF  x2F,W
3B18:  MOVWF  FE9
3B1A:  MOVLW  00
3B1C:  ADDWFC x30,W
3B1E:  MOVWF  FEA
3B20:  MOVFF  331,FEF
....................       } 
3B24:  BRA    3B7E
....................  
....................       else if(i < 11) 
3B26:  MOVF   x33,W
3B28:  SUBLW  0A
3B2A:  BNC   3B56
....................       { 
....................          the_entry[(i << 1) + 4] = val; 
3B2C:  BCF    FD8.0
3B2E:  RLCF   x33,W
3B30:  ADDLW  04
3B32:  ADDWF  x2F,W
3B34:  MOVWF  FE9
3B36:  MOVLW  00
3B38:  ADDWFC x30,W
3B3A:  MOVWF  FEA
3B3C:  MOVFF  331,FEF
....................          the_entry[(i << 1) + 5] = val; 
3B40:  BCF    FD8.0
3B42:  RLCF   x33,W
3B44:  ADDLW  05
3B46:  ADDWF  x2F,W
3B48:  MOVWF  FE9
3B4A:  MOVLW  00
3B4C:  ADDWFC x30,W
3B4E:  MOVWF  FEA
3B50:  MOVFF  331,FEF
....................       } 
3B54:  BRA    3B7E
....................  
....................       else 
....................       { 
....................          the_entry[(i << 1) + 6] = val; 
3B56:  BCF    FD8.0
3B58:  RLCF   x33,W
3B5A:  ADDLW  06
3B5C:  ADDWF  x2F,W
3B5E:  MOVWF  FE9
3B60:  MOVLW  00
3B62:  ADDWFC x30,W
3B64:  MOVWF  FEA
3B66:  MOVFF  331,FEF
....................          the_entry[(i << 1) + 7] = val; 
3B6A:  BCF    FD8.0
3B6C:  RLCF   x33,W
3B6E:  ADDLW  07
3B70:  ADDWF  x2F,W
3B72:  MOVWF  FE9
3B74:  MOVLW  00
3B76:  ADDWFC x30,W
3B78:  MOVWF  FEA
3B7A:  MOVFF  331,FEF
....................       } 
3B7E:  MOVLW  01
3B80:  ADDWF  x33,F
3B82:  BRA    3AF0
....................    } 
3B84:  MOVLB  0
3B86:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void disp_timestamp(int16 timestamp) 
.................... Summary: Parses an timestamp from a file entry and displays it to the console 
.................... Param: The 16-bit timestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_timestamp(int16 timestamp) 
.................... { 
....................    // Hours:Minutes:Seconds 
....................    printf("%lu:%lu:%lu", 
....................       timestamp >> 11, 
....................       (timestamp & 0x07E0) >> 5, 
....................       (timestamp & 0x001F) << 1); 
.................... } 
....................  
.................... /* 
.................... void disp_datestamp(int16 datestamp) 
.................... Summary: Parses an datestamp from a file entry and displays it to the console 
.................... Param: The 16-bit datestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_datestamp(int16 datestamp) 
.................... { 
....................    // Month/Day/Year 
....................    printf("%lu/%lu/%lu", 
....................       (datestamp & 0x01F0) >> 5, 
....................       datestamp & 0x001F, 
....................       (1980 + (datestamp >> 9))); 
.................... } 
....................  
.................... /// Data Utility Functions /// 
....................  
.................... /* 
.................... signed int fat_init() 
.................... Summary: Initializes global variables that are essential for this library working 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: This must be called before any other function calls in this library. 
.................... */ 
.................... signed int fat_init() 
*
0B88:  MOVLB  2
0B8A:  CLRF   x61
.................... { 
....................    int ec = 0; 
....................  
....................    int 
....................       FATs, 
....................       Sectors_Per_Cluster; 
....................  
....................    int16 
....................       Bytes_Per_Sector, 
....................       Reserved_Sectors, 
....................       Small_Sectors; 
....................  
....................    int32 
....................       Hidden_Sectors, 
....................       Large_Sectors; 
....................  
.................... #ifdef FAT32 
....................    int32 Sectors_Per_FAT; 
.................... #else // FAT16 
....................    int16 
....................       Root_Entries, 
....................       Sectors_Per_FAT; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize the media 
....................    if(mmcsd_init() != GOODEC) 
0B8C:  MOVLB  0
0B8E:  BRA    06D8
0B90:  MOVF   01,F
0B92:  BZ    0B9A
....................        return EOF; 
0B94:  MOVLW  FF
0B96:  MOVWF  01
0B98:  BRA    0FB0
....................  
....................    // assume first sector is MBR 
....................    uint8_t  boot; 
....................    uint32_t offset_, total_sectors, first_sector; 
....................    ec += mmcsd_read_data(0x1BE, 1, &boot); 
0B9A:  MOVLB  3
0B9C:  CLRF   xC0
0B9E:  CLRF   xBF
0BA0:  MOVLW  01
0BA2:  MOVWF  xBE
0BA4:  MOVLW  BE
0BA6:  MOVWF  xBD
0BA8:  CLRF   xC2
0BAA:  MOVLW  01
0BAC:  MOVWF  xC1
0BAE:  MOVLW  02
0BB0:  MOVWF  xC4
0BB2:  MOVLW  76
0BB4:  MOVWF  xC3
0BB6:  MOVLB  0
0BB8:  RCALL  0A80
0BBA:  MOVF   01,W
0BBC:  MOVLB  2
0BBE:  ADDWF  x61,F
....................    ec += mmcsd_read_data(0x1C6, 4, &first_sector); 
0BC0:  MOVLB  3
0BC2:  CLRF   xC0
0BC4:  CLRF   xBF
0BC6:  MOVLW  01
0BC8:  MOVWF  xBE
0BCA:  MOVLW  C6
0BCC:  MOVWF  xBD
0BCE:  CLRF   xC2
0BD0:  MOVLW  04
0BD2:  MOVWF  xC1
0BD4:  MOVLW  02
0BD6:  MOVWF  xC4
0BD8:  MOVLW  7F
0BDA:  MOVWF  xC3
0BDC:  MOVLB  0
0BDE:  RCALL  0A80
0BE0:  MOVF   01,W
0BE2:  MOVLB  2
0BE4:  ADDWF  x61,F
....................    ec += mmcsd_read_data(0x1CA, 4, &total_sectors); 
0BE6:  MOVLB  3
0BE8:  CLRF   xC0
0BEA:  CLRF   xBF
0BEC:  MOVLW  01
0BEE:  MOVWF  xBE
0BF0:  MOVLW  CA
0BF2:  MOVWF  xBD
0BF4:  CLRF   xC2
0BF6:  MOVLW  04
0BF8:  MOVWF  xC1
0BFA:  MOVLW  02
0BFC:  MOVWF  xC4
0BFE:  MOVLW  7B
0C00:  MOVWF  xC3
0C02:  MOVLB  0
0C04:  RCALL  0A80
0C06:  MOVF   01,W
0C08:  MOVLB  2
0C0A:  ADDWF  x61,F
....................    if( (boot & 0X7F) !=0  || (total_sectors < 100) || (first_sector == 0) ) 
0C0C:  MOVF   x76,W
0C0E:  ANDLW  7F
0C10:  BNZ   0C34
0C12:  MOVF   x7E,F
0C14:  BNZ   0C24
0C16:  MOVF   x7D,F
0C18:  BNZ   0C24
0C1A:  MOVF   x7C,F
0C1C:  BNZ   0C24
0C1E:  MOVF   x7B,W
0C20:  SUBLW  63
0C22:  BC    0C34
0C24:  MOVF   x7F,F
0C26:  BNZ   0C3E
0C28:  MOVF   x80,F
0C2A:  BNZ   0C3E
0C2C:  MOVF   x81,F
0C2E:  BNZ   0C3E
0C30:  MOVF   x82,F
0C32:  BNZ   0C3E
....................      offset_ = 0; 
0C34:  CLRF   x7A
0C36:  CLRF   x79
0C38:  CLRF   x78
0C3A:  CLRF   x77
0C3C:  BRA    0C4E
....................    else 
....................      offset_ = first_sector * MMCSD_MAX_BLOCK_SIZE; 
0C3E:  BCF    FD8.0
0C40:  CLRF   x77
0C42:  RLCF   x7F,W
0C44:  MOVWF  x78
0C46:  RLCF   x80,W
0C48:  MOVWF  x79
0C4A:  RLCF   x81,W
0C4C:  MOVWF  x7A
....................  
....................    // start filling up variables 
....................    ec += mmcsd_read_data(offset_ + 11, 2, &Bytes_Per_Sector); 
0C4E:  MOVLW  0B
0C50:  ADDWF  x77,W
0C52:  MOVWF  x83
0C54:  MOVLW  00
0C56:  ADDWFC x78,W
0C58:  MOVWF  x84
0C5A:  MOVLW  00
0C5C:  ADDWFC x79,W
0C5E:  MOVWF  x85
0C60:  MOVLW  00
0C62:  ADDWFC x7A,W
0C64:  MOVWF  x86
0C66:  MOVFF  FE8,3C0
0C6A:  MOVFF  285,3BF
0C6E:  MOVFF  284,3BE
0C72:  MOVFF  283,3BD
0C76:  MOVLB  3
0C78:  CLRF   xC2
0C7A:  MOVLW  02
0C7C:  MOVWF  xC1
0C7E:  MOVWF  xC4
0C80:  MOVLW  64
0C82:  MOVWF  xC3
0C84:  MOVLB  0
0C86:  RCALL  0A80
0C88:  MOVF   01,W
0C8A:  MOVLB  2
0C8C:  ADDWF  x61,F
....................    ec += mmcsd_read_data(offset_ + 13, 1, &Sectors_Per_Cluster); 
0C8E:  MOVLW  0D
0C90:  ADDWF  x77,W
0C92:  MOVWF  x83
0C94:  MOVLW  00
0C96:  ADDWFC x78,W
0C98:  MOVWF  x84
0C9A:  MOVLW  00
0C9C:  ADDWFC x79,W
0C9E:  MOVWF  x85
0CA0:  MOVLW  00
0CA2:  ADDWFC x7A,W
0CA4:  MOVWF  x86
0CA6:  MOVFF  FE8,3C0
0CAA:  MOVFF  285,3BF
0CAE:  MOVFF  284,3BE
0CB2:  MOVFF  283,3BD
0CB6:  MOVLB  3
0CB8:  CLRF   xC2
0CBA:  MOVLW  01
0CBC:  MOVWF  xC1
0CBE:  MOVLW  02
0CC0:  MOVWF  xC4
0CC2:  MOVLW  63
0CC4:  MOVWF  xC3
0CC6:  MOVLB  0
0CC8:  RCALL  0A80
0CCA:  MOVF   01,W
0CCC:  MOVLB  2
0CCE:  ADDWF  x61,F
....................    ec += mmcsd_read_data(offset_ + 14, 2, &Reserved_Sectors); 
0CD0:  MOVLW  0E
0CD2:  ADDWF  x77,W
0CD4:  MOVWF  x83
0CD6:  MOVLW  00
0CD8:  ADDWFC x78,W
0CDA:  MOVWF  x84
0CDC:  MOVLW  00
0CDE:  ADDWFC x79,W
0CE0:  MOVWF  x85
0CE2:  MOVLW  00
0CE4:  ADDWFC x7A,W
0CE6:  MOVWF  x86
0CE8:  MOVFF  FE8,3C0
0CEC:  MOVFF  285,3BF
0CF0:  MOVFF  284,3BE
0CF4:  MOVFF  283,3BD
0CF8:  MOVLB  3
0CFA:  CLRF   xC2
0CFC:  MOVLW  02
0CFE:  MOVWF  xC1
0D00:  MOVWF  xC4
0D02:  MOVLW  66
0D04:  MOVWF  xC3
0D06:  MOVLB  0
0D08:  RCALL  0A80
0D0A:  MOVF   01,W
0D0C:  MOVLB  2
0D0E:  ADDWF  x61,F
....................    ec += mmcsd_read_data(offset_ + 16, 1, &FATs); 
0D10:  MOVLW  10
0D12:  ADDWF  x77,W
0D14:  MOVWF  x83
0D16:  MOVLW  00
0D18:  ADDWFC x78,W
0D1A:  MOVWF  x84
0D1C:  MOVLW  00
0D1E:  ADDWFC x79,W
0D20:  MOVWF  x85
0D22:  MOVLW  00
0D24:  ADDWFC x7A,W
0D26:  MOVWF  x86
0D28:  MOVFF  FE8,3C0
0D2C:  MOVFF  285,3BF
0D30:  MOVFF  284,3BE
0D34:  MOVFF  283,3BD
0D38:  MOVLB  3
0D3A:  CLRF   xC2
0D3C:  MOVLW  01
0D3E:  MOVWF  xC1
0D40:  MOVLW  02
0D42:  MOVWF  xC4
0D44:  MOVLW  62
0D46:  MOVWF  xC3
0D48:  MOVLB  0
0D4A:  RCALL  0A80
0D4C:  MOVF   01,W
0D4E:  MOVLB  2
0D50:  ADDWF  x61,F
.................... #ifdef FAT16 
....................    ec += mmcsd_read_data(offset_ + 17, 2, &Root_Entries); 
.................... #endif // #ifdef FAT16 
....................    ec += mmcsd_read_data(offset_ + 19, 2, &Small_Sectors); 
0D52:  MOVLW  13
0D54:  ADDWF  x77,W
0D56:  MOVWF  x83
0D58:  MOVLW  00
0D5A:  ADDWFC x78,W
0D5C:  MOVWF  x84
0D5E:  MOVLW  00
0D60:  ADDWFC x79,W
0D62:  MOVWF  x85
0D64:  MOVLW  00
0D66:  ADDWFC x7A,W
0D68:  MOVWF  x86
0D6A:  MOVFF  FE8,3C0
0D6E:  MOVFF  285,3BF
0D72:  MOVFF  284,3BE
0D76:  MOVFF  283,3BD
0D7A:  MOVLB  3
0D7C:  CLRF   xC2
0D7E:  MOVLW  02
0D80:  MOVWF  xC1
0D82:  MOVWF  xC4
0D84:  MOVLW  68
0D86:  MOVWF  xC3
0D88:  MOVLB  0
0D8A:  RCALL  0A80
0D8C:  MOVF   01,W
0D8E:  MOVLB  2
0D90:  ADDWF  x61,F
.................... #ifdef FAT32 
....................    ec += mmcsd_read_data(offset_ + 36, 4, &Sectors_Per_FAT); 
0D92:  MOVLW  24
0D94:  ADDWF  x77,W
0D96:  MOVWF  x83
0D98:  MOVLW  00
0D9A:  ADDWFC x78,W
0D9C:  MOVWF  x84
0D9E:  MOVLW  00
0DA0:  ADDWFC x79,W
0DA2:  MOVWF  x85
0DA4:  MOVLW  00
0DA6:  ADDWFC x7A,W
0DA8:  MOVWF  x86
0DAA:  MOVFF  FE8,3C0
0DAE:  MOVFF  285,3BF
0DB2:  MOVFF  284,3BE
0DB6:  MOVFF  283,3BD
0DBA:  MOVLB  3
0DBC:  CLRF   xC2
0DBE:  MOVLW  04
0DC0:  MOVWF  xC1
0DC2:  MOVLW  02
0DC4:  MOVWF  xC4
0DC6:  MOVLW  72
0DC8:  MOVWF  xC3
0DCA:  MOVLB  0
0DCC:  RCALL  0A80
0DCE:  MOVF   01,W
0DD0:  MOVLB  2
0DD2:  ADDWF  x61,F
.................... #else // FAT16 
....................    ec += mmcsd_read_data(offset_ + 22, 2, &Sectors_Per_FAT); 
.................... #endif // #ifdef FAT32 
....................    ec += mmcsd_read_data(offset_ + 28, 4, &Hidden_Sectors); 
0DD4:  MOVLW  1C
0DD6:  ADDWF  x77,W
0DD8:  MOVWF  x83
0DDA:  MOVLW  00
0DDC:  ADDWFC x78,W
0DDE:  MOVWF  x84
0DE0:  MOVLW  00
0DE2:  ADDWFC x79,W
0DE4:  MOVWF  x85
0DE6:  MOVLW  00
0DE8:  ADDWFC x7A,W
0DEA:  MOVWF  x86
0DEC:  MOVFF  FE8,3C0
0DF0:  MOVFF  285,3BF
0DF4:  MOVFF  284,3BE
0DF8:  MOVFF  283,3BD
0DFC:  MOVLB  3
0DFE:  CLRF   xC2
0E00:  MOVLW  04
0E02:  MOVWF  xC1
0E04:  MOVLW  02
0E06:  MOVWF  xC4
0E08:  MOVLW  6A
0E0A:  MOVWF  xC3
0E0C:  MOVLB  0
0E0E:  RCALL  0A80
0E10:  MOVF   01,W
0E12:  MOVLB  2
0E14:  ADDWF  x61,F
....................    ec += mmcsd_read_data(offset_ + 32, 4, &Large_Sectors); 
0E16:  MOVLW  20
0E18:  ADDWF  x77,W
0E1A:  MOVWF  x83
0E1C:  MOVLW  00
0E1E:  ADDWFC x78,W
0E20:  MOVWF  x84
0E22:  MOVLW  00
0E24:  ADDWFC x79,W
0E26:  MOVWF  x85
0E28:  MOVLW  00
0E2A:  ADDWFC x7A,W
0E2C:  MOVWF  x86
0E2E:  MOVFF  FE8,3C0
0E32:  MOVFF  285,3BF
0E36:  MOVFF  284,3BE
0E3A:  MOVFF  283,3BD
0E3E:  MOVLB  3
0E40:  CLRF   xC2
0E42:  MOVLW  04
0E44:  MOVWF  xC1
0E46:  MOVLW  02
0E48:  MOVWF  xC4
0E4A:  MOVLW  6E
0E4C:  MOVWF  xC3
0E4E:  MOVLB  0
0E50:  RCALL  0A80
0E52:  MOVF   01,W
0E54:  MOVLB  2
0E56:  ADDWF  x61,F
.................... #ifdef FAT16 
....................    Next_Free_Clust = 2; 
.................... #else 
....................    ec += mmcsd_read_data(offset_ + 0x3EC, 4, &Next_Free_Clust); 
0E58:  MOVLW  EC
0E5A:  ADDWF  x77,W
0E5C:  MOVWF  x83
0E5E:  MOVLW  03
0E60:  ADDWFC x78,W
0E62:  MOVWF  x84
0E64:  MOVLW  00
0E66:  ADDWFC x79,W
0E68:  MOVWF  x85
0E6A:  MOVLW  00
0E6C:  ADDWFC x7A,W
0E6E:  MOVWF  x86
0E70:  MOVFF  FE8,3C0
0E74:  MOVFF  285,3BF
0E78:  MOVFF  284,3BE
0E7C:  MOVFF  283,3BD
0E80:  MOVLB  3
0E82:  CLRF   xC2
0E84:  MOVLW  04
0E86:  MOVWF  xC1
0E88:  MOVLW  02
0E8A:  MOVWF  xC4
0E8C:  MOVLW  1A
0E8E:  MOVWF  xC3
0E90:  MOVLB  0
0E92:  RCALL  0A80
0E94:  MOVF   01,W
0E96:  MOVLB  2
0E98:  ADDWF  x61,F
.................... #endif 
....................    if(ec != GOODEC) 
0E9A:  MOVF   x61,F
0E9C:  BZ    0EA8
....................       return EOF; 
0E9E:  MOVLW  FF
0EA0:  MOVWF  01
0EA2:  MOVLB  0
0EA4:  BRA    0FB0
0EA6:  MOVLB  2
....................  
....................    // figure out the size of a cluster 
....................    Bytes_Per_Cluster = Sectors_Per_Cluster * Bytes_Per_Sector; 
0EA8:  CLRF   x84
0EAA:  MOVFF  263,283
0EAE:  MOVFF  265,286
0EB2:  MOVFF  264,285
0EB6:  MOVLB  0
0EB8:  BRA    0B08
0EBA:  MOVFF  02,20D
0EBE:  MOVFF  01,20C
....................  
....................    // figure out how long one FAT is 
....................    FAT_Length = Sectors_Per_FAT * (int32)Bytes_Per_Sector; 
0EC2:  MOVFF  264,00
0EC6:  MOVFF  265,01
0ECA:  CLRF   02
0ECC:  CLRF   03
0ECE:  MOVFF  03,286
0ED2:  MOVFF  02,285
0ED6:  MOVFF  265,284
0EDA:  MOVFF  264,283
0EDE:  MOVFF  275,3DD
0EE2:  MOVFF  274,3DC
0EE6:  MOVFF  273,3DB
0EEA:  MOVFF  272,3DA
0EEE:  MOVFF  03,3E1
0EF2:  MOVFF  02,3E0
0EF6:  MOVFF  265,3DF
0EFA:  MOVFF  264,3DE
0EFE:  RCALL  0B2C
0F00:  MOVFF  03,219
0F04:  MOVFF  02,218
0F08:  MOVFF  01,217
0F0C:  MOVFF  00,216
....................  
....................    // figure out where the FAT starts 
....................    FAT_Start = offset_ + (int32)Reserved_Sectors * Bytes_Per_Sector; 
0F10:  MOVLB  2
0F12:  CLRF   x86
0F14:  CLRF   x85
0F16:  MOVFF  267,284
0F1A:  MOVFF  266,283
0F1E:  MOVFF  286,3DD
0F22:  MOVFF  285,3DC
0F26:  MOVFF  267,3DB
0F2A:  MOVFF  266,3DA
0F2E:  MOVLB  3
0F30:  CLRF   xE1
0F32:  CLRF   xE0
0F34:  MOVFF  265,3DF
0F38:  MOVFF  264,3DE
0F3C:  MOVLB  0
0F3E:  RCALL  0B2C
0F40:  MOVF   00,W
0F42:  MOVLB  2
0F44:  ADDWF  x77,W
0F46:  MOVWF  x0E
0F48:  MOVF   01,W
0F4A:  ADDWFC x78,W
0F4C:  MOVWF  x0F
0F4E:  MOVF   02,W
0F50:  ADDWFC x79,W
0F52:  MOVWF  x10
0F54:  MOVF   03,W
0F56:  ADDWFC x7A,W
0F58:  MOVWF  x11
....................  
....................    // figure out where the root directory starts 
....................    Root_Dir = FAT_Start + (FATs * FAT_Length); 
0F5A:  MOVLB  3
0F5C:  CLRF   xDD
0F5E:  CLRF   xDC
0F60:  CLRF   xDB
0F62:  MOVFF  262,3DA
0F66:  MOVFF  219,3E1
0F6A:  MOVFF  218,3E0
0F6E:  MOVFF  217,3DF
0F72:  MOVFF  216,3DE
0F76:  MOVLB  0
0F78:  RCALL  0B2C
0F7A:  MOVF   00,W
0F7C:  MOVLB  2
0F7E:  ADDWF  x0E,W
0F80:  MOVWF  x1E
0F82:  MOVF   01,W
0F84:  ADDWFC x0F,W
0F86:  MOVWF  x1F
0F88:  MOVF   02,W
0F8A:  ADDWFC x10,W
0F8C:  MOVWF  x20
0F8E:  MOVF   03,W
0F90:  ADDWFC x11,W
0F92:  MOVWF  x21
....................  
....................    // figure out where data for files in the root directory starts 
.................... #ifdef FAT32 
....................    Data_Start = Bytes_Per_Cluster + Root_Dir; 
0F94:  MOVF   x0C,W
0F96:  ADDWF  x1E,W
0F98:  MOVWF  x12
0F9A:  MOVF   x0D,W
0F9C:  ADDWFC x1F,W
0F9E:  MOVWF  x13
0FA0:  MOVLW  00
0FA2:  ADDWFC x20,W
0FA4:  MOVWF  x14
0FA6:  MOVLW  00
0FA8:  ADDWFC x21,W
0FAA:  MOVWF  x15
.................... #else // FAT16 
....................    Data_Start = offset_ + (Root_Entries * 0x20) + (Bytes_Per_Sector - 1); 
....................    Data_Start /= Bytes_Per_Sector; 
....................    Data_Start += Reserved_Sectors + (FATs * Sectors_Per_FAT); 
....................    Data_Start *= Bytes_Per_Sector; 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
0FAC:  MOVLW  00
0FAE:  MOVWF  01
0FB0:  MOVLB  0
0FB2:  GOTO   0FD0 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... Summary: Gets the next linked cluster from the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the next linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
....................    // convert the current cluster into the address of where information about 
....................    //  the cluster is stored in the FAT, and put this value into the current cluster 
.................... #ifdef FAT32 
....................    if(mmcsd_read_data((*my_cluster << 2) + FAT_Start, 4, my_cluster) != GOODEC) 
*
18BA:  MOVFF  39C,03
18BE:  MOVLB  3
18C0:  MOVFF  39B,FE9
18C4:  MOVFF  39C,FEA
18C8:  MOVFF  FEF,39D
18CC:  MOVFF  FEC,39E
18D0:  MOVFF  FEC,39F
18D4:  MOVFF  FEC,3A0
18D8:  RLCF   x9D,F
18DA:  RLCF   x9E,F
18DC:  RLCF   x9F,F
18DE:  RLCF   xA0,F
18E0:  RLCF   x9D,F
18E2:  RLCF   x9E,F
18E4:  RLCF   x9F,F
18E6:  RLCF   xA0,F
18E8:  MOVLW  FC
18EA:  ANDWF  x9D,F
18EC:  MOVLB  2
18EE:  MOVF   x0E,W
18F0:  MOVLB  3
18F2:  ADDWF  x9D,F
18F4:  MOVLB  2
18F6:  MOVF   x0F,W
18F8:  MOVLB  3
18FA:  ADDWFC x9E,F
18FC:  MOVLB  2
18FE:  MOVF   x10,W
1900:  MOVLB  3
1902:  ADDWFC x9F,F
1904:  MOVLB  2
1906:  MOVF   x11,W
1908:  MOVLB  3
190A:  ADDWFC xA0,F
190C:  MOVFF  3A0,3C0
1910:  MOVFF  39F,3BF
1914:  MOVFF  39E,3BE
1918:  MOVFF  39D,3BD
191C:  CLRF   xC2
191E:  MOVLW  04
1920:  MOVWF  xC1
1922:  MOVFF  39C,3C4
1926:  MOVFF  39B,3C3
192A:  MOVLB  0
192C:  CALL   0A80
1930:  MOVF   01,F
1932:  BZ    193A
....................       return EOF; 
1934:  MOVLW  FF
1936:  MOVWF  01
1938:  BRA    193E
.................... #else // FAT16 
....................    if(mmcsd_read_data((*my_cluster << 1) + FAT_Start, 2, my_cluster) != GOODEC) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................    return GOODEC; 
193A:  MOVLW  00
193C:  MOVWF  01
193E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... Summary: Gets the previously linked cluster in the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the previous linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... #else 
*
12DE:  MOVLB  3
12E0:  CLRF   xA1
12E2:  CLRF   xA0
12E4:  CLRF   x9F
12E6:  MOVLW  01
12E8:  MOVWF  x9E
12EA:  CLRF   xA5
12EC:  CLRF   xA4
12EE:  CLRF   xA3
12F0:  CLRF   xA2
.................... signed int get_prev_cluster(int16* my_cluster) 
.................... #endif // #ifdef FAT32 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #else 
....................    int16 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #endif // #ifdef FAT32 
....................     
....................    while(target_cluster != *my_cluster) 
12F2:  MOVFF  39C,FE9
12F6:  MOVFF  39D,FEA
12FA:  MOVFF  FEF,00
12FE:  MOVFF  FEC,01
1302:  MOVFF  FEC,02
1306:  MOVFF  FEC,03
130A:  MOVF   00,W
130C:  SUBWF  xA2,W
130E:  BNZ   1322
1310:  MOVF   01,W
1312:  SUBWF  xA3,W
1314:  BNZ   1322
1316:  MOVF   02,W
1318:  SUBWF  xA4,W
131A:  BNZ   1322
131C:  MOVF   03,W
131E:  SUBWF  xA5,W
1320:  BZ    139C
....................    {    
....................       cur_cluster += 1; 
1322:  MOVLW  01
1324:  ADDWF  x9E,F
1326:  MOVLW  00
1328:  ADDWFC x9F,F
132A:  ADDWFC xA0,F
132C:  ADDWFC xA1,F
.................... #ifdef FAT32 
....................       if(mmcsd_read_data((cur_cluster << 2) + FAT_Start, 4, &target_cluster) != GOODEC) 
132E:  RLCF   x9E,W
1330:  MOVWF  xA7
1332:  RLCF   x9F,W
1334:  MOVWF  xA8
1336:  RLCF   xA0,W
1338:  MOVWF  xA9
133A:  RLCF   xA1,W
133C:  MOVWF  xAA
133E:  RLCF   xA7,F
1340:  RLCF   xA8,F
1342:  RLCF   xA9,F
1344:  RLCF   xAA,F
1346:  MOVLW  FC
1348:  ANDWF  xA7,F
134A:  MOVLB  2
134C:  MOVF   x0E,W
134E:  MOVLB  3
1350:  ADDWF  xA7,F
1352:  MOVLB  2
1354:  MOVF   x0F,W
1356:  MOVLB  3
1358:  ADDWFC xA8,F
135A:  MOVLB  2
135C:  MOVF   x10,W
135E:  MOVLB  3
1360:  ADDWFC xA9,F
1362:  MOVLB  2
1364:  MOVF   x11,W
1366:  MOVLB  3
1368:  ADDWFC xAA,F
136A:  MOVFF  3AA,3C0
136E:  MOVFF  3A9,3BF
1372:  MOVFF  3A8,3BE
1376:  MOVFF  3A7,3BD
137A:  CLRF   xC2
137C:  MOVLW  04
137E:  MOVWF  xC1
1380:  MOVLW  03
1382:  MOVWF  xC4
1384:  MOVLW  A2
1386:  MOVWF  xC3
1388:  MOVLB  0
138A:  CALL   0A80
138E:  MOVF   01,F
1390:  BZ    1398
....................          return EOF; 
1392:  MOVLW  FF
1394:  MOVWF  01
1396:  BRA    13B8
.................... #else // FAT16 
1398:  MOVLB  3
139A:  BRA    12F2
....................       if(mmcsd_read_data((cur_cluster << 1) + FAT_Start, 2, &target_cluster) != GOODEC) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................    } 
....................     
.................... #ifdef FAT32 
....................    *my_cluster = cur_cluster;                         
139C:  MOVFF  39C,FE9
13A0:  MOVFF  39D,FEA
13A4:  MOVFF  39E,FEF
13A8:  MOVFF  39F,FEC
13AC:  MOVFF  3A0,FEC
13B0:  MOVFF  3A1,FEC
.................... #else // FAT16 
....................    *my_cluster = cur_cluster; 
.................... #endif // #ifdef FAT32    
....................     
....................    return GOODEC; 
13B4:  MOVLW  00
13B6:  MOVWF  01
13B8:  MOVLB  0
13BA:  GOTO   15A6 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... //#ifdef FAT32 
.................... //   if((*my_addr + 1) % Bytes_Per_Cluster == 0) 
.................... //#else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if((((*my_addr + 1) - Data_Start) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
*
1F52:  MOVFF  396,03
1F56:  MOVLB  3
1F58:  MOVFF  395,FE9
1F5C:  MOVFF  396,FEA
1F60:  MOVFF  FEF,39B
1F64:  MOVFF  FEC,39C
1F68:  MOVFF  FEC,39D
1F6C:  MOVFF  FEC,39E
1F70:  MOVLW  01
1F72:  ADDWF  x9B,F
1F74:  MOVLW  00
1F76:  ADDWFC x9C,F
1F78:  ADDWFC x9D,F
1F7A:  ADDWFC x9E,F
1F7C:  MOVLB  2
1F7E:  MOVF   x12,W
1F80:  MOVLB  3
1F82:  SUBWF  x9B,F
1F84:  MOVLB  2
1F86:  MOVF   x13,W
1F88:  MOVLB  3
1F8A:  SUBWFB x9C,F
1F8C:  MOVLB  2
1F8E:  MOVF   x14,W
1F90:  MOVLB  3
1F92:  SUBWFB x9D,F
1F94:  MOVLB  2
1F96:  MOVF   x15,W
1F98:  MOVLB  3
1F9A:  SUBWFB x9E,F
1F9C:  MOVFF  FEA,3A0
1FA0:  MOVFF  FE9,39F
1FA4:  BSF    FD8.1
1FA6:  MOVLW  03
1FA8:  MOVWF  FEA
1FAA:  MOVLW  A1
1FAC:  MOVWF  FE9
1FAE:  MOVFF  39E,3AB
1FB2:  MOVFF  39D,3AA
1FB6:  MOVFF  39C,3A9
1FBA:  MOVFF  39B,3A8
1FBE:  CLRF   xAF
1FC0:  CLRF   xAE
1FC2:  MOVFF  20D,3AD
1FC6:  MOVFF  20C,3AC
1FCA:  MOVLB  0
1FCC:  CALL   11D4
1FD0:  MOVFF  3A1,00
1FD4:  MOVFF  3A2,01
1FD8:  MOVFF  3A3,02
1FDC:  MOVFF  3A4,03
1FE0:  MOVFF  3A0,FEA
1FE4:  MOVFF  39F,FE9
1FE8:  MOVFF  3A4,39E
1FEC:  MOVFF  3A3,39D
1FF0:  MOVFF  3A2,39C
1FF4:  MOVFF  3A1,39B
1FF8:  MOVLB  3
1FFA:  MOVF   x9B,F
1FFC:  BTFSS  FD8.2
1FFE:  BRA    211A
2000:  MOVF   x9C,F
2002:  BTFSS  FD8.2
2004:  BRA    211A
2006:  MOVF   x9D,F
2008:  BTFSS  FD8.2
200A:  BRA    211A
200C:  MOVF   x9E,F
200E:  BTFSS  FD8.2
2010:  BRA    211A
2012:  MOVFF  396,03
2016:  MOVFF  395,FE9
201A:  MOVFF  396,FEA
201E:  MOVFF  FEF,39B
2022:  MOVFF  FEC,39C
2026:  MOVFF  FEC,39D
202A:  MOVFF  FEC,39E
202E:  MOVLB  2
2030:  MOVF   x15,W
2032:  MOVLB  3
2034:  SUBWF  x9E,W
2036:  BTFSS  FD8.0
2038:  BRA    211A
203A:  BNZ   2060
203C:  MOVLB  2
203E:  MOVF   x14,W
2040:  MOVLB  3
2042:  SUBWF  x9D,W
2044:  BTFSS  FD8.0
2046:  BRA    211A
2048:  BNZ   2060
204A:  MOVLB  2
204C:  MOVF   x13,W
204E:  MOVLB  3
2050:  SUBWF  x9C,W
2052:  BNC   211A
2054:  BNZ   2060
2056:  MOVLB  2
2058:  MOVF   x12,W
205A:  MOVLB  3
205C:  SUBWF  x9B,W
205E:  BNC   211A
.................... //#endif // #ifdef FAT32 
....................    { 
....................       // convert the current address into the address of where information about 
....................       //  the address is stored in the FAT, and put this value into the current address 
....................       temp = addr_to_cluster(*my_addr); 
2060:  MOVFF  396,03
2064:  MOVFF  395,FE9
2068:  MOVFF  396,FEA
206C:  MOVFF  FEF,3A0
2070:  MOVFF  FEC,3A1
2074:  MOVFF  FEC,3A2
2078:  MOVFF  FEC,3A3
207C:  MOVLB  0
207E:  CALL   1268
2082:  MOVFF  03,39A
2086:  MOVFF  02,399
208A:  MOVFF  01,398
208E:  MOVFF  00,397
....................       if(get_next_cluster(&temp) == EOF) 
2092:  MOVLW  03
2094:  MOVLB  3
2096:  MOVWF  x9C
2098:  MOVLW  97
209A:  MOVWF  x9B
209C:  MOVLB  0
209E:  RCALL  18BA
20A0:  MOVF   01,W
20A2:  SUBLW  FF
20A4:  BNZ   20AC
....................          return EOF; 
20A6:  MOVLW  FF
20A8:  MOVWF  01
20AA:  BRA    2154
.................... #ifdef FAT32 
....................       if((temp == 0xFFFFFFFF) 
....................          || (temp == 0x0FFFFFFF)) // WinXP will format the root directory's FAT entry to 0x0FFFFFFF. 
20AC:  MOVLB  3
20AE:  INCFSZ x97,W
20B0:  BRA    20C0
20B2:  INCFSZ x98,W
20B4:  BRA    20C0
20B6:  INCFSZ x99,W
20B8:  BRA    20C0
20BA:  INCFSZ x9A,W
20BC:  BRA    20C0
20BE:  BRA    20D2
20C0:  INCFSZ x97,W
20C2:  BRA    20DC
20C4:  INCFSZ x98,W
20C6:  BRA    20DC
20C8:  INCFSZ x99,W
20CA:  BRA    20DC
20CC:  MOVF   x9A,W
20CE:  SUBLW  0F
20D0:  BNZ   20DC
....................          return EOF; 
20D2:  MOVLW  FF
20D4:  MOVWF  01
20D6:  MOVLB  0
20D8:  BRA    2154
20DA:  MOVLB  3
.................... #else // FAT16 
....................       if(temp == 0xFFFF) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................       *my_addr = cluster_to_addr(temp); 
20DC:  MOVFF  396,03
20E0:  MOVFF  395,39B
20E4:  MOVFF  396,39C
20E8:  MOVFF  39A,3D5
20EC:  MOVFF  399,3D4
20F0:  MOVFF  398,3D3
20F4:  MOVFF  397,3D2
20F8:  MOVLB  0
20FA:  CALL   13BE
20FE:  MOVFF  39C,FEA
2102:  MOVFF  39B,FE9
2106:  MOVFF  00,FEF
210A:  MOVFF  01,FEC
210E:  MOVFF  02,FEC
2112:  MOVFF  03,FEC
....................    } 
2116:  BRA    2150
2118:  MOVLB  3
....................    else 
....................       *my_addr += 1; 
211A:  MOVFF  395,FE9
211E:  MOVFF  396,FEA
2122:  MOVLW  01
2124:  ADDWF  FEF,W
2126:  MOVWF  00
2128:  MOVLW  00
212A:  ADDWFC FEC,W
212C:  MOVWF  01
212E:  MOVLW  00
2130:  ADDWFC FEC,W
2132:  MOVWF  02
2134:  MOVLW  00
2136:  ADDWFC FEC,W
2138:  MOVWF  03
213A:  MOVF   FED,F
213C:  MOVF   FED,F
213E:  MOVF   FED,F
2140:  MOVFF  00,FEF
2144:  MOVFF  01,FEC
2148:  MOVFF  02,FEC
214C:  MOVWF  FEC
214E:  MOVLB  0
....................  
....................    return GOODEC; 
2150:  MOVLW  00
2152:  MOVWF  01
2154:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're trying to go backwards one entry from the beginning of the root, 
....................    //  we won't be able to... 
....................    if(*my_addr <= Root_Dir) 
*
141C:  MOVFF  397,03
1420:  MOVLB  3
1422:  MOVFF  396,FE9
1426:  MOVFF  397,FEA
142A:  MOVFF  FEF,39C
142E:  MOVFF  FEC,39D
1432:  MOVFF  FEC,39E
1436:  MOVFF  FEC,39F
143A:  MOVF   x9F,W
143C:  MOVLB  2
143E:  SUBWF  x21,W
1440:  BNC   146C
1442:  BNZ   1466
1444:  MOVLB  3
1446:  MOVF   x9E,W
1448:  MOVLB  2
144A:  SUBWF  x20,W
144C:  BNC   146C
144E:  BNZ   1466
1450:  MOVLB  3
1452:  MOVF   x9D,W
1454:  MOVLB  2
1456:  SUBWF  x1F,W
1458:  BNC   146C
145A:  BNZ   1466
145C:  MOVLB  3
145E:  MOVF   x9C,W
1460:  MOVLB  2
1462:  SUBWF  x1E,W
1464:  BNC   146C
....................       return GOODEC; 
1466:  MOVLW  00
1468:  MOVWF  01
146A:  BRA    165C
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... //#ifdef FAT32 
.................... //   if(*my_addr % Bytes_Per_Cluster == 0) 
.................... //#else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if(( ( *my_addr - Data_Start ) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
146C:  MOVFF  397,03
1470:  MOVFF  396,FE9
1474:  MOVFF  397,FEA
1478:  MOVFF  FEF,39C
147C:  MOVFF  FEC,39D
1480:  MOVFF  FEC,39E
1484:  MOVFF  FEC,39F
1488:  MOVLB  2
148A:  MOVF   x12,W
148C:  MOVLB  3
148E:  SUBWF  x9C,F
1490:  MOVLB  2
1492:  MOVF   x13,W
1494:  MOVLB  3
1496:  SUBWFB x9D,F
1498:  MOVLB  2
149A:  MOVF   x14,W
149C:  MOVLB  3
149E:  SUBWFB x9E,F
14A0:  MOVLB  2
14A2:  MOVF   x15,W
14A4:  MOVLB  3
14A6:  SUBWFB x9F,F
14A8:  MOVFF  FEA,3A1
14AC:  MOVFF  FE9,3A0
14B0:  BSF    FD8.1
14B2:  MOVLW  03
14B4:  MOVWF  FEA
14B6:  MOVLW  A2
14B8:  MOVWF  FE9
14BA:  MOVFF  39F,3AB
14BE:  MOVFF  39E,3AA
14C2:  MOVFF  39D,3A9
14C6:  MOVFF  39C,3A8
14CA:  CLRF   xAF
14CC:  CLRF   xAE
14CE:  MOVFF  20D,3AD
14D2:  MOVFF  20C,3AC
14D6:  MOVLB  0
14D8:  RCALL  11D4
14DA:  MOVFF  3A2,00
14DE:  MOVFF  3A3,01
14E2:  MOVFF  3A4,02
14E6:  MOVFF  3A5,03
14EA:  MOVFF  3A1,FEA
14EE:  MOVFF  3A0,FE9
14F2:  MOVFF  3A5,39F
14F6:  MOVFF  3A4,39E
14FA:  MOVFF  3A3,39D
14FE:  MOVFF  3A2,39C
1502:  MOVLB  3
1504:  MOVF   x9C,F
1506:  BTFSS  FD8.2
1508:  BRA    1624
150A:  MOVF   x9D,F
150C:  BTFSS  FD8.2
150E:  BRA    1624
1510:  MOVF   x9E,F
1512:  BTFSS  FD8.2
1514:  BRA    1624
1516:  MOVF   x9F,F
1518:  BTFSS  FD8.2
151A:  BRA    1624
151C:  MOVFF  397,03
1520:  MOVFF  396,FE9
1524:  MOVFF  397,FEA
1528:  MOVFF  FEF,39C
152C:  MOVFF  FEC,39D
1530:  MOVFF  FEC,39E
1534:  MOVFF  FEC,39F
1538:  MOVLB  2
153A:  MOVF   x15,W
153C:  MOVLB  3
153E:  SUBWF  x9F,W
1540:  BTFSS  FD8.0
1542:  BRA    1624
1544:  BNZ   1568
1546:  MOVLB  2
1548:  MOVF   x14,W
154A:  MOVLB  3
154C:  SUBWF  x9E,W
154E:  BNC   1624
1550:  BNZ   1568
1552:  MOVLB  2
1554:  MOVF   x13,W
1556:  MOVLB  3
1558:  SUBWF  x9D,W
155A:  BNC   1624
155C:  BNZ   1568
155E:  MOVLB  2
1560:  MOVF   x12,W
1562:  MOVLB  3
1564:  SUBWF  x9C,W
1566:  BNC   1624
.................... //#endif // #ifdef FAT32 
....................    { 
....................       temp = addr_to_cluster(*my_addr); 
1568:  MOVFF  397,03
156C:  MOVFF  396,FE9
1570:  MOVFF  397,FEA
1574:  MOVFF  FEF,3A0
1578:  MOVFF  FEC,3A1
157C:  MOVFF  FEC,3A2
1580:  MOVFF  FEC,3A3
1584:  MOVLB  0
1586:  RCALL  1268
1588:  MOVFF  03,39B
158C:  MOVFF  02,39A
1590:  MOVFF  01,399
1594:  MOVFF  00,398
....................       if(get_prev_cluster(&temp) == EOF) 
1598:  MOVLW  03
159A:  MOVLB  3
159C:  MOVWF  x9D
159E:  MOVLW  98
15A0:  MOVWF  x9C
15A2:  MOVLB  0
15A4:  BRA    12DE
15A6:  MOVF   01,W
15A8:  SUBLW  FF
15AA:  BNZ   15B6
....................          return EOF; 
15AC:  MOVLW  FF
15AE:  MOVWF  01
15B0:  MOVLB  2
15B2:  BRA    165C
15B4:  MOVLB  0
....................  
....................       *my_addr = cluster_to_addr(temp) + (Bytes_Per_Cluster - 1); 
15B6:  MOVFF  397,03
15BA:  MOVFF  396,39C
15BE:  MOVFF  397,39D
15C2:  MOVFF  39B,3D5
15C6:  MOVFF  39A,3D4
15CA:  MOVFF  399,3D3
15CE:  MOVFF  398,3D2
15D2:  MOVLB  0
15D4:  RCALL  13BE
15D6:  MOVFF  03,3A1
15DA:  MOVFF  02,3A0
15DE:  MOVFF  01,39F
15E2:  MOVFF  00,39E
15E6:  MOVLW  01
15E8:  MOVLB  2
15EA:  SUBWF  x0C,W
15EC:  MOVWF  00
15EE:  MOVLW  00
15F0:  SUBWFB x0D,W
15F2:  MOVWF  03
15F4:  MOVF   00,W
15F6:  MOVLB  3
15F8:  ADDWF  x9E,W
15FA:  MOVWF  00
15FC:  MOVF   03,W
15FE:  ADDWFC 01,W
1600:  MOVWF  01
1602:  MOVLW  00
1604:  ADDWFC 02,W
1606:  MOVWF  02
1608:  MOVLW  00
160A:  ADDWFC xA1,W
160C:  MOVFF  39D,FEA
1610:  MOVFF  39C,FE9
1614:  MOVFF  00,FEF
1618:  MOVFF  01,FEC
161C:  MOVFF  02,FEC
1620:  MOVWF  FEC
....................    } 
1622:  BRA    1656
....................    else 
....................       *my_addr -= 1; 
1624:  MOVFF  396,FE9
1628:  MOVFF  397,FEA
162C:  MOVLW  01
162E:  SUBWF  FEF,W
1630:  MOVWF  00
1632:  MOVLW  00
1634:  SUBWFB FEC,W
1636:  MOVWF  01
1638:  MOVLW  00
163A:  SUBWFB FEC,W
163C:  MOVWF  02
163E:  MOVLW  00
1640:  SUBWFB FEC,W
1642:  MOVF   FED,F
1644:  MOVF   FED,F
1646:  MOVF   FED,F
1648:  MOVFF  00,FEF
164C:  MOVFF  01,FEC
1650:  MOVFF  02,FEC
1654:  MOVWF  FEC
....................  
....................    return GOODEC; 
1656:  MOVLW  00
1658:  MOVWF  01
165A:  MOVLB  2
165C:  MOVLB  0
165E:  GOTO   1694 (RETURN)
.................... } 
....................  
.................... /* 
.................... int32 cluster_to_addr(int32 cluster) 
.................... Summary: Converts a cluster number to an address. 
.................... Param: The cluster to convert. 
.................... Returns: The cluster's address. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 cluster_to_addr(int32 cluster) 
.................... { 
....................    // in unit math: 
....................    //  return  Bytes+(Bytes  /  Cluster * (Clusters - Clusters)) 
....................    return Root_Dir + (Bytes_Per_Cluster * (cluster - 2)); 
*
13BE:  MOVLW  02
13C0:  MOVLB  3
13C2:  SUBWF  xD2,W
13C4:  MOVWF  00
13C6:  MOVLW  00
13C8:  SUBWFB xD3,W
13CA:  MOVWF  01
13CC:  MOVLW  00
13CE:  SUBWFB xD4,W
13D0:  MOVWF  02
13D2:  MOVLW  00
13D4:  SUBWFB xD5,W
13D6:  MOVWF  03
13D8:  MOVWF  xD9
13DA:  MOVFF  02,3D8
13DE:  MOVFF  01,3D7
13E2:  MOVFF  00,3D6
13E6:  CLRF   xDD
13E8:  CLRF   xDC
13EA:  MOVFF  20D,3DB
13EE:  MOVFF  20C,3DA
13F2:  MOVWF  xE1
13F4:  MOVFF  02,3E0
13F8:  MOVFF  01,3DF
13FC:  MOVFF  00,3DE
1400:  MOVLB  0
1402:  CALL   0B2C
1406:  MOVLB  2
1408:  MOVF   x1E,W
140A:  ADDWF  00,F
140C:  MOVF   x1F,W
140E:  ADDWFC 01,F
1410:  MOVF   x20,W
1412:  ADDWFC 02,F
1414:  MOVF   x21,W
1416:  ADDWFC 03,F
1418:  MOVLB  0
141A:  RETURN 0
.................... } 
.................... #else 
.................... int32 cluster_to_addr(int16 cluster) 
.................... { 
....................    if(cluster < 2) 
....................       return 0; 
....................    // in unit math: 
....................    //  return  Bytes + (       Bytes  /  Cluster * (Clusters- Clusters)) 
....................    return Data_Start + ((int32)Bytes_Per_Cluster * (cluster - 2)); 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... int32 addr_to_cluster(int32 addr) 
.................... Summary: Converts an address to a cluster number. 
.................... Param: The address to convert. 
.................... Returns: The address's cluster. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 addr_to_cluster(int32 addr) 
.................... { 
....................    // in unit math: 
....................    //  return (Bytes -Bytes) / Bytes  /  Cluster) + Clusters 
....................    return ((addr - Root_Dir) / Bytes_Per_Cluster) + 2; 
*
1268:  MOVLB  2
126A:  MOVF   x1E,W
126C:  MOVLB  3
126E:  SUBWF  xA0,W
1270:  MOVWF  xA4
1272:  MOVLB  2
1274:  MOVF   x1F,W
1276:  MOVLB  3
1278:  SUBWFB xA1,W
127A:  MOVWF  xA5
127C:  MOVLB  2
127E:  MOVF   x20,W
1280:  MOVLB  3
1282:  SUBWFB xA2,W
1284:  MOVWF  xA6
1286:  MOVLB  2
1288:  MOVF   x21,W
128A:  MOVLB  3
128C:  SUBWFB xA3,W
128E:  MOVWF  xA7
1290:  BCF    FD8.1
1292:  MOVWF  xAB
1294:  MOVFF  3A6,3AA
1298:  MOVFF  3A5,3A9
129C:  MOVFF  3A4,3A8
12A0:  CLRF   xAF
12A2:  CLRF   xAE
12A4:  MOVFF  20D,3AD
12A8:  MOVFF  20C,3AC
12AC:  MOVLB  0
12AE:  RCALL  11D4
12B0:  MOVFF  03,3A7
12B4:  MOVFF  02,3A6
12B8:  MOVFF  01,3A5
12BC:  MOVFF  00,3A4
12C0:  MOVLW  02
12C2:  MOVLB  3
12C4:  ADDWF  00,W
12C6:  MOVWF  00
12C8:  MOVLW  00
12CA:  ADDWFC 01,W
12CC:  MOVWF  01
12CE:  MOVLW  00
12D0:  ADDWFC 02,W
12D2:  MOVWF  02
12D4:  MOVLW  00
12D6:  ADDWFC 03,W
12D8:  MOVWF  03
12DA:  MOVLB  0
12DC:  RETURN 0
.................... } 
.................... #else 
.................... int16 addr_to_cluster(int32 addr) 
.................... { 
....................    if(addr < Data_Start) 
....................       return 0; 
....................    // in unit math: 
....................    //  return (Bytes -Bytes)   /(Bytes  /  Cluster) + Clusters 
....................    return ((addr - Data_Start) / Bytes_Per_Cluster) + 2; 
.................... } 
.................... #endif 
.................... /* 
.................... signed int format(int32 DskSize) 
.................... Summary: Formats media with a FAT filesystem. 
.................... Param: The size of the filesystem to create in kB. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: There are certain minimum and maximum size restrictions on the card and type of file system. The restrictions are as follows: 
....................        FAT16: DskSize < 2GB 
....................        FAT32: 33MB < DskSize < 32GB 
....................        In order to change the way that the drive is formatted, select the proper #define(FAT16 or FAT32) way up at the top of this file. 
.................... Note: In this context, 1kB = 1024B = 2^10B. Please don't confuse this with 10^3B, we don't want to be wasting thousands of bytes of information now, do we? 
.................... Note: DskSize has a lower limit of 64, anything lower becomes highly inefficient and runs the risk of very quick corruption. 
.................... Note: If this is called on an MMC/SD card, Windows will recognize it as a RAW filesystem. 
.................... */ 
.................... signed int format(int32 DskSize) 
.................... { 
....................    int 
....................       BPB_Media = 0xF8, 
....................       BPB_NumFATs = 1, 
....................       BPB_NumHeads = 2, 
....................       BPB_SecPerClus, 
....................       BPB_SecPerTrk = 0x20; 
....................  
....................    int16 
....................       BPB_BytsPerSec = 0x200, 
....................       i; 
....................  
....................    int32 
....................       BPB_TotSec, 
....................       BS_VolID = 0, 
....................       RootDirSectors, 
....................       TmpVal1, 
....................       TmpVal2; 
....................  
....................    char                
....................       BS_OEMName[] = "MSDOS5.0", 
....................       BS_VolLab[] = "NO NAME    "; 
....................  
.................... #ifdef FAT32 
....................    int 
....................       BPB_BkBootSec = 6, 
....................       BPB_FSInfo = 1, 
....................       BPB_RootClus = 2, 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x58, 
....................       data[0x5A]; 
....................  
....................    int16 
....................       BPB_RootEntCnt = 0, 
....................       BPB_RsvdSecCnt = 32; 
....................     
....................    int32 BPB_FATSz; 
....................     
....................    char BS_FilSysType[] = "FAT32   "; 
.................... #else 
....................    int 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x3C, 
....................       data[0x3E]; 
....................        
....................    int16 
....................       BPB_FATSz, 
....................       BPB_RootEntCnt = 512, 
....................       BPB_RsvdSecCnt = 1; 
....................        
....................    char BS_FilSysType[] = "FAT12   "; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize variables 
....................    // figure out total sectors 
....................    BPB_TotSec = (DskSize * 0x400) / BPB_BytsPerSec; 
....................     
....................    // use the magical table on page 20 of fatgen103.pdf to determine sectors per cluster 
.................... #ifdef FAT32 
....................    if(DskSize < 0x8400) // < 33 MB; this is too small 
....................       return EOF; 
....................    else if(DskSize < 0x41000) // 260 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0X800000) // 8 GB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x1000000) // 16 GB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x2000000) // 32 GB 
....................       BPB_SecPerClus = 32; 
....................    else // > 32 GB; this is too big 
....................       return EOF; 
.................... #else 
....................    if(DskSize < 0x1400) // < 5 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0x4000) // 16 MB 
....................       BPB_SecPerClus = 2; 
....................    else if(DskSize < 0X20000) // 128 MB 
....................       BPB_SecPerClus = 4; 
....................    else if(DskSize < 0x40000) // 256 MB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x80000) // 512 MB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x100000) // 1 GB 
....................       BPB_SecPerClus = 32; 
....................    else if(DskSize < 0x200000) // 2 GB 
....................       BPB_SecPerClus = 64; 
....................    else // > 2 GB; this is too big 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // figure out how many sectors one FAT takes up 
....................    RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;  
....................    TmpVal1 = DskSize - (BPB_RsvdSecCnt + RootDirSectors);  
....................    TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;  
.................... #ifdef FAT32 
....................    TmpVal2 = TmpVal2 / 2; 
.................... #endif // #ifdef FAT32  
....................    BPB_FATSz = (TmpVal1 + (TmpVal2 - 1)) / TmpVal2; 
....................  
....................    // zero data 
....................    for(i = 0; i < sizeof(data); i += 1) 
....................       data[i] = 0; 
....................  
....................    // start filling up data 
....................    data[0] = 0xEB; 
....................    data[1] = BS_jmpBoot; 
....................    data[2] = 0x90;    
....................    sprintf(data + 3, "%s", BS_OEMName); 
....................    data[11] = make8(BPB_BytsPerSec, 0); 
....................    data[12] = make8(BPB_BytsPerSec, 1); 
....................    data[13] = BPB_SecPerClus; 
....................    data[14] = BPB_RsvdSecCnt; 
....................    data[16] = BPB_NumFATs; 
....................    data[21] = BPB_Media; 
....................    data[24] = BPB_SecPerTrk;  
....................    data[26] = BPB_NumHeads; 
.................... #ifdef FAT32 
....................    data[32] = make8(BPB_TotSec, 0); 
....................    data[33] = make8(BPB_TotSec, 1); 
....................    data[34] = make8(BPB_TotSec, 2); 
....................    data[35] = make8(BPB_TotSec, 3); 
....................    data[36] = make8(BPB_FATSz, 0); 
....................    data[37] = make8(BPB_FATSz, 1); 
....................    data[38] = make8(BPB_FATSz, 2); 
....................    data[39] = make8(BPB_FATSz, 3); 
....................    data[44] = BPB_RootClus; 
....................    data[48] = BPB_FSInfo; 
....................    data[50] = BPB_BkBootSec; 
....................    data[66] = BS_BootSig; 
....................    data[67] = make8(BS_VolID, 0); 
....................    data[68] = make8(BS_VolID, 1); 
....................    data[69] = make8(BS_VolID, 2); 
....................    data[70] = make8(BS_VolID, 3); 
....................    sprintf(data + 71, "%s", BS_VolLab); 
....................    sprintf(data + 82, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    clear_cluster(2); 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 12 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    data[3] = 0x0F; 
....................    data[4] = 0xFF; 
....................    data[5] = 0xFF; 
....................    data[6] = 0xFF; 
....................    data[7] = 0x0F; 
....................    data[8] = 0xFF; 
....................    data[9] = 0xFF; 
....................    data[10] = 0xFF; 
....................    data[11] = 0x0F; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
....................    // reset the last cluster 
....................    i = 2; 
....................    if(mmcsd_write_data(0x3EC, 4, &i) != GOODEC) 
....................       return EOF; 
.................... #else 
....................    data[17] = make8(BPB_RootEntCnt, 0); 
....................    data[18] = make8(BPB_RootEntCnt, 1); 
....................    data[19] = make8(BPB_TotSec, 0); 
....................    data[20] = make8(BPB_TotSec, 1); 
....................    data[22] = make8(BPB_FATSz, 0); 
....................    data[23] = make8(BPB_FATSz, 1); 
....................    data[38] = BS_BootSig; 
....................    data[39] = make8(BS_VolID, 0); 
....................    data[40] = make8(BS_VolID, 1); 
....................    data[41] = make8(BS_VolID, 2); 
....................    data[42] = make8(BS_VolID, 3); 
....................    sprintf(data + 43, "%s", BS_VolLab); 
....................    sprintf(data + 54, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    for(i = 0; i < (0x20 * BPB_RootEntCnt); i += 0x20) 
....................       if(mmcsd_write_data(TmpVal2 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 3 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
.................... #endif // #ifdef FAT32 
....................  
....................    i = 0xAA55; 
....................  
....................    if(mmcsd_write_data(0x1FE, 2, &i) != GOODEC) 
....................       return EOF;    
....................  
....................    // we're going to have to re-initialize the FAT, a bunch of parameters probably just changed 
....................    fat_init(); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Debugging Utility Functions /// 
....................  
.................... /* 
.................... signed int disp_folder_contents(char foldername[]) 
.................... Summary: Displays the contents of a folder. 
.................... Param: The folder to display the contents of. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int disp_folder_contents(char foldername[]) 
.................... { 
....................    char filename[MAX_FILE_NAME_LENGTH]; // a place to hold a file name 
....................     
....................    FILE stream; // the stream that we're going to be working with 
....................     
....................    char mode[] = "r"; 
....................     
....................    if(fatopen(foldername, mode, &stream) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf off a header 
....................    printf("\r\n--%s--", foldername); 
....................  
....................    // start off at the root directory 
....................    stream.Entry_Addr = stream.Start_Addr; 
....................  
....................    while(get_next_file(&stream) != EOF) 
....................    { 
....................       // get the name of the file that we are at 
....................       if(get_file_name(stream.Entry_Addr, filename) != GOODEC) 
....................          return EOF; 
....................       
....................       // make cool little "tree" branches 
....................       printf("\r\n%s", filename); 
....................       if (stream.File_Type == Directory) 
....................          putc('/'); 
....................    } 
....................  
....................    fatclose(&stream); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_addr(int32 from, int32 to) 
.................... Summary: Display a series of addresses in a hex editor type fashion. 
.................... Param from: The beginning address to display. 
.................... Param to: The end address to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_addr(int32 from, int32 to) 
.................... { 
....................    int 
....................       j,          // counter for loops 
....................       val[0x10];  // buffer to hold values 
....................  
....................    int32 i;       // pointer to memory 
....................  
....................    // print off header 
....................    printf("\r\n\r\n         "); 
....................    for(i = 0; i < 0x10; i += 1) 
....................       printf("%2X ", i); 
....................  
....................    // note that the to and from values are being rounded up and down 
....................    //  this makes a nice "block" map in case someone inputs a number that 
....................    //  isn't evenly divisible by 0x10 
....................    for(i = (from - (from % 0x10)); i <= (to + (to % 0x10)); i += 0x10) 
....................    { 
....................       // printf memory block 
....................       printf("\r\n%lX ", i); 
....................  
....................       // fill up buffer 
....................       if(mmcsd_read_data(i, 0x10, val) != GOODEC)   
....................          return EOF; 
....................  
....................       // printf RAM in hex 
....................       for(j = 0; j < 0X10; j += 1) 
....................          printf("%X ", val[j]); 
....................  
....................       // printf spacer 
....................       printf("; "); 
....................  
....................       // printf RAM in char 
....................       for(j = 0; j < 0X10; j += 1) 
....................       { 
....................          // check for characters that will mess up the nice-looking map 
....................          if(val[j] < ' ') 
....................             val[j] = '.'; 
....................  
....................          printf("%c", val[j]); 
....................       } 
....................    } 
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... Summary: Display a series of clusters in a memory map. 
.................... Param from: The beginning clusters to display. 
.................... Param to: The end clusters to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... { 
....................    // convert the clusters to addresses and dump 
....................    if(dump_addr(cluster_to_addr(from), cluster_to_addr(to)) != GOODEC) 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... void disp_fat_stats() 
.................... Summary: Display essential statistics about the FAT to the console. 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_fat_stats() 
.................... { 
....................    printf("\r\n\r\n--FAT Stats--\r\n"); 
....................    printf("First FAT starts at: 0x%lX\r\n", FAT_Start); 
....................    printf("Data Starts At: 0x%lX\r\n", Data_Start); 
....................    printf("Root Directory Is At: 0x%lX\r\n", Root_Dir); 
....................    printf("Bytes Per Cluster: 0x%lX\r\n", Bytes_Per_Cluster); 
.................... } 
....................  
.................... /* 
.................... signed int fatprintfinfo(FILE* stream) 
.................... Summary: Display essential statistics about the file that a stream is pointing to. 
.................... Param: The stream to print off information about. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatprintfinfo(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 val = 0; // buffer to hold values 
....................  
....................    char name[MAX_FILE_NAME_LENGTH]; 
....................  
....................    // get name 
....................    if(get_file_name(stream->Entry_Addr, name) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf header 
....................    printf("\r\n\r\n--"); 
....................    printf(name); 
....................    printf(" Info--"); 
....................  
....................    // printf attributes 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0B, 1, &val); 
....................    printf("\r\nAttributes: 0x%X", val); 
....................  
....................    // printf creation date 
....................    printf("\r\nCreated: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x10, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf creation time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0E, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf modification date 
....................    printf("\r\nModified: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x18, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf modification time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x16, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf starting cluster 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&val + 1); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &val); 
....................  
....................    printf("\r\nStarting cluster: %lX", val); 
....................  
....................    // printf starting address 
....................    printf("\r\nStarting address: %lX", cluster_to_addr(val)); 
....................  
....................    // printf size 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1C, 4, &val); 
....................    printf("\r\nSize: %lu Bytes\r\n", val); 
....................  
....................    if(ec != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... #endif // #ifndef FAT_PIC_C 
....................  
....................  
....................  
....................  int8 i, dato; 
....................  FILE myfile; 
....................   
.................... void initialize(){  
....................    printf("\r\n\nInitialize FAT library ... "); 
*
0FB6:  MOVLW  3E
0FB8:  MOVWF  FF6
0FBA:  MOVLW  01
0FBC:  MOVWF  FF7
0FBE:  CALL   0328
....................    delay_ms(100); 
0FC2:  MOVLW  64
0FC4:  MOVLB  2
0FC6:  MOVWF  x89
0FC8:  MOVLB  0
0FCA:  CALL   02BC
....................    // Initializing the FAT library as well as the SD card ---> returns 0 if OK 
....................    i = fat_init(); 
0FCE:  BRA    0B88
0FD0:  MOVFF  01,224
....................    if(i != 0){ 
0FD4:  MOVLB  2
0FD6:  MOVF   x24,F
0FD8:  BZ    0FEE
....................       printf("Error initializing FAT library!\r\n"); 
0FDA:  MOVLW  5E
0FDC:  MOVWF  FF6
0FDE:  MOVLW  01
0FE0:  MOVWF  FF7
0FE2:  MOVLB  0
0FE4:  CALL   0328
....................       while(1){ 
0FE8:  BRA    0FE8
....................       } 
....................    } 
0FEA:  BRA    105C
0FEC:  MOVLB  2
....................    else{ 
....................       printf("FAT Library initialized ... "); 
0FEE:  MOVLW  80
0FF0:  MOVWF  FF6
0FF2:  MOVLW  01
0FF4:  MOVWF  FF7
0FF6:  MOVLB  0
0FF8:  CALL   0328
....................       delay_ms(100);  
0FFC:  MOVLW  64
0FFE:  MOVLB  2
1000:  MOVWF  x89
1002:  MOVLB  0
1004:  CALL   02BC
....................       // Display SD card type ---> MMC, SDSC or SDHC 
....................       printf("Card Type: "); 
1008:  MOVLW  9E
100A:  MOVWF  FF6
100C:  MOVLW  01
100E:  MOVWF  FF7
1010:  CALL   0328
....................     switch(g_card_type) { 
1014:  MOVLB  2
1016:  MOVF   x09,W
1018:  XORLW  00
101A:  MOVLB  0
101C:  BZ    1028
101E:  XORLW  01
1020:  BZ    1036
1022:  XORLW  03
1024:  BZ    1044
1026:  BRA    105C
....................       case MMC: printf("MMC \r\n"); break; 
1028:  MOVLW  AA
102A:  MOVWF  FF6
102C:  MOVLW  01
102E:  MOVWF  FF7
1030:  CALL   0328
1034:  BRA    105C
....................       case SDSC: printf("SDSC \r\n"); break; 
1036:  MOVLW  B2
1038:  MOVWF  FF6
103A:  MOVLW  01
103C:  MOVWF  FF7
103E:  CALL   0328
1042:  BRA    105C
....................       case SDHC: printf("SDHC \r\n"); 
1044:  MOVLW  BA
1046:  MOVWF  FF6
1048:  MOVLW  01
104A:  MOVWF  FF7
104C:  CALL   0328
....................       delay_ms(100); 
1050:  MOVLW  64
1052:  MOVLB  2
1054:  MOVWF  x89
1056:  MOVLB  0
1058:  CALL   02BC
....................     } 
....................   } 
105C:  GOTO   4A3A (RETURN)
.................... } 
....................  
.................... //!void create_folder(){ 
.................... //!    // Create folder 'Test Dir' 
.................... //!    printf("Create 'Test Dir' folder ... "); 
.................... //!    if(mk_dir("/Test Dir/") == 0) 
.................... //!      printf("OK \r\n"); 
.................... //!    else 
.................... //!      printf("error creating folder \r\n"); 
.................... //!    delay_ms(1); 
.................... //!} 
....................  
.................... void create_doc(){ 
....................     // Create a text file 'log.txt' 
....................     printf("Create 'Datos.txt' file ---> "); 
*
4016:  MOVLW  C2
4018:  MOVWF  FF6
401A:  MOVLW  01
401C:  MOVWF  FF7
401E:  CALL   0328
....................     if(mk_file("/Datos.txt") == 0) 
4022:  MOVLW  02
4024:  MOVWF  FEA
4026:  MOVLW  61
4028:  MOVWF  FE9
402A:  MOVLW  0B
402C:  MOVWF  01
402E:  CLRF   FF7
4030:  MOVLW  00
4032:  CALL   0004
4036:  TBLRD*-
4038:  TBLRD*+
403A:  MOVFF  FF5,FEE
403E:  DECFSZ 01,F
4040:  BRA    4038
4042:  MOVLW  02
4044:  MOVLB  2
4046:  MOVWF  x6F
4048:  MOVLW  61
404A:  MOVWF  x6E
404C:  MOVLB  0
404E:  BRA    3E98
4050:  MOVF   01,F
4052:  BNZ   4062
....................       printf("OK \r\n"); 
4054:  MOVLW  E0
4056:  MOVWF  FF6
4058:  MOVLW  01
405A:  MOVWF  FF7
405C:  CALL   0328
4060:  BRA    406E
....................     else 
....................       printf("error creating file \r\n"); 
4062:  MOVLW  E6
4064:  MOVWF  FF6
4066:  MOVLW  01
4068:  MOVWF  FF7
406A:  CALL   0328
....................     delay_ms(1); 
406E:  MOVLW  01
4070:  MOVLB  2
4072:  MOVWF  x89
4074:  MOVLB  0
4076:  CALL   02BC
407A:  GOTO   4A4A (RETURN)
.................... } 
....................  
.................... void eliminate_doc(){ 
....................     // Create a text file 'log.txt' 
....................     printf("eliminating 'Datos.txt' file ---> "); 
....................     if(rm_file("/Datos.txt") == 0) 
....................       printf("OK \r\n"); 
....................     else 
....................       printf("error eliminating file \r\n"); 
....................     delay_ms(1); 
.................... } 
....................  
.................... void open_doc(){ 
....................     // Open the last created file 'log.txt' with write permission ('w') "r" = read "w" = write "a" = append "rb" = read binarily          
.................... //    printf("Open 'Datos.txt' file ---> ");                                               
....................     if(fatopen("/Datos.txt", "a", &myfile) != 0)                                       
407E:  MOVLW  02
4080:  MOVWF  FEA
4082:  MOVLW  61
4084:  MOVWF  FE9
4086:  MOVLW  0B
4088:  MOVWF  01
408A:  CLRF   FF7
408C:  MOVLW  00
408E:  CALL   0004
4092:  TBLRD*-
4094:  TBLRD*+
4096:  MOVFF  FF5,FEE
409A:  DECFSZ 01,F
409C:  BRA    4094
409E:  MOVLW  61
40A0:  MOVLB  2
40A2:  MOVWF  x6C
40A4:  CLRF   x6D
40A6:  MOVLW  02
40A8:  MOVWF  xF4
40AA:  MOVLW  61
40AC:  MOVWF  xF3
40AE:  MOVLW  02
40B0:  MOVWF  xF6
40B2:  MOVLW  6C
40B4:  MOVWF  xF5
40B6:  MOVLW  02
40B8:  MOVWF  xF8
40BA:  MOVLW  26
40BC:  MOVWF  xF7
40BE:  MOVLB  0
40C0:  CALL   304A
40C4:  MOVF   01,F
40C6:  BZ    40D4
....................       printf("  error opening file \r\n");                                     
40C8:  MOVLW  42
40CA:  MOVWF  FF6
40CC:  MOVLW  02
40CE:  MOVWF  FF7
40D0:  CALL   0328
....................     else { 
.................... //      printf("OK \r\n"); 
....................     } 
40D4:  GOTO   4A4E (RETURN)
.................... } 
....................  
.................... void write_docu(int dato){ 
....................       // Write some thing to the text file 
....................       char txt[50]; 
.................... //      printf("Writing to the text file 'Datos.txt' ---> "); 
....................       sprintf(txt, "%02u", dato); 
*
41FE:  MOVLW  02
4200:  MOVLB  2
4202:  MOVWF  x23
4204:  MOVLW  62
4206:  MOVWF  x22
4208:  MOVFF  261,294
420C:  MOVLW  01
420E:  MOVWF  x95
4210:  MOVLB  0
4212:  BRA    4104
....................       if(fatputs(txt, &myfile) == 0){ 
4214:  MOVLW  02
4216:  MOVLB  2
4218:  MOVWF  x95
421A:  MOVLW  62
421C:  MOVWF  x94
421E:  MOVLW  02
4220:  MOVWF  x97
4222:  MOVLW  26
4224:  MOVWF  x96
4226:  MOVLB  0
4228:  RCALL  4188
422A:  MOVF   01,F
422C:  BNZ   423A
....................         printf(txt); 
422E:  MOVLW  02
4230:  MOVWF  FEA
4232:  MOVLW  62
4234:  MOVWF  FE9
4236:  BRA    41D6
.................... //        printf(" ---> OK \r\n"); 
....................       } 
4238:  BRA    4246
....................       else{ 
....................         printf("  writing error \r\n"); 
423A:  MOVLW  5A
423C:  MOVWF  FF6
423E:  MOVLW  02
4240:  MOVWF  FF7
4242:  CALL   0328
....................       } 
4246:  GOTO   4A56 (RETURN)
.................... } 
....................  
.................... void write_docf(float dato){ 
....................       // Write some thing to the text file 
....................       char txt[50]; 
.................... //      printf("Writing to the text file 'Datos.txt' ---> "); 
....................       sprintf(txt, "%05f", dato); 
....................       if(fatputs(txt, &myfile) == 0){ 
....................         printf(txt); 
.................... //        printf(" ---> OK \r\n"); 
....................       } 
....................       else{ 
....................         printf(" ---> writing error \r\n"); 
....................       } 
.................... } 
....................  
.................... void enter(){ 
....................    fatputs("\r\n", &myfile); 
424A:  MOVLW  0D
424C:  MOVLB  2
424E:  MOVWF  x61
4250:  MOVLW  0A
4252:  MOVWF  x62
4254:  CLRF   x63
4256:  MOVLW  02
4258:  MOVWF  x95
425A:  MOVLW  61
425C:  MOVWF  x94
425E:  MOVLW  02
4260:  MOVWF  x97
4262:  MOVLW  26
4264:  MOVWF  x96
4266:  MOVLB  0
4268:  RCALL  4188
426A:  GOTO   4A5A (RETURN)
.................... } 
....................  
.................... void close_doc(){ 
....................       // Now close the file 
.................... //      printf("Closing the file 'Datos.txt' ---> "); 
....................       if(fatclose(&myfile) == 0){ 
*
4728:  MOVLW  02
472A:  MOVLB  2
472C:  MOVWF  x62
472E:  MOVLW  26
4730:  MOVWF  x61
4732:  MOVLB  0
4734:  BRA    440A
4736:  MOVF   01,F
4738:  BNZ   473C
.................... //        printf("OK \r\n"); 
....................       } 
473A:  BRA    4748
....................       else{ 
....................         printf("  closing error \r\n");} 
473C:  MOVLW  86
473E:  MOVWF  FF6
4740:  MOVLW  02
4742:  MOVWF  FF7
4744:  CALL   0328
4748:  GOTO   4A5C (RETURN)
.................... } 
....................  
.................... void read_doc(){ 
....................     // Reading 'log.txt' file 
....................     printf("Reading 'Datos.txt' file: \r\n"); 
*
4996:  MOVLW  9A
4998:  MOVWF  FF6
499A:  MOVLW  02
499C:  MOVWF  FF7
499E:  CALL   0328
....................     // Open 'log.txt' file with read permission ('r') 
.................... //!    printf("Open 'log.txt' file ... "); 
.................... //!    if(fatopen("/log.txt", "r", &myfile) != 0) 
.................... //!      printf("error opening file"); 
.................... //!    else { 
.................... //!      printf("OK"); 
.................... //!      // Print the whole file 
.................... //!      printf("\r\nPrint 'log.txt' file:\r\n\r"); 
....................       fatopen("/Datos.txt", "r", &myfile); 
49A2:  MOVLW  02
49A4:  MOVWF  FEA
49A6:  MOVLW  61
49A8:  MOVWF  FE9
49AA:  MOVLW  0B
49AC:  MOVWF  01
49AE:  CLRF   FF7
49B0:  MOVLW  00
49B2:  CALL   0004
49B6:  TBLRD*-
49B8:  TBLRD*+
49BA:  MOVFF  FF5,FEE
49BE:  DECFSZ 01,F
49C0:  BRA    49B8
49C2:  MOVLW  72
49C4:  MOVLB  2
49C6:  MOVWF  x6C
49C8:  CLRF   x6D
49CA:  MOVLW  02
49CC:  MOVWF  xF4
49CE:  MOVLW  61
49D0:  MOVWF  xF3
49D2:  MOVLW  02
49D4:  MOVWF  xF6
49D6:  MOVLW  6C
49D8:  MOVWF  xF5
49DA:  MOVLW  02
49DC:  MOVWF  xF8
49DE:  MOVLW  26
49E0:  MOVWF  xF7
49E2:  MOVLB  0
49E4:  CALL   304A
....................       fatprintf(&myfile); 
49E8:  MOVLW  02
49EA:  MOVLB  2
49EC:  MOVWF  x6F
49EE:  MOVLW  26
49F0:  MOVWF  x6E
49F2:  MOVLB  0
49F4:  BRA    4968
....................       // Now close the file 
.................... //      if(fatclose(&myfile) == 0) 
....................         printf("\r\n\n"); 
49F6:  MOVLW  B8
49F8:  MOVWF  FF6
49FA:  MOVLW  02
49FC:  MOVWF  FF7
49FE:  CALL   0328
4A02:  GOTO   4A5E (RETURN)
.................... //      else 
.................... //        printf("closing error \r\n\n"); 
....................      
.................... } 
....................  
....................  
....................  
.................... int z=0; 
....................  
.................... void main(){ 
4A06:  CLRF   FF8
4A08:  BCF    FD0.7
4A0A:  MOVLW  70
4A0C:  MOVWF  FD3
4A0E:  MOVF   FD3,W
4A10:  BCF    F92.3
4A12:  BSF    F89.3
4A14:  MOVLB  2
4A16:  CLRF   x23
4A18:  CLRF   x22
4A1A:  CLRF   x60
4A1C:  MOVF   FC1,W
4A1E:  ANDLW  C0
4A20:  IORLW  0F
4A22:  MOVWF  FC1
4A24:  MOVLW  07
4A26:  MOVWF  FB4
4A28:  CLRF   x0A
4A2A:  CLRF   x0B
....................    delay_ms(100); 
4A2C:  MOVLW  64
4A2E:  MOVWF  x89
4A30:  MOVLB  0
4A32:  CALL   02BC
....................    initialize(); 
4A36:  GOTO   0FB6
....................    delay_ms(100); 
4A3A:  MOVLW  64
4A3C:  MOVLB  2
4A3E:  MOVWF  x89
4A40:  MOVLB  0
4A42:  CALL   02BC
....................    create_doc(); 
4A46:  GOTO   4016
....................    while(TRUE){ 
....................       open_doc(); 
4A4A:  GOTO   407E
....................       write_docu(z); 
4A4E:  MOVFF  260,261
4A52:  GOTO   41FE
....................       enter(); 
4A56:  GOTO   424A
....................       close_doc(); 
4A5A:  BRA    4728
....................       read_doc(); 
4A5C:  BRA    4996
....................       z++; 
4A5E:  MOVLB  2
4A60:  INCF   x60,F
....................       delay_ms(1000); 
4A62:  MOVLW  04
4A64:  MOVWF  x61
4A66:  MOVLW  FA
4A68:  MOVWF  x89
4A6A:  MOVLB  0
4A6C:  CALL   02BC
4A70:  MOVLB  2
4A72:  DECFSZ x61,F
4A74:  BRA    4A66
4A76:  MOVLB  0
4A78:  BRA    4A4A
....................    } 
....................  
.................... } 
4A7A:  SLEEP 

Configuration Fuses:
   Word  1: C821   PLL2 CPUDIV1 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
