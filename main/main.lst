CCS PCH C Compiler, Version 5.059, 5967               19-feb.-20 13:23

               Filename:   E:\Trabajos U\ELECTIVA INSTRUMENTACION\PROYECTO\TODO2\main.lst

               ROM used:   26282 bytes (80%)
                           Largest free fragment is 6486
               RAM used:   827 (40%) at main() level
                           1131 (55%) worst case
               Stack used: 10 locations
               Stack size: 31

*
0000:  GOTO   5CD6
.................... #include <main.h> 
.................... #define MMCSD_SPI_HW                // Use hardware SPI module 
.................... #define MMCSD_PIN_SELECT  PIN_A2 
....................  
.................... #include <18F2550.h> 
.................... //////////// Standard Header file for the PIC18F2550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2550 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 2F,44
0016:  DATA 61,74
0018:  DATA 6F,73
001A:  DATA 2E,74
001C:  DATA 78,74
001E:  DATA 00,00
0020:  DATA 0D,0A
0022:  DATA 2D,2D
0024:  DATA 25,73
0026:  DATA 2D,2D
0028:  DATA 00,00
002A:  DATA 0D,0A
002C:  DATA 0D,0A
002E:  DATA 20,20
0030:  DATA 20,20
0032:  DATA 20,20
0034:  DATA 20,20
0036:  DATA 20,00
0038:  DATA 0D,0A
003A:  DATA 0D,0A
003C:  DATA 2D,2D
003E:  DATA 46,41
0040:  DATA 54,20
0042:  DATA 53,74
0044:  DATA 61,74
0046:  DATA 73,2D
0048:  DATA 2D,0D
004A:  DATA 0A,00
004C:  DATA 46,69
004E:  DATA 72,73
0050:  DATA 74,20
0052:  DATA 46,41
0054:  DATA 54,20
0056:  DATA 73,74
0058:  DATA 61,72
005A:  DATA 74,73
005C:  DATA 20,61
005E:  DATA 74,3A
0060:  DATA 20,30
0062:  DATA 78,25
0064:  DATA 6C,58
0066:  DATA 0D,0A
0068:  DATA 00,00
006A:  DATA 44,61
006C:  DATA 74,61
006E:  DATA 20,53
0070:  DATA 74,61
0072:  DATA 72,74
0074:  DATA 73,20
0076:  DATA 41,74
0078:  DATA 3A,20
007A:  DATA 30,78
007C:  DATA 25,6C
007E:  DATA 58,0D
0080:  DATA 0A,00
0082:  DATA 52,6F
0084:  DATA 6F,74
0086:  DATA 20,44
0088:  DATA 69,72
008A:  DATA 65,63
008C:  DATA 74,6F
008E:  DATA 72,79
0090:  DATA 20,49
0092:  DATA 73,20
0094:  DATA 41,74
0096:  DATA 3A,20
0098:  DATA 30,78
009A:  DATA 25,6C
009C:  DATA 58,0D
009E:  DATA 0A,00
00A0:  DATA 42,79
00A2:  DATA 74,65
00A4:  DATA 73,20
00A6:  DATA 50,65
00A8:  DATA 72,20
00AA:  DATA 43,6C
00AC:  DATA 75,73
00AE:  DATA 74,65
00B0:  DATA 72,3A
00B2:  DATA 20,30
00B4:  DATA 78,25
00B6:  DATA 6C,58
00B8:  DATA 0D,0A
00BA:  DATA 00,00
00BC:  DATA 0D,0A
00BE:  DATA 0D,0A
00C0:  DATA 2D,2D
00C2:  DATA 00,00
00C4:  DATA 20,49
00C6:  DATA 6E,66
00C8:  DATA 6F,2D
00CA:  DATA 2D,00
00CC:  DATA 0D,0A
00CE:  DATA 41,74
00D0:  DATA 74,72
00D2:  DATA 69,62
00D4:  DATA 75,74
00D6:  DATA 65,73
00D8:  DATA 3A,20
00DA:  DATA 30,78
00DC:  DATA 25,58
00DE:  DATA 00,00
00E0:  DATA 0D,0A
00E2:  DATA 43,72
00E4:  DATA 65,61
00E6:  DATA 74,65
00E8:  DATA 64,3A
00EA:  DATA 20,00
00EC:  DATA 0D,0A
00EE:  DATA 4D,6F
00F0:  DATA 64,69
00F2:  DATA 66,69
00F4:  DATA 65,64
00F6:  DATA 3A,20
00F8:  DATA 00,00
00FA:  DATA 0D,0A
00FC:  DATA 53,74
00FE:  DATA 61,72
0100:  DATA 74,69
0102:  DATA 6E,67
0104:  DATA 20,63
0106:  DATA 6C,75
0108:  DATA 73,74
010A:  DATA 65,72
010C:  DATA 3A,20
010E:  DATA 25,6C
0110:  DATA 58,00
0112:  DATA 0D,0A
0114:  DATA 53,74
0116:  DATA 61,72
0118:  DATA 74,69
011A:  DATA 6E,67
011C:  DATA 20,61
011E:  DATA 64,64
0120:  DATA 72,65
0122:  DATA 73,73
0124:  DATA 3A,20
0126:  DATA 25,6C
0128:  DATA 58,00
012A:  DATA 0D,0A
012C:  DATA 53,69
012E:  DATA 7A,65
0130:  DATA 3A,20
0132:  DATA 25,6C
0134:  DATA 75,20
0136:  DATA 42,79
0138:  DATA 74,65
013A:  DATA 73,0D
013C:  DATA 0A,00
013E:  DATA 0D,0A
0140:  DATA 0A,49
0142:  DATA 6E,69
0144:  DATA 74,69
0146:  DATA 61,6C
0148:  DATA 69,7A
014A:  DATA 65,20
014C:  DATA 46,41
014E:  DATA 54,20
0150:  DATA 6C,69
0152:  DATA 62,72
0154:  DATA 61,72
0156:  DATA 79,20
0158:  DATA 2E,2E
015A:  DATA 2E,20
015C:  DATA 00,00
015E:  DATA 45,72
0160:  DATA 72,6F
0162:  DATA 72,20
0164:  DATA 69,6E
0166:  DATA 69,74
0168:  DATA 69,61
016A:  DATA 6C,69
016C:  DATA 7A,69
016E:  DATA 6E,67
0170:  DATA 20,46
0172:  DATA 41,54
0174:  DATA 20,6C
0176:  DATA 69,62
0178:  DATA 72,61
017A:  DATA 72,79
017C:  DATA 21,0D
017E:  DATA 0A,00
0180:  DATA 46,41
0182:  DATA 54,20
0184:  DATA 4C,69
0186:  DATA 62,72
0188:  DATA 61,72
018A:  DATA 79,20
018C:  DATA 69,6E
018E:  DATA 69,74
0190:  DATA 69,61
0192:  DATA 6C,69
0194:  DATA 7A,65
0196:  DATA 64,20
0198:  DATA 2E,2E
019A:  DATA 2E,20
019C:  DATA 00,00
019E:  DATA 43,61
01A0:  DATA 72,64
01A2:  DATA 20,54
01A4:  DATA 79,70
01A6:  DATA 65,3A
01A8:  DATA 20,00
01AA:  DATA 4D,4D
01AC:  DATA 43,20
01AE:  DATA 0D,0A
01B0:  DATA 00,00
01B2:  DATA 53,44
01B4:  DATA 53,43
01B6:  DATA 20,0D
01B8:  DATA 0A,00
01BA:  DATA 53,44
01BC:  DATA 48,43
01BE:  DATA 20,0D
01C0:  DATA 0A,00
01C2:  DATA 43,72
01C4:  DATA 65,61
01C6:  DATA 74,65
01C8:  DATA 20,27
01CA:  DATA 44,61
01CC:  DATA 74,6F
01CE:  DATA 73,2E
01D0:  DATA 74,78
01D2:  DATA 74,27
01D4:  DATA 20,66
01D6:  DATA 69,6C
01D8:  DATA 65,20
01DA:  DATA 2D,2D
01DC:  DATA 2D,3E
01DE:  DATA 20,00
01E0:  DATA 4F,4B
01E2:  DATA 20,0D
01E4:  DATA 0A,00
01E6:  DATA 65,72
01E8:  DATA 72,6F
01EA:  DATA 72,20
01EC:  DATA 63,72
01EE:  DATA 65,61
01F0:  DATA 74,69
01F2:  DATA 6E,67
01F4:  DATA 20,66
01F6:  DATA 69,6C
01F8:  DATA 65,20
01FA:  DATA 0D,0A
01FC:  DATA 00,00
01FE:  DATA 65,6C
0200:  DATA 69,6D
0202:  DATA 69,6E
0204:  DATA 61,74
0206:  DATA 69,6E
0208:  DATA 67,20
020A:  DATA 27,44
020C:  DATA 61,74
020E:  DATA 6F,73
0210:  DATA 2E,74
0212:  DATA 78,74
0214:  DATA 27,20
0216:  DATA 66,69
0218:  DATA 6C,65
021A:  DATA 20,2D
021C:  DATA 2D,2D
021E:  DATA 3E,20
0220:  DATA 00,00
0222:  DATA 4F,4B
0224:  DATA 20,0D
0226:  DATA 0A,00
0228:  DATA 65,72
022A:  DATA 72,6F
022C:  DATA 72,20
022E:  DATA 65,6C
0230:  DATA 69,6D
0232:  DATA 69,6E
0234:  DATA 61,74
0236:  DATA 69,6E
0238:  DATA 67,20
023A:  DATA 66,69
023C:  DATA 6C,65
023E:  DATA 20,0D
0240:  DATA 0A,00
0242:  DATA 20,20
0244:  DATA 65,72
0246:  DATA 72,6F
0248:  DATA 72,20
024A:  DATA 6F,70
024C:  DATA 65,6E
024E:  DATA 69,6E
0250:  DATA 67,20
0252:  DATA 66,69
0254:  DATA 6C,65
0256:  DATA 20,0D
0258:  DATA 0A,00
025A:  DATA 20,20
025C:  DATA 77,72
025E:  DATA 69,74
0260:  DATA 69,6E
0262:  DATA 67,20
0264:  DATA 65,72
0266:  DATA 72,6F
0268:  DATA 72,20
026A:  DATA 0D,0A
026C:  DATA 00,00
026E:  DATA 20,2D
0270:  DATA 2D,2D
0272:  DATA 3E,20
0274:  DATA 77,72
0276:  DATA 69,74
0278:  DATA 69,6E
027A:  DATA 67,20
027C:  DATA 65,72
027E:  DATA 72,6F
0280:  DATA 72,20
0282:  DATA 0D,0A
0284:  DATA 00,00
0286:  DATA 20,20
0288:  DATA 63,6C
028A:  DATA 6F,73
028C:  DATA 69,6E
028E:  DATA 67,20
0290:  DATA 65,72
0292:  DATA 72,6F
0294:  DATA 72,20
0296:  DATA 0D,0A
0298:  DATA 00,00
029A:  DATA 52,65
029C:  DATA 61,64
029E:  DATA 69,6E
02A0:  DATA 67,20
02A2:  DATA 27,44
02A4:  DATA 61,74
02A6:  DATA 6F,73
02A8:  DATA 2E,74
02AA:  DATA 78,74
02AC:  DATA 27,20
02AE:  DATA 66,69
02B0:  DATA 6C,65
02B2:  DATA 3A,20
02B4:  DATA 0D,0A
02B6:  DATA 00,00
02B8:  DATA 0D,0A
02BA:  DATA 0A,00
02BC:  DATA 54,69
02BE:  DATA 6D,65
02C0:  DATA 20,6F
02C2:  DATA 75,74
02C4:  DATA 21,0D
02C6:  DATA 0A,00
02C8:  DATA 43,68
02CA:  DATA 65,63
02CC:  DATA 6B,73
02CE:  DATA 75,6D
02D0:  DATA 20,45
02D2:  DATA 72,72
02D4:  DATA 6F,72
02D6:  DATA 21,0D
02D8:  DATA 0A,00
02DA:  DATA 4E,6F
02DC:  DATA 20,72
02DE:  DATA 65,73
02E0:  DATA 70,6F
02E2:  DATA 6E,73
02E4:  DATA 65,20
02E6:  DATA 66,72
02E8:  DATA 6F,6D
02EA:  DATA 20,74
02EC:  DATA 68,65
02EE:  DATA 20,73
02F0:  DATA 65,6E
02F2:  DATA 73,6F
02F4:  DATA 72,0D
02F6:  DATA 0A,00
02F8:  DATA 54,49
02FA:  DATA 4D,45
02FC:  DATA 3A,20
02FE:  DATA 25,30
0300:  DATA 32,75
0302:  DATA 3A,25
0304:  DATA 30,32
0306:  DATA 75,3A
0308:  DATA 25,30
030A:  DATA 32,75
030C:  DATA 00,00
030E:  DATA 20,44
0310:  DATA 41,54
0312:  DATA 45,3A
0314:  DATA 20,25
0316:  DATA 30,32
0318:  DATA 75,2F
031A:  DATA 25,30
031C:  DATA 32,75
031E:  DATA 2F,32
0320:  DATA 30,25
0322:  DATA 30,32
0324:  DATA 75,0D
0326:  DATA 0A,00
0328:  DATA 48,75
032A:  DATA 6D,65
032C:  DATA 64,61
032E:  DATA 64,3A
0330:  DATA 20,25
0332:  DATA 30,2E
0334:  DATA 31,66
0336:  DATA 0D,0A
0338:  DATA 00,00
033A:  DATA 54,65
033C:  DATA 6D,70
033E:  DATA 65,72
0340:  DATA 61,74
0342:  DATA 75,72
0344:  DATA 61,3A
0346:  DATA 20,25
0348:  DATA 2E,33
034A:  DATA 67,0D
034C:  DATA 0A,50
034E:  DATA 72,65
0350:  DATA 73,69
0352:  DATA 6F,6E
0354:  DATA 3A,20
0356:  DATA 25,2E
0358:  DATA 33,67
035A:  DATA 0D,0A
035C:  DATA 00,00
035E:  DATA 4C,75
0360:  DATA 7A,3A
0362:  DATA 20,25
0364:  DATA 75,20
0366:  DATA 20,56
0368:  DATA 62,61
036A:  DATA 74,3A
036C:  DATA 20,25
036E:  DATA 66,00
0370:  DATA 25,30
0372:  DATA 32,75
0374:  DATA 2F,25
0376:  DATA 30,32
0378:  DATA 75,2F
037A:  DATA 32,30
037C:  DATA 25,30
037E:  DATA 32,75
0380:  DATA 20,25
0382:  DATA 30,32
0384:  DATA 75,3A
0386:  DATA 25,30
0388:  DATA 32,75
038A:  DATA 20,7C
038C:  DATA 20,25
038E:  DATA 30,2E
0390:  DATA 31,66
0392:  DATA 20,7C
0394:  DATA 20,25
0396:  DATA 30,2E
0398:  DATA 31,66
039A:  DATA 20,7C
039C:  DATA 20,25
039E:  DATA 30,2E
03A0:  DATA 31,66
03A2:  DATA 20,00
03A4:  DATA 20,20
03A6:  DATA 77,72
03A8:  DATA 69,74
03AA:  DATA 69,6E
03AC:  DATA 67,20
03AE:  DATA 65,72
03B0:  DATA 72,6F
03B2:  DATA 72,20
03B4:  DATA 0D,0A
03B6:  DATA 00,00
03B8:  DATA 7C,20
03BA:  DATA 25,75
03BC:  DATA 20,7C
03BE:  DATA 20,25
03C0:  DATA 66,20
03C2:  DATA 0D,0A
03C4:  DATA 00,00
03C6:  DATA 20,20
03C8:  DATA 77,72
03CA:  DATA 69,74
03CC:  DATA 69,6E
03CE:  DATA 67,20
03D0:  DATA 65,72
03D2:  DATA 72,6F
03D4:  DATA 72,20
03D6:  DATA 0D,0A
03D8:  DATA 00,00
03DA:  DATA 41,54
03DC:  DATA 2B,43
03DE:  DATA 49,50
03E0:  DATA 53,54
03E2:  DATA 41,52
03E4:  DATA 54,3D
03E6:  DATA 25,63
03E8:  DATA 54,43
03EA:  DATA 50,25
03EC:  DATA 63,2C
03EE:  DATA 25,63
03F0:  DATA 61,70
03F2:  DATA 69,2E
03F4:  DATA 74,68
03F6:  DATA 69,6E
03F8:  DATA 67,73
03FA:  DATA 70,65
03FC:  DATA 61,6B
03FE:  DATA 2E,63
0400:  DATA 6F,6D
0402:  DATA 25,63
0404:  DATA 2C,38
0406:  DATA 30,0D
0408:  DATA 0A,00
040A:  DATA 41,54
040C:  DATA 2B,43
040E:  DATA 49,50
0410:  DATA 4D,4F
0412:  DATA 44,45
0414:  DATA 3D,31
0416:  DATA 0D,0A
0418:  DATA 00,00
041A:  DATA 41,54
041C:  DATA 2B,43
041E:  DATA 49,50
0420:  DATA 53,45
0422:  DATA 4E,44
0424:  DATA 0D,0A
0426:  DATA 00,00
0428:  DATA 47,45
042A:  DATA 54,20
042C:  DATA 68,74
042E:  DATA 74,70
0430:  DATA 73,3A
0432:  DATA 2F,2F
0434:  DATA 61,70
0436:  DATA 69,2E
0438:  DATA 74,68
043A:  DATA 69,6E
043C:  DATA 67,73
043E:  DATA 70,65
0440:  DATA 61,6B
0442:  DATA 2E,63
0444:  DATA 6F,6D
0446:  DATA 2F,75
0448:  DATA 70,64
044A:  DATA 61,74
044C:  DATA 65,3F
044E:  DATA 61,70
0450:  DATA 69,5F
0452:  DATA 6B,65
0454:  DATA 79,3D
0456:  DATA 4A,34
0458:  DATA 31,41
045A:  DATA 48,31
045C:  DATA 5A,59
045E:  DATA 37,39
0460:  DATA 53,51
0462:  DATA 39,36
0464:  DATA 59,39
0466:  DATA 00,00
0468:  DATA 26,66
046A:  DATA 69,65
046C:  DATA 6C,64
046E:  DATA 31,3D
0470:  DATA 25,75
0472:  DATA 26,66
0474:  DATA 69,65
0476:  DATA 6C,64
0478:  DATA 32,3D
047A:  DATA 25,75
047C:  DATA 26,66
047E:  DATA 69,65
0480:  DATA 6C,64
0482:  DATA 33,3D
0484:  DATA 25,6C
0486:  DATA 75,26
0488:  DATA 66,69
048A:  DATA 65,6C
048C:  DATA 64,34
048E:  DATA 3D,25
0490:  DATA 75,0D
0492:  DATA 0A,00
0494:  DATA 41,54
0496:  DATA 2B,47
0498:  DATA 53,4C
049A:  DATA 50,3D
049C:  DATA 31,0D
049E:  DATA 0A,00
04A0:  DATA 41,54
04A2:  DATA 2B,47
04A4:  DATA 53,4C
04A6:  DATA 50,3D
04A8:  DATA 31,0D
04AA:  DATA 0A,00
*
0694:  TBLRD*+
0696:  MOVFF  FF6,33A
069A:  MOVFF  FF7,33B
069E:  MOVFF  FF5,345
06A2:  RCALL  0650
06A4:  MOVFF  33A,FF6
06A8:  MOVFF  33B,FF7
06AC:  MOVLB  3
06AE:  DECFSZ x39,F
06B0:  BRA    06B4
06B2:  BRA    06B8
06B4:  MOVLB  0
06B6:  BRA    0694
06B8:  MOVLB  0
06BA:  RETURN 0
06BC:  MOVLB  3
06BE:  MOVF   x3E,W
06C0:  CLRF   01
06C2:  SUBWF  x3D,W
06C4:  BC    06CC
06C6:  MOVFF  33D,00
06CA:  BRA    06E4
06CC:  CLRF   00
06CE:  MOVLW  08
06D0:  MOVWF  x3F
06D2:  RLCF   x3D,F
06D4:  RLCF   00,F
06D6:  MOVF   x3E,W
06D8:  SUBWF  00,W
06DA:  BTFSC  FD8.0
06DC:  MOVWF  00
06DE:  RLCF   01,F
06E0:  DECFSZ x3F,F
06E2:  BRA    06D2
06E4:  MOVLB  0
06E6:  RETURN 0
06E8:  MOVF   01,W
06EA:  MOVFF  339,33D
06EE:  MOVLW  64
06F0:  MOVLB  3
06F2:  MOVWF  x3E
06F4:  MOVLB  0
06F6:  RCALL  06BC
06F8:  MOVFF  00,339
06FC:  MOVF   01,W
06FE:  MOVLW  30
0700:  BNZ   0712
0702:  MOVLB  3
0704:  BTFSS  x3A.1
0706:  BRA    0726
0708:  BTFSC  x3A.3
070A:  BRA    0726
070C:  BTFSC  x3A.4
070E:  MOVLW  20
0710:  BRA    071A
0712:  MOVLB  3
0714:  BCF    x3A.3
0716:  BCF    x3A.4
0718:  BSF    x3A.0
071A:  ADDWF  01,F
071C:  MOVFF  01,345
0720:  MOVLB  0
0722:  RCALL  0650
0724:  MOVLB  3
0726:  MOVFF  339,33D
072A:  MOVLW  0A
072C:  MOVWF  x3E
072E:  MOVLB  0
0730:  RCALL  06BC
0732:  MOVFF  00,339
0736:  MOVF   01,W
0738:  MOVLW  30
073A:  BNZ   074C
073C:  MOVLB  3
073E:  BTFSC  x3A.3
0740:  BRA    0756
0742:  BTFSS  x3A.0
0744:  BRA    0756
0746:  BTFSC  x3A.4
0748:  MOVLW  20
074A:  MOVLB  0
074C:  ADDWF  01,F
074E:  MOVFF  01,345
0752:  RCALL  0650
0754:  MOVLB  3
0756:  MOVLW  30
0758:  ADDWF  x39,F
075A:  MOVFF  339,345
075E:  MOVLB  0
0760:  RCALL  0650
0762:  RETURN 0
*
0994:  TBLRD*+
0996:  MOVF   FF5,F
0998:  BZ    09B2
099A:  MOVFF  FF6,343
099E:  MOVFF  FF7,344
09A2:  MOVFF  FF5,345
09A6:  RCALL  0650
09A8:  MOVFF  343,FF6
09AC:  MOVFF  344,FF7
09B0:  BRA    0994
09B2:  RETURN 0
09B4:  MOVLB  3
09B6:  MOVF   x38,W
09B8:  XORWF  x3A,W
09BA:  ANDLW  80
09BC:  MOVWF  x3C
09BE:  BTFSS  x38.7
09C0:  BRA    09CC
09C2:  COMF   x37,F
09C4:  COMF   x38,F
09C6:  INCF   x37,F
09C8:  BTFSC  FD8.2
09CA:  INCF   x38,F
09CC:  BTFSS  x3A.7
09CE:  BRA    09DA
09D0:  COMF   x39,F
09D2:  COMF   x3A,F
09D4:  INCF   x39,F
09D6:  BTFSC  FD8.2
09D8:  INCF   x3A,F
09DA:  MOVF   x37,W
09DC:  MULWF  x39
09DE:  MOVFF  FF3,01
09E2:  MOVFF  FF4,00
09E6:  MULWF  x3A
09E8:  MOVF   FF3,W
09EA:  ADDWF  00,F
09EC:  MOVF   x38,W
09EE:  MULWF  x39
09F0:  MOVF   FF3,W
09F2:  ADDWFC 00,W
09F4:  MOVWF  02
09F6:  BTFSS  x3C.7
09F8:  BRA    0A04
09FA:  COMF   01,F
09FC:  COMF   02,F
09FE:  INCF   01,F
0A00:  BTFSC  FD8.2
0A02:  INCF   02,F
0A04:  MOVLB  0
0A06:  GOTO   0C58 (RETURN)
0A0A:  MOVLW  8E
0A0C:  MOVWF  00
0A0E:  MOVFF  33E,01
0A12:  MOVFF  33D,02
0A16:  CLRF   03
0A18:  MOVF   01,F
0A1A:  BNZ   0A2E
0A1C:  MOVFF  02,01
0A20:  CLRF   02
0A22:  MOVLW  08
0A24:  SUBWF  00,F
0A26:  MOVF   01,F
0A28:  BNZ   0A2E
0A2A:  CLRF   00
0A2C:  BRA    0A3E
0A2E:  BCF    FD8.0
0A30:  BTFSC  01.7
0A32:  BRA    0A3C
0A34:  RLCF   02,F
0A36:  RLCF   01,F
0A38:  DECF   00,F
0A3A:  BRA    0A2E
0A3C:  BCF    01.7
0A3E:  RETURN 0
0A40:  MOVLB  3
0A42:  MOVF   x52,W
0A44:  BTFSC  FD8.2
0A46:  BRA    0B92
0A48:  MOVWF  x5E
0A4A:  MOVF   x56,W
0A4C:  BTFSC  FD8.2
0A4E:  BRA    0B92
0A50:  SUBWF  x5E,F
0A52:  BNC   0A5E
0A54:  MOVLW  7F
0A56:  ADDWF  x5E,F
0A58:  BTFSC  FD8.0
0A5A:  BRA    0B92
0A5C:  BRA    0A6A
0A5E:  MOVLW  81
0A60:  SUBWF  x5E,F
0A62:  BTFSS  FD8.0
0A64:  BRA    0B92
0A66:  BTFSC  FD8.2
0A68:  BRA    0B92
0A6A:  MOVFF  35E,00
0A6E:  CLRF   01
0A70:  CLRF   02
0A72:  CLRF   03
0A74:  CLRF   x5D
0A76:  MOVFF  353,35C
0A7A:  BSF    x5C.7
0A7C:  MOVFF  354,35B
0A80:  MOVFF  355,35A
0A84:  MOVLW  19
0A86:  MOVWF  x5E
0A88:  MOVF   x59,W
0A8A:  SUBWF  x5A,F
0A8C:  BC    0AA8
0A8E:  MOVLW  01
0A90:  SUBWF  x5B,F
0A92:  BC    0AA8
0A94:  SUBWF  x5C,F
0A96:  BC    0AA8
0A98:  SUBWF  x5D,F
0A9A:  BC    0AA8
0A9C:  INCF   x5D,F
0A9E:  INCF   x5C,F
0AA0:  INCF   x5B,F
0AA2:  MOVF   x59,W
0AA4:  ADDWF  x5A,F
0AA6:  BRA    0AF8
0AA8:  MOVF   x58,W
0AAA:  SUBWF  x5B,F
0AAC:  BC    0AD2
0AAE:  MOVLW  01
0AB0:  SUBWF  x5C,F
0AB2:  BC    0AD2
0AB4:  SUBWF  x5D,F
0AB6:  BC    0AD2
0AB8:  INCF   x5D,F
0ABA:  INCF   x5C,F
0ABC:  MOVF   x58,W
0ABE:  ADDWF  x5B,F
0AC0:  MOVF   x59,W
0AC2:  ADDWF  x5A,F
0AC4:  BNC   0AF8
0AC6:  INCF   x5B,F
0AC8:  BNZ   0AF8
0ACA:  INCF   x5C,F
0ACC:  BNZ   0AF8
0ACE:  INCF   x5D,F
0AD0:  BRA    0AF8
0AD2:  MOVF   x57,W
0AD4:  IORLW  80
0AD6:  SUBWF  x5C,F
0AD8:  BC    0AF6
0ADA:  MOVLW  01
0ADC:  SUBWF  x5D,F
0ADE:  BC    0AF6
0AE0:  INCF   x5D,F
0AE2:  MOVF   x57,W
0AE4:  IORLW  80
0AE6:  ADDWF  x5C,F
0AE8:  MOVF   x58,W
0AEA:  ADDWF  x5B,F
0AEC:  BNC   0AC0
0AEE:  INCF   x5C,F
0AF0:  BNZ   0AC0
0AF2:  INCF   x5D,F
0AF4:  BRA    0AC0
0AF6:  BSF    03.0
0AF8:  DECFSZ x5E,F
0AFA:  BRA    0AFE
0AFC:  BRA    0B14
0AFE:  BCF    FD8.0
0B00:  RLCF   x5A,F
0B02:  RLCF   x5B,F
0B04:  RLCF   x5C,F
0B06:  RLCF   x5D,F
0B08:  BCF    FD8.0
0B0A:  RLCF   03,F
0B0C:  RLCF   02,F
0B0E:  RLCF   01,F
0B10:  RLCF   x5F,F
0B12:  BRA    0A88
0B14:  BTFSS  x5F.0
0B16:  BRA    0B24
0B18:  BCF    FD8.0
0B1A:  RRCF   01,F
0B1C:  RRCF   02,F
0B1E:  RRCF   03,F
0B20:  RRCF   x5F,F
0B22:  BRA    0B28
0B24:  DECF   00,F
0B26:  BZ    0B92
0B28:  BTFSC  x5F.7
0B2A:  BRA    0B68
0B2C:  BCF    FD8.0
0B2E:  RLCF   x5A,F
0B30:  RLCF   x5B,F
0B32:  RLCF   x5C,F
0B34:  RLCF   x5D,F
0B36:  MOVF   x59,W
0B38:  SUBWF  x5A,F
0B3A:  BC    0B4A
0B3C:  MOVLW  01
0B3E:  SUBWF  x5B,F
0B40:  BC    0B4A
0B42:  SUBWF  x5C,F
0B44:  BC    0B4A
0B46:  SUBWF  x5D,F
0B48:  BNC   0B7E
0B4A:  MOVF   x58,W
0B4C:  SUBWF  x5B,F
0B4E:  BC    0B5A
0B50:  MOVLW  01
0B52:  SUBWF  x5C,F
0B54:  BC    0B5A
0B56:  SUBWF  x5D,F
0B58:  BNC   0B7E
0B5A:  MOVF   x57,W
0B5C:  IORLW  80
0B5E:  SUBWF  x5C,F
0B60:  BC    0B68
0B62:  MOVLW  01
0B64:  SUBWF  x5D,F
0B66:  BNC   0B7E
0B68:  INCF   03,F
0B6A:  BNZ   0B7E
0B6C:  INCF   02,F
0B6E:  BNZ   0B7E
0B70:  INCF   01,F
0B72:  BNZ   0B7E
0B74:  INCF   00,F
0B76:  BZ    0B92
0B78:  RRCF   01,F
0B7A:  RRCF   02,F
0B7C:  RRCF   03,F
0B7E:  MOVFF  353,35E
0B82:  MOVF   x57,W
0B84:  XORWF  x5E,F
0B86:  BTFSS  x5E.7
0B88:  BRA    0B8E
0B8A:  BSF    01.7
0B8C:  BRA    0B9A
0B8E:  BCF    01.7
0B90:  BRA    0B9A
0B92:  CLRF   00
0B94:  CLRF   01
0B96:  CLRF   02
0B98:  CLRF   03
0B9A:  MOVLB  0
0B9C:  RETURN 0
*
0D56:  MOVLB  3
0D58:  MOVF   x52,W
0D5A:  BTFSC  FD8.2
0D5C:  BRA    0E40
0D5E:  MOVWF  00
0D60:  MOVF   x56,W
0D62:  BTFSC  FD8.2
0D64:  BRA    0E40
0D66:  ADDWF  00,F
0D68:  BNC   0D72
0D6A:  MOVLW  81
0D6C:  ADDWF  00,F
0D6E:  BC    0E40
0D70:  BRA    0D7A
0D72:  MOVLW  7F
0D74:  SUBWF  00,F
0D76:  BNC   0E40
0D78:  BZ    0E40
0D7A:  MOVFF  353,35A
0D7E:  MOVF   x57,W
0D80:  XORWF  x5A,F
0D82:  BSF    x53.7
0D84:  BSF    x57.7
0D86:  MOVF   x55,W
0D88:  MULWF  x59
0D8A:  MOVFF  FF4,35C
0D8E:  MOVF   x54,W
0D90:  MULWF  x58
0D92:  MOVFF  FF4,03
0D96:  MOVFF  FF3,35B
0D9A:  MULWF  x59
0D9C:  MOVF   FF3,W
0D9E:  ADDWF  x5C,F
0DA0:  MOVF   FF4,W
0DA2:  ADDWFC x5B,F
0DA4:  MOVLW  00
0DA6:  ADDWFC 03,F
0DA8:  MOVF   x55,W
0DAA:  MULWF  x58
0DAC:  MOVF   FF3,W
0DAE:  ADDWF  x5C,F
0DB0:  MOVF   FF4,W
0DB2:  ADDWFC x5B,F
0DB4:  MOVLW  00
0DB6:  CLRF   02
0DB8:  ADDWFC 03,F
0DBA:  ADDWFC 02,F
0DBC:  MOVF   x53,W
0DBE:  MULWF  x59
0DC0:  MOVF   FF3,W
0DC2:  ADDWF  x5B,F
0DC4:  MOVF   FF4,W
0DC6:  ADDWFC 03,F
0DC8:  MOVLW  00
0DCA:  ADDWFC 02,F
0DCC:  MOVF   x53,W
0DCE:  MULWF  x58
0DD0:  MOVF   FF3,W
0DD2:  ADDWF  03,F
0DD4:  MOVF   FF4,W
0DD6:  ADDWFC 02,F
0DD8:  MOVLW  00
0DDA:  CLRF   01
0DDC:  ADDWFC 01,F
0DDE:  MOVF   x55,W
0DE0:  MULWF  x57
0DE2:  MOVF   FF3,W
0DE4:  ADDWF  x5B,F
0DE6:  MOVF   FF4,W
0DE8:  ADDWFC 03,F
0DEA:  MOVLW  00
0DEC:  ADDWFC 02,F
0DEE:  ADDWFC 01,F
0DF0:  MOVF   x54,W
0DF2:  MULWF  x57
0DF4:  MOVF   FF3,W
0DF6:  ADDWF  03,F
0DF8:  MOVF   FF4,W
0DFA:  ADDWFC 02,F
0DFC:  MOVLW  00
0DFE:  ADDWFC 01,F
0E00:  MOVF   x53,W
0E02:  MULWF  x57
0E04:  MOVF   FF3,W
0E06:  ADDWF  02,F
0E08:  MOVF   FF4,W
0E0A:  ADDWFC 01,F
0E0C:  INCF   00,F
0E0E:  BTFSC  01.7
0E10:  BRA    0E1C
0E12:  RLCF   x5B,F
0E14:  RLCF   03,F
0E16:  RLCF   02,F
0E18:  RLCF   01,F
0E1A:  DECF   00,F
0E1C:  MOVLW  00
0E1E:  BTFSS  x5B.7
0E20:  BRA    0E36
0E22:  INCF   03,F
0E24:  ADDWFC 02,F
0E26:  ADDWFC 01,F
0E28:  MOVF   01,W
0E2A:  BNZ   0E36
0E2C:  MOVF   02,W
0E2E:  BNZ   0E36
0E30:  MOVF   03,W
0E32:  BNZ   0E36
0E34:  INCF   00,F
0E36:  BTFSC  x5A.7
0E38:  BSF    01.7
0E3A:  BTFSS  x5A.7
0E3C:  BCF    01.7
0E3E:  BRA    0E48
0E40:  CLRF   00
0E42:  CLRF   01
0E44:  CLRF   02
0E46:  CLRF   03
0E48:  MOVLB  0
0E4A:  RETURN 0
0E4C:  MOVLB  3
0E4E:  MOVF   x48,W
0E50:  SUBLW  B6
0E52:  MOVWF  x48
0E54:  CLRF   03
0E56:  MOVFF  349,34C
0E5A:  BSF    x49.7
0E5C:  BCF    FD8.0
0E5E:  RRCF   x49,F
0E60:  RRCF   x4A,F
0E62:  RRCF   x4B,F
0E64:  RRCF   03,F
0E66:  RRCF   02,F
0E68:  RRCF   01,F
0E6A:  RRCF   00,F
0E6C:  DECFSZ x48,F
0E6E:  BRA    0E5C
0E70:  BTFSS  x4C.7
0E72:  BRA    0E8A
0E74:  COMF   00,F
0E76:  COMF   01,F
0E78:  COMF   02,F
0E7A:  COMF   03,F
0E7C:  INCF   00,F
0E7E:  BTFSC  FD8.2
0E80:  INCF   01,F
0E82:  BTFSC  FD8.2
0E84:  INCF   02,F
0E86:  BTFSC  FD8.2
0E88:  INCF   03,F
0E8A:  MOVLB  0
0E8C:  RETURN 0
0E8E:  BTFSC  FD8.1
0E90:  BRA    0E98
0E92:  MOVLW  04
0E94:  MOVWF  FEA
0E96:  MOVWF  FE9
0E98:  CLRF   00
0E9A:  CLRF   01
0E9C:  CLRF   02
0E9E:  CLRF   03
0EA0:  MOVLB  4
0EA2:  CLRF   x04
0EA4:  CLRF   x05
0EA6:  CLRF   x06
0EA8:  CLRF   x07
0EAA:  MOVF   x03,W
0EAC:  IORWF  x02,W
0EAE:  IORWF  x01,W
0EB0:  IORWF  x00,W
0EB2:  BZ    0F10
0EB4:  MOVLW  20
0EB6:  MOVWF  x08
0EB8:  BCF    FD8.0
0EBA:  MOVLB  3
0EBC:  RLCF   xFC,F
0EBE:  RLCF   xFD,F
0EC0:  RLCF   xFE,F
0EC2:  RLCF   xFF,F
0EC4:  MOVLB  4
0EC6:  RLCF   x04,F
0EC8:  RLCF   x05,F
0ECA:  RLCF   x06,F
0ECC:  RLCF   x07,F
0ECE:  MOVF   x03,W
0ED0:  SUBWF  x07,W
0ED2:  BNZ   0EE4
0ED4:  MOVF   x02,W
0ED6:  SUBWF  x06,W
0ED8:  BNZ   0EE4
0EDA:  MOVF   x01,W
0EDC:  SUBWF  x05,W
0EDE:  BNZ   0EE4
0EE0:  MOVF   x00,W
0EE2:  SUBWF  x04,W
0EE4:  BNC   0F04
0EE6:  MOVF   x00,W
0EE8:  SUBWF  x04,F
0EEA:  MOVF   x01,W
0EEC:  BTFSS  FD8.0
0EEE:  INCFSZ x01,W
0EF0:  SUBWF  x05,F
0EF2:  MOVF   x02,W
0EF4:  BTFSS  FD8.0
0EF6:  INCFSZ x02,W
0EF8:  SUBWF  x06,F
0EFA:  MOVF   x03,W
0EFC:  BTFSS  FD8.0
0EFE:  INCFSZ x03,W
0F00:  SUBWF  x07,F
0F02:  BSF    FD8.0
0F04:  RLCF   00,F
0F06:  RLCF   01,F
0F08:  RLCF   02,F
0F0A:  RLCF   03,F
0F0C:  DECFSZ x08,F
0F0E:  BRA    0EB8
0F10:  MOVFF  404,FEF
0F14:  MOVFF  405,FEC
0F18:  MOVFF  406,FEC
0F1C:  MOVFF  407,FEC
0F20:  MOVLB  0
0F22:  RETURN 0
0F24:  MOVF   FE9,W
0F26:  MOVLB  3
0F28:  MOVWF  x3B
0F2A:  MOVF   x3A,W
0F2C:  MOVWF  x3D
0F2E:  BZ    0F66
0F30:  MOVFF  339,355
0F34:  MOVFF  338,354
0F38:  MOVFF  337,353
0F3C:  MOVFF  336,352
0F40:  CLRF   x59
0F42:  CLRF   x58
0F44:  MOVLW  20
0F46:  MOVWF  x57
0F48:  MOVLW  82
0F4A:  MOVWF  x56
0F4C:  MOVLB  0
0F4E:  RCALL  0D56
0F50:  MOVFF  03,339
0F54:  MOVFF  02,338
0F58:  MOVFF  01,337
0F5C:  MOVFF  00,336
0F60:  MOVLB  3
0F62:  DECFSZ x3D,F
0F64:  BRA    0F30
0F66:  MOVFF  339,34B
0F6A:  MOVFF  338,34A
0F6E:  MOVFF  337,349
0F72:  MOVFF  336,348
0F76:  MOVLB  0
0F78:  RCALL  0E4C
0F7A:  MOVFF  03,339
0F7E:  MOVFF  02,338
0F82:  MOVFF  01,337
0F86:  MOVFF  00,336
0F8A:  MOVLB  3
0F8C:  BTFSS  x39.7
0F8E:  BRA    0FAA
0F90:  DECF   x3B,F
0F92:  BSF    x3B.5
0F94:  COMF   x36,F
0F96:  COMF   x37,F
0F98:  COMF   x38,F
0F9A:  COMF   x39,F
0F9C:  INCF   x36,F
0F9E:  BTFSC  FD8.2
0FA0:  INCF   x37,F
0FA2:  BTFSC  FD8.2
0FA4:  INCF   x38,F
0FA6:  BTFSC  FD8.2
0FA8:  INCF   x39,F
0FAA:  MOVLW  3B
0FAC:  MOVWF  x42
0FAE:  MOVLW  9A
0FB0:  MOVWF  x41
0FB2:  MOVLW  CA
0FB4:  MOVWF  x40
0FB6:  CLRF   x3F
0FB8:  MOVLW  0A
0FBA:  MOVWF  x3D
0FBC:  MOVF   x3A,W
0FBE:  BTFSC  FD8.2
0FC0:  INCF   x3B,F
0FC2:  BSF    FD8.1
0FC4:  MOVLW  03
0FC6:  MOVWF  FEA
0FC8:  MOVLW  36
0FCA:  MOVWF  FE9
0FCC:  MOVFF  339,3FF
0FD0:  MOVFF  338,3FE
0FD4:  MOVFF  337,3FD
0FD8:  MOVFF  336,3FC
0FDC:  MOVFF  342,403
0FE0:  MOVFF  341,402
0FE4:  MOVFF  340,401
0FE8:  MOVFF  33F,400
0FEC:  MOVLB  0
0FEE:  RCALL  0E8E
0FF0:  MOVF   01,W
0FF2:  MOVF   00,F
0FF4:  BNZ   101C
0FF6:  MOVLB  3
0FF8:  INCF   x3A,W
0FFA:  SUBWF  x3D,W
0FFC:  BTFSS  FD8.2
0FFE:  BRA    1004
1000:  MOVLB  0
1002:  BRA    101C
1004:  MOVF   x3B,W
1006:  BZ    1022
1008:  ANDLW  0F
100A:  SUBWF  x3D,W
100C:  BZ    1010
100E:  BC    1098
1010:  BTFSC  x3B.7
1012:  BRA    1098
1014:  BTFSC  x3B.6
1016:  BRA    1022
1018:  MOVLW  20
101A:  BRA    108A
101C:  MOVLW  20
101E:  MOVLB  3
1020:  ANDWF  x3B,F
1022:  BTFSS  x3B.5
1024:  BRA    1044
1026:  BCF    x3B.5
1028:  MOVF   x3A,W
102A:  BTFSS  FD8.2
102C:  DECF   x3B,F
102E:  MOVF   00,W
1030:  MOVWF  x3B
1032:  MOVLW  2D
1034:  MOVWF  x45
1036:  MOVLB  0
1038:  CALL   0650
103C:  MOVLB  3
103E:  MOVF   x3B,W
1040:  MOVWF  00
1042:  CLRF   x3B
1044:  MOVF   x3A,W
1046:  SUBWF  x3D,W
1048:  BNZ   1064
104A:  MOVF   00,W
104C:  MOVWF  x3B
104E:  MOVLW  2E
1050:  MOVWF  x45
1052:  MOVLB  0
1054:  CALL   0650
1058:  MOVLB  3
105A:  MOVF   x3B,W
105C:  MOVWF  00
105E:  MOVLW  20
1060:  ANDWF  x3B,F
1062:  MOVLW  00
1064:  MOVLW  30
1066:  BTFSS  x3B.5
1068:  BRA    108A
106A:  BCF    x3B.5
106C:  MOVF   x3A,W
106E:  BTFSS  FD8.2
1070:  DECF   x3B,F
1072:  MOVF   00,W
1074:  MOVWF  x3B
1076:  MOVLW  2D
1078:  MOVWF  x45
107A:  MOVLB  0
107C:  CALL   0650
1080:  MOVLB  3
1082:  MOVF   x3B,W
1084:  MOVWF  00
1086:  CLRF   x3B
1088:  MOVLW  30
108A:  ADDWF  00,F
108C:  MOVFF  00,345
1090:  MOVLB  0
1092:  CALL   0650
1096:  MOVLB  3
1098:  BCF    FD8.1
109A:  MOVFF  342,3FF
109E:  MOVFF  341,3FE
10A2:  MOVFF  340,3FD
10A6:  MOVFF  33F,3FC
10AA:  MOVLB  4
10AC:  CLRF   x03
10AE:  CLRF   x02
10B0:  CLRF   x01
10B2:  MOVLW  0A
10B4:  MOVWF  x00
10B6:  MOVLB  0
10B8:  RCALL  0E8E
10BA:  MOVFF  03,342
10BE:  MOVFF  02,341
10C2:  MOVFF  01,340
10C6:  MOVFF  00,33F
10CA:  MOVLB  3
10CC:  DECFSZ x3D,F
10CE:  BRA    0FC2
10D0:  MOVLB  0
10D2:  RETURN 0
*
115C:  MOVLW  8E
115E:  MOVWF  00
1160:  MOVFF  337,01
1164:  MOVFF  336,02
1168:  CLRF   03
116A:  BTFSS  01.7
116C:  BRA    1178
116E:  COMF   01,F
1170:  COMF   02,F
1172:  INCF   02,F
1174:  BNZ   1178
1176:  INCF   01,F
1178:  MOVF   01,F
117A:  BNZ   118E
117C:  MOVFF  02,01
1180:  CLRF   02
1182:  MOVLW  08
1184:  SUBWF  00,F
1186:  MOVF   01,F
1188:  BNZ   118E
118A:  CLRF   00
118C:  BRA    11AA
118E:  BCF    FD8.0
1190:  BTFSC  01.7
1192:  BRA    119C
1194:  RLCF   02,F
1196:  RLCF   01,F
1198:  DECF   00,F
119A:  BRA    118E
119C:  MOVLB  3
119E:  BTFSS  x37.7
11A0:  BRA    11A6
11A2:  MOVLB  0
11A4:  BRA    11AA
11A6:  BCF    01.7
11A8:  MOVLB  0
11AA:  RETURN 0
*
15B8:  MOVLW  8E
15BA:  MOVWF  00
15BC:  MOVLB  3
15BE:  MOVF   x38,W
15C0:  SUBWF  00,F
15C2:  MOVFF  339,02
15C6:  MOVFF  33A,01
15CA:  BSF    02.7
15CC:  MOVF   00,F
15CE:  BZ    15E2
15D0:  BCF    FD8.0
15D2:  MOVF   02,F
15D4:  BNZ   15DA
15D6:  MOVF   01,F
15D8:  BZ    15E2
15DA:  RRCF   02,F
15DC:  RRCF   01,F
15DE:  DECFSZ 00,F
15E0:  BRA    15D0
15E2:  BTFSS  x39.7
15E4:  BRA    15F0
15E6:  COMF   01,F
15E8:  COMF   02,F
15EA:  INCF   01,F
15EC:  BTFSC  FD8.2
15EE:  INCF   02,F
15F0:  MOVLB  0
15F2:  RETURN 0
*
1642:  MOVLW  80
1644:  BTFSS  FD8.1
1646:  BRA    164C
1648:  MOVLB  3
164A:  XORWF  x57,F
164C:  MOVLB  3
164E:  CLRF   x5C
1650:  CLRF   x5D
1652:  MOVFF  353,35B
1656:  MOVF   x57,W
1658:  XORWF  x5B,F
165A:  MOVF   x52,W
165C:  BTFSC  FD8.2
165E:  BRA    181E
1660:  MOVWF  x5A
1662:  MOVWF  00
1664:  MOVF   x56,W
1666:  BTFSC  FD8.2
1668:  BRA    1830
166A:  SUBWF  x5A,F
166C:  BTFSC  FD8.2
166E:  BRA    1776
1670:  BNC   16EE
1672:  MOVFF  357,360
1676:  BSF    x60.7
1678:  MOVFF  358,35F
167C:  MOVFF  359,35E
1680:  CLRF   x5D
1682:  BCF    FD8.0
1684:  RRCF   x60,F
1686:  RRCF   x5F,F
1688:  RRCF   x5E,F
168A:  RRCF   x5D,F
168C:  DECFSZ x5A,F
168E:  BRA    1680
1690:  BTFSS  x5B.7
1692:  BRA    169A
1694:  BSF    x5C.0
1696:  BRA    1858
1698:  BCF    x5C.0
169A:  BCF    x5A.0
169C:  BSF    x5C.4
169E:  MOVLW  03
16A0:  MOVWF  FEA
16A2:  MOVLW  55
16A4:  MOVWF  FE9
16A6:  BRA    187E
16A8:  BCF    x5C.4
16AA:  BTFSC  x5B.7
16AC:  BRA    16C2
16AE:  BTFSS  x5A.0
16B0:  BRA    16D8
16B2:  RRCF   x60,F
16B4:  RRCF   x5F,F
16B6:  RRCF   x5E,F
16B8:  RRCF   x5D,F
16BA:  INCF   00,F
16BC:  BTFSC  FD8.2
16BE:  BRA    184E
16C0:  BRA    16D8
16C2:  BTFSC  x60.7
16C4:  BRA    16DE
16C6:  BCF    FD8.0
16C8:  RLCF   x5D,F
16CA:  RLCF   x5E,F
16CC:  RLCF   x5F,F
16CE:  RLCF   x60,F
16D0:  DECF   00,F
16D2:  BTFSC  FD8.2
16D4:  BRA    184E
16D6:  BRA    16C2
16D8:  BSF    x5C.6
16DA:  BRA    17B6
16DC:  BCF    x5C.6
16DE:  MOVFF  353,35B
16E2:  BTFSS  x53.7
16E4:  BRA    16EA
16E6:  BSF    x60.7
16E8:  BRA    1840
16EA:  BCF    x60.7
16EC:  BRA    1840
16EE:  MOVFF  356,35A
16F2:  MOVFF  356,00
16F6:  MOVF   x52,W
16F8:  SUBWF  x5A,F
16FA:  MOVFF  353,360
16FE:  BSF    x60.7
1700:  MOVFF  354,35F
1704:  MOVFF  355,35E
1708:  CLRF   x5D
170A:  BCF    FD8.0
170C:  RRCF   x60,F
170E:  RRCF   x5F,F
1710:  RRCF   x5E,F
1712:  RRCF   x5D,F
1714:  DECFSZ x5A,F
1716:  BRA    1708
1718:  BTFSS  x5B.7
171A:  BRA    1722
171C:  BSF    x5C.1
171E:  BRA    1858
1720:  BCF    x5C.1
1722:  BCF    x5A.0
1724:  BSF    x5C.5
1726:  MOVLW  03
1728:  MOVWF  FEA
172A:  MOVLW  59
172C:  MOVWF  FE9
172E:  BRA    187E
1730:  BCF    x5C.5
1732:  BTFSC  x5B.7
1734:  BRA    174A
1736:  BTFSS  x5A.0
1738:  BRA    1760
173A:  RRCF   x60,F
173C:  RRCF   x5F,F
173E:  RRCF   x5E,F
1740:  RRCF   x5D,F
1742:  INCF   00,F
1744:  BTFSC  FD8.2
1746:  BRA    184E
1748:  BRA    1760
174A:  BTFSC  x60.7
174C:  BRA    1766
174E:  BCF    FD8.0
1750:  RLCF   x5D,F
1752:  RLCF   x5E,F
1754:  RLCF   x5F,F
1756:  RLCF   x60,F
1758:  DECF   00,F
175A:  BTFSC  FD8.2
175C:  BRA    184E
175E:  BRA    174A
1760:  BSF    x5C.7
1762:  BRA    17B6
1764:  BCF    x5C.7
1766:  MOVFF  357,35B
176A:  BTFSS  x57.7
176C:  BRA    1772
176E:  BSF    x60.7
1770:  BRA    1840
1772:  BCF    x60.7
1774:  BRA    1840
1776:  MOVFF  357,360
177A:  BSF    x60.7
177C:  MOVFF  358,35F
1780:  MOVFF  359,35E
1784:  BTFSS  x5B.7
1786:  BRA    1790
1788:  BCF    x60.7
178A:  BSF    x5C.2
178C:  BRA    1858
178E:  BCF    x5C.2
1790:  CLRF   x5D
1792:  BCF    x5A.0
1794:  MOVLW  03
1796:  MOVWF  FEA
1798:  MOVLW  55
179A:  MOVWF  FE9
179C:  BRA    187E
179E:  BTFSC  x5B.7
17A0:  BRA    17DA
17A2:  MOVFF  353,35B
17A6:  BTFSS  x5A.0
17A8:  BRA    17B6
17AA:  RRCF   x60,F
17AC:  RRCF   x5F,F
17AE:  RRCF   x5E,F
17B0:  RRCF   x5D,F
17B2:  INCF   00,F
17B4:  BZ    184E
17B6:  BTFSS  x5D.7
17B8:  BRA    17D0
17BA:  INCF   x5E,F
17BC:  BNZ   17D0
17BE:  INCF   x5F,F
17C0:  BNZ   17D0
17C2:  INCF   x60,F
17C4:  BNZ   17D0
17C6:  RRCF   x60,F
17C8:  RRCF   x5F,F
17CA:  RRCF   x5E,F
17CC:  INCF   00,F
17CE:  BZ    184E
17D0:  BTFSC  x5C.6
17D2:  BRA    16DC
17D4:  BTFSC  x5C.7
17D6:  BRA    1764
17D8:  BRA    1812
17DA:  MOVLW  80
17DC:  XORWF  x60,F
17DE:  BTFSS  x60.7
17E0:  BRA    17EA
17E2:  BRA    1858
17E4:  MOVFF  357,35B
17E8:  BRA    17FE
17EA:  MOVFF  353,35B
17EE:  MOVF   x60,F
17F0:  BNZ   17FE
17F2:  MOVF   x5F,F
17F4:  BNZ   17FE
17F6:  MOVF   x5E,F
17F8:  BNZ   17FE
17FA:  CLRF   00
17FC:  BRA    1840
17FE:  BTFSC  x60.7
1800:  BRA    1812
1802:  BCF    FD8.0
1804:  RLCF   x5D,F
1806:  RLCF   x5E,F
1808:  RLCF   x5F,F
180A:  RLCF   x60,F
180C:  DECFSZ 00,F
180E:  BRA    17FE
1810:  BRA    184E
1812:  BTFSS  x5B.7
1814:  BRA    181A
1816:  BSF    x60.7
1818:  BRA    1840
181A:  BCF    x60.7
181C:  BRA    1840
181E:  MOVFF  356,00
1822:  MOVFF  357,360
1826:  MOVFF  358,35F
182A:  MOVFF  359,35E
182E:  BRA    1840
1830:  MOVFF  352,00
1834:  MOVFF  353,360
1838:  MOVFF  354,35F
183C:  MOVFF  355,35E
1840:  MOVFF  360,01
1844:  MOVFF  35F,02
1848:  MOVFF  35E,03
184C:  BRA    18B6
184E:  CLRF   00
1850:  CLRF   01
1852:  CLRF   02
1854:  CLRF   03
1856:  BRA    18B6
1858:  CLRF   x5D
185A:  COMF   x5E,F
185C:  COMF   x5F,F
185E:  COMF   x60,F
1860:  COMF   x5D,F
1862:  INCF   x5D,F
1864:  BNZ   1870
1866:  INCF   x5E,F
1868:  BNZ   1870
186A:  INCF   x5F,F
186C:  BNZ   1870
186E:  INCF   x60,F
1870:  BTFSC  x5C.0
1872:  BRA    1698
1874:  BTFSC  x5C.1
1876:  BRA    1720
1878:  BTFSC  x5C.2
187A:  BRA    178E
187C:  BRA    17E4
187E:  MOVF   FEF,W
1880:  ADDWF  x5E,F
1882:  BNC   188E
1884:  INCF   x5F,F
1886:  BNZ   188E
1888:  INCF   x60,F
188A:  BTFSC  FD8.2
188C:  BSF    x5A.0
188E:  MOVF   FED,F
1890:  MOVF   FEF,W
1892:  ADDWF  x5F,F
1894:  BNC   189C
1896:  INCF   x60,F
1898:  BTFSC  FD8.2
189A:  BSF    x5A.0
189C:  MOVF   FED,F
189E:  MOVF   FEF,W
18A0:  BTFSC  FEF.7
18A2:  BRA    18A6
18A4:  XORLW  80
18A6:  ADDWF  x60,F
18A8:  BTFSC  FD8.0
18AA:  BSF    x5A.0
18AC:  BTFSC  x5C.4
18AE:  BRA    16A8
18B0:  BTFSC  x5C.5
18B2:  BRA    1730
18B4:  BRA    179E
18B6:  MOVLB  0
18B8:  RETURN 0
*
1B2C:  MOVLW  B6
1B2E:  MOVWF  00
1B30:  CLRF   03
1B32:  CLRF   02
1B34:  CLRF   01
1B36:  MOVLB  3
1B38:  MOVF   x36,W
1B3A:  IORWF  x37,W
1B3C:  IORWF  x38,W
1B3E:  IORWF  x39,W
1B40:  BNZ   1B46
1B42:  CLRF   00
1B44:  BRA    1B60
1B46:  BCF    FD8.0
1B48:  BTFSC  01.7
1B4A:  BRA    1B5E
1B4C:  RLCF   x36,F
1B4E:  RLCF   x37,F
1B50:  RLCF   x38,F
1B52:  RLCF   x39,F
1B54:  RLCF   03,F
1B56:  RLCF   02,F
1B58:  RLCF   01,F
1B5A:  DECFSZ 00,F
1B5C:  BRA    1B46
1B5E:  BCF    01.7
1B60:  MOVLB  0
1B62:  GOTO   1F4E (RETURN)
*
1F74:  MOVF   FE9,W
1F76:  MOVLB  3
1F78:  MOVWF  x3B
1F7A:  MOVF   x3A,W
1F7C:  MOVWF  x3D
1F7E:  BZ    1FB8
1F80:  MOVFF  339,355
1F84:  MOVFF  338,354
1F88:  MOVFF  337,353
1F8C:  MOVFF  336,352
1F90:  CLRF   x59
1F92:  CLRF   x58
1F94:  MOVLW  20
1F96:  MOVWF  x57
1F98:  MOVLW  82
1F9A:  MOVWF  x56
1F9C:  MOVLB  0
1F9E:  CALL   0D56
1FA2:  MOVFF  03,339
1FA6:  MOVFF  02,338
1FAA:  MOVFF  01,337
1FAE:  MOVFF  00,336
1FB2:  MOVLB  3
1FB4:  DECFSZ x3D,F
1FB6:  BRA    1F80
1FB8:  MOVLW  7E
1FBA:  MOVWF  00
1FBC:  CLRF   01
1FBE:  BTFSC  x37.7
1FC0:  BSF    01.7
1FC2:  CLRF   02
1FC4:  CLRF   03
1FC6:  BCF    FD8.1
1FC8:  MOVFF  339,355
1FCC:  MOVFF  338,354
1FD0:  MOVFF  337,353
1FD4:  MOVFF  336,352
1FD8:  MOVFF  03,359
1FDC:  MOVFF  02,358
1FE0:  MOVFF  01,357
1FE4:  MOVWF  x56
1FE6:  MOVLB  0
1FE8:  CALL   1642
1FEC:  MOVFF  03,339
1FF0:  MOVFF  02,338
1FF4:  MOVFF  01,337
1FF8:  MOVFF  00,336
1FFC:  MOVFF  339,34B
2000:  MOVFF  338,34A
2004:  MOVFF  337,349
2008:  MOVFF  336,348
200C:  CALL   0E4C
2010:  MOVFF  03,339
2014:  MOVFF  02,338
2018:  MOVFF  01,337
201C:  MOVFF  00,336
2020:  MOVLB  3
2022:  BTFSS  x39.7
2024:  BRA    2040
2026:  DECF   x3B,F
2028:  BSF    x3B.5
202A:  COMF   x36,F
202C:  COMF   x37,F
202E:  COMF   x38,F
2030:  COMF   x39,F
2032:  INCF   x36,F
2034:  BTFSC  FD8.2
2036:  INCF   x37,F
2038:  BTFSC  FD8.2
203A:  INCF   x38,F
203C:  BTFSC  FD8.2
203E:  INCF   x39,F
2040:  MOVLW  3B
2042:  MOVWF  x42
2044:  MOVLW  9A
2046:  MOVWF  x41
2048:  MOVLW  CA
204A:  MOVWF  x40
204C:  CLRF   x3F
204E:  MOVLW  0A
2050:  MOVWF  x3D
2052:  MOVF   x3A,W
2054:  BTFSC  FD8.2
2056:  INCF   x3B,F
2058:  BSF    FD8.1
205A:  MOVLW  03
205C:  MOVWF  FEA
205E:  MOVLW  36
2060:  MOVWF  FE9
2062:  MOVFF  339,3FF
2066:  MOVFF  338,3FE
206A:  MOVFF  337,3FD
206E:  MOVFF  336,3FC
2072:  MOVFF  342,403
2076:  MOVFF  341,402
207A:  MOVFF  340,401
207E:  MOVFF  33F,400
2082:  MOVLB  0
2084:  CALL   0E8E
2088:  MOVF   01,W
208A:  MOVF   00,F
208C:  BNZ   20B4
208E:  MOVLB  3
2090:  INCF   x3A,W
2092:  SUBWF  x3D,W
2094:  BTFSS  FD8.2
2096:  BRA    209C
2098:  MOVLB  0
209A:  BRA    20B4
209C:  MOVF   x3B,W
209E:  BZ    20BA
20A0:  ANDLW  0F
20A2:  SUBWF  x3D,W
20A4:  BZ    20A8
20A6:  BC    2130
20A8:  BTFSC  x3B.7
20AA:  BRA    2130
20AC:  BTFSC  x3B.6
20AE:  BRA    20BA
20B0:  MOVLW  20
20B2:  BRA    2122
20B4:  MOVLW  20
20B6:  MOVLB  3
20B8:  ANDWF  x3B,F
20BA:  BTFSS  x3B.5
20BC:  BRA    20DC
20BE:  BCF    x3B.5
20C0:  MOVF   x3A,W
20C2:  BTFSS  FD8.2
20C4:  DECF   x3B,F
20C6:  MOVF   00,W
20C8:  MOVWF  x3B
20CA:  MOVLW  2D
20CC:  MOVWF  x45
20CE:  MOVLB  0
20D0:  CALL   0650
20D4:  MOVLB  3
20D6:  MOVF   x3B,W
20D8:  MOVWF  00
20DA:  CLRF   x3B
20DC:  MOVF   x3A,W
20DE:  SUBWF  x3D,W
20E0:  BNZ   20FC
20E2:  MOVF   00,W
20E4:  MOVWF  x3B
20E6:  MOVLW  2E
20E8:  MOVWF  x45
20EA:  MOVLB  0
20EC:  CALL   0650
20F0:  MOVLB  3
20F2:  MOVF   x3B,W
20F4:  MOVWF  00
20F6:  MOVLW  20
20F8:  ANDWF  x3B,F
20FA:  MOVLW  00
20FC:  MOVLW  30
20FE:  BTFSS  x3B.5
2100:  BRA    2122
2102:  BCF    x3B.5
2104:  MOVF   x3A,W
2106:  BTFSS  FD8.2
2108:  DECF   x3B,F
210A:  MOVF   00,W
210C:  MOVWF  x3B
210E:  MOVLW  2D
2110:  MOVWF  x45
2112:  MOVLB  0
2114:  CALL   0650
2118:  MOVLB  3
211A:  MOVF   x3B,W
211C:  MOVWF  00
211E:  CLRF   x3B
2120:  MOVLW  30
2122:  ADDWF  00,F
2124:  MOVFF  00,345
2128:  MOVLB  0
212A:  CALL   0650
212E:  MOVLB  3
2130:  BCF    FD8.1
2132:  MOVFF  342,3FF
2136:  MOVFF  341,3FE
213A:  MOVFF  340,3FD
213E:  MOVFF  33F,3FC
2142:  MOVLB  4
2144:  CLRF   x03
2146:  CLRF   x02
2148:  CLRF   x01
214A:  MOVLW  0A
214C:  MOVWF  x00
214E:  MOVLB  0
2150:  CALL   0E8E
2154:  MOVFF  03,342
2158:  MOVFF  02,341
215C:  MOVFF  01,340
2160:  MOVFF  00,33F
2164:  MOVLB  3
2166:  DECFSZ x3D,F
2168:  BRA    2058
216A:  MOVLB  0
216C:  RETURN 0
*
2C40:  MOVLB  3
2C42:  MOVF   x58,W
2C44:  MULWF  x5A
2C46:  MOVFF  FF3,01
2C4A:  MOVFF  FF4,00
2C4E:  MULWF  x5B
2C50:  MOVF   FF3,W
2C52:  ADDWF  00,F
2C54:  MOVF   x59,W
2C56:  MULWF  x5A
2C58:  MOVF   FF3,W
2C5A:  ADDWFC 00,W
2C5C:  MOVWF  02
2C5E:  MOVLB  0
2C60:  GOTO   2FF8 (RETURN)
2C64:  MOVLB  4
2C66:  CLRF   x36
2C68:  CLRF   x37
2C6A:  MOVLW  01
2C6C:  MOVWF  x38
2C6E:  CLRF   FDA
2C70:  CLRF   FD9
2C72:  MOVLW  04
2C74:  MOVWF  x3B
2C76:  MOVLW  2E
2C78:  MOVWF  x3A
2C7A:  MOVLW  04
2C7C:  MOVWF  FEA
2C7E:  MOVLW  32
2C80:  MOVWF  FE9
2C82:  MOVFF  43B,FE2
2C86:  MOVFF  43A,FE1
2C8A:  MOVFF  438,439
2C8E:  BCF    FD8.0
2C90:  MOVF   FE5,W
2C92:  MULWF  FEE
2C94:  MOVF   FF3,W
2C96:  ADDWFC x36,F
2C98:  MOVF   FF4,W
2C9A:  ADDWFC x37,F
2C9C:  DECFSZ x39,F
2C9E:  BRA    2C8E
2CA0:  MOVFF  436,FDE
2CA4:  MOVFF  437,436
2CA8:  CLRF   x37
2CAA:  BTFSC  FD8.0
2CAC:  INCF   x37,F
2CAE:  INCF   x3A,F
2CB0:  BTFSC  FD8.2
2CB2:  INCF   x3B,F
2CB4:  INCF   x38,F
2CB6:  MOVF   x38,W
2CB8:  SUBLW  05
2CBA:  BNZ   2C7A
2CBC:  MOVLB  0
2CBE:  RETURN 0
*
5416:  MOVFF  223,FEA
541A:  MOVFF  222,FE9
541E:  MOVLB  3
5420:  MOVFF  348,FEF
5424:  INCF   FE9,F
5426:  BTFSC  FD8.2
5428:  INCF   FEA,F
542A:  CLRF   FEF
542C:  MOVLB  2
542E:  INCF   x22,F
5430:  BTFSC  FD8.2
5432:  INCF   x23,F
5434:  MOVLB  0
5436:  RETURN 0
5438:  MOVF   01,W
543A:  MOVFF  33B,33D
543E:  MOVLW  64
5440:  MOVLB  3
5442:  MOVWF  x3E
5444:  MOVLB  0
5446:  CALL   06BC
544A:  MOVFF  00,33B
544E:  MOVF   01,W
5450:  MOVLW  30
5452:  BNZ   5464
5454:  MOVLB  3
5456:  BTFSS  x3C.1
5458:  BRA    5478
545A:  BTFSC  x3C.3
545C:  BRA    5478
545E:  BTFSC  x3C.4
5460:  MOVLW  20
5462:  BRA    546C
5464:  MOVLB  3
5466:  BCF    x3C.3
5468:  BCF    x3C.4
546A:  BSF    x3C.0
546C:  ADDWF  01,F
546E:  MOVFF  01,348
5472:  MOVLB  0
5474:  RCALL  5416
5476:  MOVLB  3
5478:  MOVFF  33B,33D
547C:  MOVLW  0A
547E:  MOVWF  x3E
5480:  MOVLB  0
5482:  CALL   06BC
5486:  MOVFF  00,33B
548A:  MOVF   01,W
548C:  MOVLW  30
548E:  BNZ   54A0
5490:  MOVLB  3
5492:  BTFSC  x3C.3
5494:  BRA    54AA
5496:  BTFSS  x3C.0
5498:  BRA    54AA
549A:  BTFSC  x3C.4
549C:  MOVLW  20
549E:  MOVLB  0
54A0:  ADDWF  01,F
54A2:  MOVFF  01,348
54A6:  RCALL  5416
54A8:  MOVLB  3
54AA:  MOVLW  30
54AC:  ADDWF  x3B,F
54AE:  MOVFF  33B,348
54B2:  MOVLB  0
54B4:  RCALL  5416
54B6:  RETURN 0
54B8:  TBLRD*+
54BA:  MOVFF  FF6,33C
54BE:  MOVFF  FF7,33D
54C2:  MOVFF  FF5,348
54C6:  RCALL  5416
54C8:  MOVFF  33C,FF6
54CC:  MOVFF  33D,FF7
54D0:  MOVLB  3
54D2:  DECFSZ x3B,F
54D4:  BRA    54D8
54D6:  BRA    54DC
54D8:  MOVLB  0
54DA:  BRA    54B8
54DC:  MOVLB  0
54DE:  RETURN 0
54E0:  MOVF   FE9,W
54E2:  MOVLB  3
54E4:  MOVWF  x40
54E6:  MOVF   x3F,W
54E8:  MOVWF  x42
54EA:  BZ    5524
54EC:  MOVFF  33E,355
54F0:  MOVFF  33D,354
54F4:  MOVFF  33C,353
54F8:  MOVFF  33B,352
54FC:  CLRF   x59
54FE:  CLRF   x58
5500:  MOVLW  20
5502:  MOVWF  x57
5504:  MOVLW  82
5506:  MOVWF  x56
5508:  MOVLB  0
550A:  CALL   0D56
550E:  MOVFF  03,33E
5512:  MOVFF  02,33D
5516:  MOVFF  01,33C
551A:  MOVFF  00,33B
551E:  MOVLB  3
5520:  DECFSZ x42,F
5522:  BRA    54EC
5524:  MOVFF  33E,34B
5528:  MOVFF  33D,34A
552C:  MOVFF  33C,349
5530:  MOVFF  33B,348
5534:  MOVLB  0
5536:  CALL   0E4C
553A:  MOVFF  03,33E
553E:  MOVFF  02,33D
5542:  MOVFF  01,33C
5546:  MOVFF  00,33B
554A:  MOVLB  3
554C:  BTFSS  x3E.7
554E:  BRA    556A
5550:  DECF   x40,F
5552:  BSF    x40.5
5554:  COMF   x3B,F
5556:  COMF   x3C,F
5558:  COMF   x3D,F
555A:  COMF   x3E,F
555C:  INCF   x3B,F
555E:  BTFSC  FD8.2
5560:  INCF   x3C,F
5562:  BTFSC  FD8.2
5564:  INCF   x3D,F
5566:  BTFSC  FD8.2
5568:  INCF   x3E,F
556A:  MOVLW  3B
556C:  MOVWF  x47
556E:  MOVLW  9A
5570:  MOVWF  x46
5572:  MOVLW  CA
5574:  MOVWF  x45
5576:  CLRF   x44
5578:  MOVLW  0A
557A:  MOVWF  x42
557C:  MOVF   x3F,W
557E:  BTFSC  FD8.2
5580:  INCF   x40,F
5582:  BSF    FD8.1
5584:  MOVLW  03
5586:  MOVWF  FEA
5588:  MOVLW  3B
558A:  MOVWF  FE9
558C:  MOVFF  33E,3FF
5590:  MOVFF  33D,3FE
5594:  MOVFF  33C,3FD
5598:  MOVFF  33B,3FC
559C:  MOVFF  347,403
55A0:  MOVFF  346,402
55A4:  MOVFF  345,401
55A8:  MOVFF  344,400
55AC:  MOVLB  0
55AE:  CALL   0E8E
55B2:  MOVF   01,W
55B4:  MOVF   00,F
55B6:  BNZ   55DE
55B8:  MOVLB  3
55BA:  INCF   x3F,W
55BC:  SUBWF  x42,W
55BE:  BTFSS  FD8.2
55C0:  BRA    55C6
55C2:  MOVLB  0
55C4:  BRA    55DE
55C6:  MOVF   x40,W
55C8:  BZ    55E4
55CA:  ANDLW  0F
55CC:  SUBWF  x42,W
55CE:  BZ    55D2
55D0:  BC    5652
55D2:  BTFSC  x40.7
55D4:  BRA    5652
55D6:  BTFSC  x40.6
55D8:  BRA    55E4
55DA:  MOVLW  20
55DC:  BRA    5646
55DE:  MOVLW  20
55E0:  MOVLB  3
55E2:  ANDWF  x40,F
55E4:  BTFSS  x40.5
55E6:  BRA    5604
55E8:  BCF    x40.5
55EA:  MOVF   x3F,W
55EC:  BTFSS  FD8.2
55EE:  DECF   x40,F
55F0:  MOVF   00,W
55F2:  MOVWF  x40
55F4:  MOVLW  2D
55F6:  MOVWF  x48
55F8:  MOVLB  0
55FA:  RCALL  5416
55FC:  MOVLB  3
55FE:  MOVF   x40,W
5600:  MOVWF  00
5602:  CLRF   x40
5604:  MOVF   x3F,W
5606:  SUBWF  x42,W
5608:  BNZ   5622
560A:  MOVF   00,W
560C:  MOVWF  x40
560E:  MOVLW  2E
5610:  MOVWF  x48
5612:  MOVLB  0
5614:  RCALL  5416
5616:  MOVLB  3
5618:  MOVF   x40,W
561A:  MOVWF  00
561C:  MOVLW  20
561E:  ANDWF  x40,F
5620:  MOVLW  00
5622:  MOVLW  30
5624:  BTFSS  x40.5
5626:  BRA    5646
5628:  BCF    x40.5
562A:  MOVF   x3F,W
562C:  BTFSS  FD8.2
562E:  DECF   x40,F
5630:  MOVF   00,W
5632:  MOVWF  x40
5634:  MOVLW  2D
5636:  MOVWF  x48
5638:  MOVLB  0
563A:  RCALL  5416
563C:  MOVLB  3
563E:  MOVF   x40,W
5640:  MOVWF  00
5642:  CLRF   x40
5644:  MOVLW  30
5646:  ADDWF  00,F
5648:  MOVFF  00,348
564C:  MOVLB  0
564E:  RCALL  5416
5650:  MOVLB  3
5652:  BCF    FD8.1
5654:  MOVFF  347,3FF
5658:  MOVFF  346,3FE
565C:  MOVFF  345,3FD
5660:  MOVFF  344,3FC
5664:  MOVLB  4
5666:  CLRF   x03
5668:  CLRF   x02
566A:  CLRF   x01
566C:  MOVLW  0A
566E:  MOVWF  x00
5670:  MOVLB  0
5672:  CALL   0E8E
5676:  MOVFF  03,347
567A:  MOVFF  02,346
567E:  MOVFF  01,345
5682:  MOVFF  00,344
5686:  MOVLB  3
5688:  DECFSZ x42,F
568A:  BRA    5582
568C:  MOVLB  0
568E:  RETURN 0
*
56DE:  MOVF   FEF,F
56E0:  BZ    5702
56E2:  MOVFF  FEA,337
56E6:  MOVFF  FE9,336
56EA:  MOVFF  FEF,345
56EE:  CALL   0650
56F2:  MOVFF  337,FEA
56F6:  MOVFF  336,FE9
56FA:  INCF   FE9,F
56FC:  BTFSC  FD8.2
56FE:  INCF   FEA,F
5700:  BRA    56DE
5702:  RETURN 0
*
5C0C:  MOVFF  FEA,33E
5C10:  MOVFF  FE9,33D
5C14:  MOVLB  3
5C16:  SWAPF  x37,W
5C18:  IORLW  F0
5C1A:  MOVWF  x39
5C1C:  ADDWF  x39,F
5C1E:  ADDLW  E2
5C20:  MOVWF  x3A
5C22:  ADDLW  32
5C24:  MOVWF  x3C
5C26:  MOVF   x37,W
5C28:  ANDLW  0F
5C2A:  ADDWF  x3A,F
5C2C:  ADDWF  x3A,F
5C2E:  ADDWF  x3C,F
5C30:  ADDLW  E9
5C32:  MOVWF  x3B
5C34:  ADDWF  x3B,F
5C36:  ADDWF  x3B,F
5C38:  SWAPF  x36,W
5C3A:  ANDLW  0F
5C3C:  ADDWF  x3B,F
5C3E:  ADDWF  x3C,F
5C40:  RLCF   x3B,F
5C42:  RLCF   x3C,F
5C44:  COMF   x3C,F
5C46:  RLCF   x3C,F
5C48:  MOVF   x36,W
5C4A:  ANDLW  0F
5C4C:  ADDWF  x3C,F
5C4E:  RLCF   x39,F
5C50:  MOVLW  07
5C52:  MOVWF  x38
5C54:  MOVLW  0A
5C56:  DECF   x3B,F
5C58:  ADDWF  x3C,F
5C5A:  BNC   5C56
5C5C:  DECF   x3A,F
5C5E:  ADDWF  x3B,F
5C60:  BNC   5C5C
5C62:  DECF   x39,F
5C64:  ADDWF  x3A,F
5C66:  BNC   5C62
5C68:  DECF   x38,F
5C6A:  ADDWF  x39,F
5C6C:  BNC   5C68
5C6E:  MOVLW  03
5C70:  MOVWF  FEA
5C72:  MOVLW  38
5C74:  MOVWF  FE9
5C76:  MOVLW  07
5C78:  ANDWF  x3D,W
5C7A:  BCF    x3D.6
5C7C:  ADDWF  FE9,F
5C7E:  MOVLW  00
5C80:  ADDWFC FEA,F
5C82:  MOVF   FE9,W
5C84:  SUBLW  3C
5C86:  BNZ   5C90
5C88:  MOVF   FEA,W
5C8A:  SUBLW  03
5C8C:  BNZ   5C90
5C8E:  BSF    x3D.6
5C90:  MOVF   FEF,W
5C92:  MOVWF  00
5C94:  BNZ   5CA6
5C96:  BTFSC  x3D.6
5C98:  BRA    5CA6
5C9A:  BTFSC  x3D.4
5C9C:  BRA    5CCA
5C9E:  BTFSC  x3D.3
5CA0:  BRA    5CA6
5CA2:  MOVLW  20
5CA4:  BRA    5CAC
5CA6:  BSF    x3D.3
5CA8:  BCF    x3D.4
5CAA:  MOVLW  30
5CAC:  ADDWF  00,F
5CAE:  MOVFF  FEA,337
5CB2:  MOVFF  FE9,336
5CB6:  MOVFF  00,345
5CBA:  MOVLB  0
5CBC:  CALL   0650
5CC0:  MOVFF  337,FEA
5CC4:  MOVFF  336,FE9
5CC8:  MOVLB  3
5CCA:  MOVF   FEE,W
5CCC:  BTFSS  x3D.6
5CCE:  BRA    5C82
5CD0:  MOVLB  0
5CD2:  GOTO   644C (RETURN)
....................  
.................... #list 
....................  
.................... #device PASS_STRINGS = IN_RAM 
.................... #fuses HSPLL, PLL2, CPUDIV1 
.................... #use delay(internal = 8MHz) 
*
0882:  MOVLW  03
0884:  MOVWF  FEA
0886:  MOVLW  5E
0888:  MOVWF  FE9
088A:  MOVF   FEF,W
088C:  BZ    08A8
088E:  MOVLW  02
0890:  MOVWF  01
0892:  CLRF   00
0894:  DECFSZ 00,F
0896:  BRA    0894
0898:  DECFSZ 01,F
089A:  BRA    0892
089C:  MOVLW  97
089E:  MOVWF  00
08A0:  DECFSZ 00,F
08A2:  BRA    08A0
08A4:  DECFSZ FEF,F
08A6:  BRA    088E
08A8:  RETURN 0
.................... #use i2c(Master,Fast,sda=PIN_A1,scl=PIN_A0) 
*
04AC:  MOVLW  08
04AE:  MOVWF  01
04B0:  NOP   
04B2:  BCF    F89.0
04B4:  BCF    F92.0
04B6:  NOP   
04B8:  MOVLB  3
04BA:  RLCF   x3F,F
04BC:  BCF    F89.1
04BE:  BTFSC  FD8.0
04C0:  BSF    F92.1
04C2:  BTFSS  FD8.0
04C4:  BCF    F92.1
04C6:  BSF    F92.0
04C8:  BTFSS  F80.0
04CA:  BRA    04C8
04CC:  DECFSZ 01,F
04CE:  BRA    04D2
04D0:  BRA    04D6
04D2:  MOVLB  0
04D4:  BRA    04B0
04D6:  NOP   
04D8:  BCF    F89.0
04DA:  BCF    F92.0
04DC:  NOP   
04DE:  BSF    F92.1
04E0:  NOP   
04E2:  NOP   
04E4:  BSF    F92.0
04E6:  BTFSS  F80.0
04E8:  BRA    04E6
04EA:  CLRF   01
04EC:  NOP   
04EE:  BTFSC  F80.1
04F0:  BSF    01.0
04F2:  BCF    F89.0
04F4:  BCF    F92.0
04F6:  BCF    F89.1
04F8:  BCF    F92.1
04FA:  MOVLB  0
04FC:  RETURN 0
04FE:  MOVLW  08
0500:  MOVLB  3
0502:  MOVWF  x40
0504:  MOVFF  00,341
0508:  BSF    F92.1
050A:  NOP   
050C:  BSF    F92.0
050E:  BTFSS  F80.0
0510:  BRA    050E
0512:  BTFSC  F80.1
0514:  BSF    FD8.0
0516:  BTFSS  F80.1
0518:  BCF    FD8.0
051A:  RLCF   01,F
051C:  NOP   
051E:  BCF    F92.0
0520:  BCF    F89.0
0522:  DECFSZ x40,F
0524:  BRA    0508
0526:  BSF    F92.1
0528:  NOP   
052A:  BCF    F89.1
052C:  MOVF   x41,W
052E:  BTFSS  FD8.2
0530:  BCF    F92.1
0532:  NOP   
0534:  BSF    F92.0
0536:  BTFSS  F80.0
0538:  BRA    0536
053A:  NOP   
053C:  BCF    F89.0
053E:  BCF    F92.0
0540:  NOP   
0542:  BCF    F89.1
0544:  BCF    F92.1
0546:  MOVLB  0
0548:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_A3,rcv=PIN_A4,stream=asd) 
*
0650:  BCF    F92.3
0652:  BCF    F89.3
0654:  MOVLW  08
0656:  MOVWF  01
0658:  BRA    065A
065A:  NOP   
065C:  BSF    01.7
065E:  BRA    0680
0660:  BCF    01.7
0662:  MOVLB  3
0664:  RRCF   x45,F
0666:  MOVLB  0
0668:  BTFSC  FD8.0
066A:  BSF    F89.3
066C:  BTFSS  FD8.0
066E:  BCF    F89.3
0670:  BSF    01.6
0672:  BRA    0680
0674:  BCF    01.6
0676:  DECFSZ 01,F
0678:  BRA    0662
067A:  BRA    067C
067C:  NOP   
067E:  BSF    F89.3
0680:  MOVLW  3F
0682:  MOVWF  FE9
0684:  DECFSZ FE9,F
0686:  BRA    0684
0688:  NOP   
068A:  BTFSC  01.7
068C:  BRA    0660
068E:  BTFSC  01.6
0690:  BRA    0674
0692:  RETURN 0
.................... #define DS1307_I2C_NO_STREAM 
.................... #use fast_io(A) 
....................  
.................... #include <SD.c> 
.................... // Include MMC/SD card driver source file 
.................... #include <mmcsd_m.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           mmcsd_m.c                             //// 
.................... ////                                                                 //// 
.................... ////   This driver is a modified version of CCS C compiler mmcsd.c   //// 
.................... ////   file, now it supports all types of cards: MMC, SD and SDHC.   //// 
.................... ////                                                                 //// 
.................... ////               https://simple-circuit.com/                       //// 
.................... ////               contact@simple-circuit.com                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////    This is a low-level driver for MMC and SD cards.             //// 
.................... ////                                                                 //// 
.................... //// --User Functions--                                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_init(): Initializes the media.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_byte(a, p)                                           //// 
.................... ////  Reads a byte from the MMC/SD card at location a, saves to      //// 
.................... ////  pointer p.  Returns 0 if OK, non-zero if error.                //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_data(a, n, p)                                        //// 
.................... ////  Reads n bytes of data from the MMC/SD card starting at address //// 
.................... ////  a, saves result to pointer p.  Returns 0 if OK, non-zero if    //// 
.................... ////  error.                                                         //// 
.................... ////                                                                 //// 
.................... //// mmcsd_flush_buffer()                                            //// 
.................... ////  The two user write functions (mmcsd_write_byte() and           //// 
.................... ////  mmcsd_write_data()) maintain a buffer to speed up the writing  //// 
.................... ////  process.  Whenever a read or write is performed, the write     //// 
.................... ////  buffer is loaded with the specified page and only the          //// 
.................... ////  contents of this buffer is changed.  If any future writes      //// 
.................... ////  cross a page boundary then the buffer in RAM is written        //// 
.................... ////  to the MMC/SD and then the next page is loaded into the        //// 
.................... ////  buffer.  mmcsd_flush_buffer() forces the contents in RAM       //// 
.................... ////  to the MMC/SD card.  Returns 0 if OK, non-zero if errror.      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_byte(a, d)                                          //// 
.................... ////  Writes data byte d to the MMC/SD address a.  Intelligently     //// 
.................... ////  manages a write buffer, therefore you may need to call         //// 
.................... ////  mmcsd_flush_buffer() to flush the buffer.                      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_data(a, n, p)                                       //// 
.................... ////  Writes n bytes of data from pointer p to the MMC/SD card       //// 
.................... ////  starting at address a.  This function intelligently manages    //// 
.................... ////  a write buffer, therefore if you may need to call              //// 
.................... ////  mmcsd_flush_buffer() to flush any buffered characters.         //// 
.................... ////  returns 0 if OK, non-zero if error.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_block(a, s, p)                                       //// 
.................... ////  Reads an entire page from the SD/MMC.  Keep in mind that the   //// 
.................... ////  start of the read has to be aligned to a block                 //// 
.................... ////  (Address % 512 = 0).  Therefore s must be evenly divisible by  //// 
.................... ////  512.  At the application level it is much more effecient to    //// 
.................... ////  to use mmcsd_read_data() or mmcsd_read_byte().  Returns 0      //// 
.................... ////  if successful, non-zero if error.                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_block(a, s, p):                                     //// 
.................... ////  Writes an entire page to the SD/MMC.  This will write an       //// 
.................... ////  entire page to the SD/MMC, so the address and size must be     //// 
.................... ////  evenly  divisble by 512.  At the application level it is much  //// 
.................... ////  more effecient to use mmcsd_write_data() or mmcsd_write_byte().//// 
.................... ////  Returns 0 if successful, non-zero if error.                    //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_cid(): Displays all data in the Card Identification //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_csd(): Displays all data in the Card Specific Data  //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// --Non-User Functions--                                          //// 
.................... ////                                                                 //// 
.................... //// mmcsd_go_idle_state(): Sends the GO_IDLE_STATE command to the   //// 
.................... ////                        SD/MMC.                                  //// 
.................... //// mmcsd_send_op_cond(): Sends the SEND_OP_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_send_if_cond(): Sends the SEND_IF_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_sd_status(): Sends the SD_STATUS command to the SD. Note  //// 
.................... ////                     This command only works on SD cards.        //// 
.................... //// mmcsd_send_status(): Sends the SEND_STATUS command to the       //// 
.................... ////                       SD/MMC.                                   //// 
.................... //// mmcsd_set_blocklen(): Sends the SET_BLOCKLEN command along with //// 
.................... ////                        the desired block length.                //// 
.................... //// mmcsd_app_cmd(): Sends the APP_CMD command to the SD. This only //// 
.................... ////                   works on SD cards and is used just before any //// 
.................... ////                   SD-only command (e.g. send_op_cond()).        //// 
.................... //// mmcsd_read_ocr(): Sends the READ_OCR command to the SD/MMC.     //// 
.................... //// mmcsd_crc_on_off(): Sends the CRC_ON_OFF command to the SD/MMC  //// 
.................... ////                      along with a bit to turn the CRC on/off.   //// 
.................... //// mmcsd_send_cmd(): Sends a command and argument to the SD/MMC.   //// 
.................... //// mmcsd_get_r1(): Waits for an R1 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r2(): Waits for an R2 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r3(): Waits for an R3 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r7(): Waits for an R7 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_wait_for_token(): Waits for a specified token from the    //// 
.................... ////                          SD/MMC.                                //// 
.................... //// mmcsd_crc7(): Generates a CRC7 using a pointer to some data,    //// 
.................... ////                and how many bytes long the data is.             //// 
.................... //// mmcsd_crc16(): Generates a CRC16 using a pointer to some data,  //// 
.................... ////                and how many bytes long the data is.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MMCSD_C 
.................... #define MMCSD_C 
....................  
.................... ///////////////////// 
.................... ////             //// 
.................... //// User Config //// 
.................... ////             //// 
.................... ///////////////////// 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef MMCSD_SPI_HW 
....................   #use spi(MASTER, DI=MMCSD_PIN_MISO, DO=MMCSD_PIN_MOSI, CLK=MMCSD_PIN_SCK, BITS=8, MSB_FIRST, MODE=3, baud=400000) 
.................... #endif 
....................  
.................... //////////////////////// 
.................... ////                //// 
.................... //// Useful Defines //// 
.................... ////                //// 
.................... //////////////////////// 
....................  
.................... enum MMCSD_err 
....................    {MMCSD_GOODEC = 0, 
....................    MMCSD_IDLE = 0x01, 
....................    MMCSD_ERASE_RESET = 0x02, 
....................    MMCSD_ILLEGAL_CMD = 0x04, 
....................    MMCSD_CRC_ERR = 0x08, 
....................    MMCSD_ERASE_SEQ_ERR = 0x10, 
....................    MMCSD_ADDR_ERR = 0x20, 
....................    MMCSD_PARAM_ERR = 0x40, 
....................    RESP_TIMEOUT = 0x80}; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_OP_COND 1 
.................... #define SEND_IF_COND 8 
.................... #define SEND_CSD 9 
.................... #define SEND_CID 10 
.................... #define SD_STATUS 13 
.................... #define SEND_STATUS 13 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SD_SEND_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
.................... #define CRC_ON_OFF 59 
....................  
.................... #define IDLE_TOKEN 0x01 
.................... #define DATA_START_TOKEN 0xFE 
....................  
.................... #define MMCSD_MAX_BLOCK_SIZE 512 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... uint8_t g_mmcsd_buffer[MMCSD_MAX_BLOCK_SIZE]; 
....................  
.................... int1 g_CRC_enabled; 
.................... int1 g_MMCSDBufferChanged; 
....................  
.................... uint32_t g_mmcsdBufferAddress; 
....................  
.................... enum _card_type{MMC, SDSC, SDHC} g_card_type; 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init(); 
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_go_idle_state(void); 
.................... MMCSD_err mmcsd_send_op_cond(void); 
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]); 
.................... MMCSD_err mmcsd_print_csd(); 
.................... MMCSD_err mmcsd_print_cid(); 
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen); 
.................... MMCSD_err mmcsd_read_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_write_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_sd_send_op_cond(void); 
.................... MMCSD_err mmcsd_app_cmd(void); 
.................... MMCSD_err mmcsd_read_ocr(uint8_t* r1); 
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled); 
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg); 
.................... MMCSD_err mmcsd_get_r1(void); 
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]); 
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]); 
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]); 
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token); 
.................... uint8_t mmcsd_crc7(char *data, uint8_t length); 
.................... //uint16_t mmcsd_crc16(char *data, uint8_t length);  // Not needed --> commented 
.................... void mmcsd_select(); 
.................... void mmcsd_deselect(); 
....................  
.................... /// Fast Functions ! /// 
....................  
.................... MMCSD_err mmcsd_load_buffer(void); 
.................... MMCSD_err mmcsd_flush_buffer(void); 
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr); 
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data); 
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... int8 MMCSD_SPI_XFER(int8 spi_data) { 
....................   #ifdef MMCSD_SPI_HW 
....................     return SPI_Read(spi_data); 
*
246E:  MOVF   FC9,W
2470:  MOVFF  463,FC9
2474:  RRCF   FC7,W
2476:  BNC   2474
2478:  MOVFF  FC9,01
....................   #else 
247C:  RETURN 0
....................     return spi_xfer(spi_data); 
....................   #endif 
.................... } 
....................  
.................... MMCSD_err mmcsd_init() 
.................... { 
....................    uint8_t 
....................       i, 
....................       r1, 
....................       r3[4]; 
....................  
....................    g_CRC_enabled = TRUE; 
*
27FC:  MOVLB  2
27FE:  BSF    x04.0
....................    g_mmcsdBufferAddress = 0; 
2800:  CLRF   x08
2802:  CLRF   x07
2804:  CLRF   x06
2806:  CLRF   x05
....................  
....................    output_drive(MMCSD_PIN_SELECT); 
2808:  BCF    F92.2
....................  
....................   #ifdef MMCSD_SPI_HW 
....................     SETUP_SPI(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
280A:  BCF    FC6.5
280C:  BCF    F94.7
280E:  BSF    F93.0
2810:  BCF    F93.1
2812:  MOVLW  32
2814:  MOVWF  FC6
2816:  MOVLW  00
2818:  MOVWF  FC7
....................   #else   // Software SPI 
....................     output_drive(MMCSD_PIN_SCK); 
....................     output_drive(MMCSD_PIN_MOSI); 
....................     output_float(MMCSD_PIN_MISO); 
....................   #endif 
....................  
....................    mmcsd_deselect(); 
281A:  MOVLB  0
281C:  RCALL  246A
....................    delay_ms(250); 
281E:  MOVLW  FA
2820:  MOVLB  3
2822:  MOVWF  x5E
2824:  MOVLB  0
2826:  CALL   0882
....................     for(i = 0; i < 10; i++)                        // Send 80 cycles 
282A:  MOVLB  3
282C:  CLRF   x58
282E:  MOVF   x58,W
2830:  SUBLW  09
2832:  BNC   2842
....................       MMCSD_SPI_XFER(0xFF); 
2834:  MOVLB  4
2836:  SETF   x63
2838:  MOVLB  0
283A:  RCALL  246E
283C:  MOVLB  3
283E:  INCF   x58,F
2840:  BRA    282E
....................  
....................    /* begin initialization */ 
....................    i = 0; 
2842:  CLRF   x58
....................    do 
....................    { 
....................       delay_ms(1); 
2844:  MOVLW  01
2846:  MOVWF  x5E
2848:  MOVLB  0
284A:  CALL   0882
....................       mmcsd_select(); 
284E:  RCALL  247E
....................       r1 = mmcsd_go_idle_state(); 
2850:  RCALL  256C
2852:  MOVFF  01,359
....................       mmcsd_deselect(); 
2856:  RCALL  246A
....................       i++; 
2858:  MOVLB  3
285A:  INCF   x58,F
....................       if(i == 0xFF) { 
285C:  INCFSZ x58,W
285E:  BRA    2872
....................          if (r1 == 0) 
2860:  MOVF   x59,F
2862:  BNZ   286C
....................            return 1; 
2864:  MOVLW  01
2866:  MOVWF  01
2868:  BRA    29AE
286A:  BRA    2872
....................          else 
....................            return r1; 
286C:  MOVFF  359,01
2870:  BRA    29AE
....................       } 
....................    } while(r1 != MMCSD_IDLE); 
2872:  DECFSZ x59,W
2874:  BRA    2844
....................  
....................    i = 0; 
2876:  CLRF   x58
....................    do 
....................    { 
....................       delay_ms(1); 
2878:  MOVLW  01
287A:  MOVWF  x5E
287C:  MOVLB  0
287E:  CALL   0882
....................       mmcsd_select(); 
2882:  RCALL  247E
....................       r1 = mmcsd_send_op_cond(); 
2884:  BRA    2582
2886:  MOVFF  01,359
....................       mmcsd_deselect(); 
288A:  RCALL  246A
....................       i++; 
288C:  MOVLB  3
288E:  INCF   x58,F
....................    } while((r1 & MMCSD_IDLE) && i != 0xFF); 
2890:  BTFSS  x59.0
2892:  BRA    2898
2894:  INCFSZ x58,W
2896:  BRA    2878
....................    if(i == 0xFF) { 
2898:  INCFSZ x58,W
289A:  BRA    28E0
....................      delay_ms(100); 
289C:  MOVLW  64
289E:  MOVWF  x5E
28A0:  MOVLB  0
28A2:  CALL   0882
....................      mmcsd_select(); 
28A6:  RCALL  247E
....................      r1 = mmcsd_go_idle_state(); 
28A8:  RCALL  256C
28AA:  MOVFF  01,359
....................      mmcsd_deselect(); 
28AE:  RCALL  246A
....................      delay_ms(100); 
28B0:  MOVLW  64
28B2:  MOVLB  3
28B4:  MOVWF  x5E
28B6:  MOVLB  0
28B8:  CALL   0882
....................      mmcsd_select(); 
28BC:  RCALL  247E
....................      r1 = mmcsd_send_if_cond(r3); 
28BE:  MOVLW  03
28C0:  MOVLB  3
28C2:  MOVWF  x5F
28C4:  MOVLW  5A
28C6:  MOVWF  x5E
28C8:  MOVLB  0
28CA:  BRA    260E
28CC:  MOVFF  01,359
....................      mmcsd_deselect(); 
28D0:  RCALL  246A
....................    if(r1 != MMCSD_IDLE) 
28D2:  MOVLB  3
28D4:  DECFSZ x59,W
28D6:  BRA    28DA
28D8:  BRA    28E0
....................      return r1; 
28DA:  MOVFF  359,01
28DE:  BRA    29AE
....................    } 
....................  
....................    /* figure out if we have an SD or MMC */ 
....................    i = 0; 
28E0:  CLRF   x58
....................    do { 
....................      mmcsd_select(); 
28E2:  MOVLB  0
28E4:  RCALL  247E
....................      r1=mmcsd_app_cmd(); 
28E6:  BRA    2634
28E8:  MOVFF  01,359
....................      r1=mmcsd_sd_send_op_cond(); 
28EC:  BRA    264E
28EE:  MOVFF  01,359
....................      mmcsd_deselect(); 
28F2:  RCALL  246A
....................      delay_ms(100); 
28F4:  MOVLW  64
28F6:  MOVLB  3
28F8:  MOVWF  x5E
28FA:  MOVLB  0
28FC:  CALL   0882
....................      i++; 
2900:  MOVLB  3
2902:  INCF   x58,F
....................    } while((r1 == MMCSD_IDLE) && (i != 0xFF)); 
2904:  DECFSZ x59,W
2906:  BRA    290C
2908:  INCFSZ x58,W
290A:  BRA    28E2
....................    if(r1 == MMCSD_IDLE) 
290C:  DECFSZ x59,W
290E:  BRA    2916
....................      return r1; 
2910:  MOVFF  359,01
2914:  BRA    29AE
....................  
....................    /* an mmc will return an 0x04 here */ 
....................    if(r1 == 0x04) 
2916:  MOVF   x59,W
2918:  SUBLW  04
291A:  BNZ   2924
....................       g_card_type = MMC; 
291C:  MOVLB  2
291E:  CLRF   x09
2920:  BRA    2958
2922:  MOVLB  3
....................    else { 
....................       g_card_type = SDSC; 
2924:  MOVLW  01
2926:  MOVLB  2
2928:  MOVWF  x09
....................       mmcsd_select(); 
292A:  MOVLB  0
292C:  RCALL  247E
....................       r1 = mmcsd_read_ocr(r3); 
292E:  MOVLW  03
2930:  MOVLB  3
2932:  MOVWF  x5F
2934:  MOVLW  5A
2936:  MOVWF  x5E
2938:  MOVLB  0
293A:  BRA    267A
293C:  MOVFF  01,359
....................       mmcsd_deselect(); 
2940:  RCALL  246A
....................       if(r1 != MMCSD_ILLEGAL_CMD) { 
2942:  MOVLB  3
2944:  MOVF   x59,W
2946:  SUBLW  04
2948:  BZ    295A
....................         r1 = r3[3]; 
294A:  MOVFF  35D,359
....................         if(bit_test(r1, 6))                  // If bit 30 of the OCR register is 1 (CCS is 1) ==> SDHC type 
294E:  BTFSS  x59.6
2950:  BRA    295A
....................           g_card_type =  SDHC; 
2952:  MOVLW  02
2954:  MOVLB  2
2956:  MOVWF  x09
2958:  MOVLB  3
....................       } 
....................    } 
....................  
....................    /* set block length to 512 bytes */ 
....................    mmcsd_select(); 
295A:  MOVLB  0
295C:  RCALL  247E
....................    r1 = mmcsd_set_blocklen(MMCSD_MAX_BLOCK_SIZE); 
295E:  MOVLB  3
2960:  CLRF   x61
2962:  CLRF   x60
2964:  MOVLW  02
2966:  MOVWF  x5F
2968:  CLRF   x5E
296A:  MOVLB  0
296C:  BRA    269C
296E:  MOVFF  01,359
....................    mmcsd_deselect(); 
2972:  RCALL  246A
....................    if(r1 != MMCSD_GOODEC) 
2974:  MOVLB  3
2976:  MOVF   x59,F
2978:  BZ    2980
....................      return r1; 
297A:  MOVFF  359,01
297E:  BRA    29AE
....................  
.................... /// this would be a good time to set a higher clock speed, 20MHz 
.................... #ifdef MMCSD_SPI_HW 
....................   setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
2980:  BCF    FC6.5
2982:  BCF    F94.7
2984:  BSF    F93.0
2986:  BCF    F93.1
2988:  MOVLW  30
298A:  MOVWF  FC6
298C:  MOVLW  00
298E:  MOVWF  FC7
.................... #else 
....................   #use spi(MASTER, DI=MMCSD_PIN_MISO, DO=MMCSD_PIN_MOSI, CLK=MMCSD_PIN_SCK, BITS=8, MODE=3) 
.................... #endif 
....................  
....................    // Turn OFF CRC check, some card return 0 (MMCSD_GOODEC) and some others return 0x04 (MMCSD_ILLEGAL_CMD) 
....................    mmcsd_select(); 
2990:  MOVLB  0
2992:  RCALL  247E
....................    r1 = mmcsd_crc_on_off(FALSE); 
2994:  MOVLB  3
2996:  CLRF   x5E
2998:  MOVLB  0
299A:  BRA    26BE
299C:  MOVFF  01,359
....................    mmcsd_deselect(); 
29A0:  RCALL  246A
....................    r1 = mmcsd_load_buffer(); 
29A2:  RCALL  27D2
29A4:  MOVFF  01,359
....................  
....................    return MMCSD_GOODEC; 
29A8:  MOVLW  00
29AA:  MOVWF  01
29AC:  MOVLB  3
29AE:  MOVLB  0
29B0:  GOTO   2CC8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err r1; 
....................    uint16_t i;  // counter for loops 
....................  
....................    for(i = 0; i < size; i++) 
*
2BB8:  MOVLB  4
2BBA:  CLRF   x20
2BBC:  CLRF   x1F
2BBE:  MOVF   x20,W
2BC0:  SUBWF  x1B,W
2BC2:  BNC   2C38
2BC4:  BNZ   2BCC
2BC6:  MOVF   x1A,W
2BC8:  SUBWF  x1F,W
2BCA:  BC    2C38
....................    { 
....................       r1 = mmcsd_read_byte(address++, ptr++); 
2BCC:  MOVFF  419,42A
2BD0:  MOVFF  418,02
2BD4:  MOVFF  417,01
2BD8:  MOVFF  416,00
2BDC:  MOVLW  01
2BDE:  ADDWF  x16,F
2BE0:  BTFSC  FD8.0
2BE2:  INCF   x17,F
2BE4:  BTFSC  FD8.2
2BE6:  INCF   x18,F
2BE8:  BTFSC  FD8.2
2BEA:  INCF   x19,F
2BEC:  MOVFF  02,423
2BF0:  MOVFF  01,422
2BF4:  MOVFF  00,421
2BF8:  MOVFF  41D,03
2BFC:  MOVF   x1C,W
2BFE:  INCF   x1C,F
2C00:  BTFSC  FD8.2
2C02:  INCF   x1D,F
2C04:  MOVWF  x25
2C06:  MOVFF  03,426
2C0A:  MOVFF  02,429
2C0E:  MOVFF  01,428
2C12:  MOVFF  00,427
2C16:  MOVFF  03,42C
2C1A:  MOVWF  x2B
2C1C:  MOVLB  0
2C1E:  BRA    2B66
2C20:  MOVFF  01,41E
....................       if(r1 != MMCSD_GOODEC) 
2C24:  MOVLB  4
2C26:  MOVF   x1E,F
2C28:  BZ    2C30
....................          return r1; 
2C2A:  MOVFF  41E,01
2C2E:  BRA    2C3C
2C30:  INCF   x1F,F
2C32:  BTFSC  FD8.2
2C34:  INCF   x20,F
2C36:  BRA    2BBE
....................    } 
....................     
....................    return MMCSD_GOODEC; 
2C38:  MOVLW  00
2C3A:  MOVWF  01
2C3C:  MOVLB  0
2C3E:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {   
....................    MMCSD_err ec; 
....................    uint16_t i; // counter for loops 
....................   
....................    // send command 
....................    mmcsd_select(); 
*
272C:  RCALL  247E
....................    ec = mmcsd_read_single_block(address); 
272E:  MOVFF  44C,457
2732:  MOVFF  44B,456
2736:  MOVFF  44A,455
273A:  MOVFF  449,454
273E:  BRA    26EC
2740:  MOVFF  01,451
....................    if(ec != MMCSD_GOODEC) 
2744:  MOVLB  4
2746:  MOVF   x51,F
2748:  BZ    2756
....................    { 
....................       mmcsd_deselect(); 
274A:  MOVLB  0
274C:  RCALL  246A
....................       return ec; 
274E:  MOVLB  4
2750:  MOVFF  451,01
2754:  BRA    27CC
....................    } 
....................     
....................    // wait for the data start token 
....................    ec = mmcsd_wait_for_token(DATA_START_TOKEN); 
2756:  MOVLW  FE
2758:  MOVWF  x54
275A:  MOVLB  0
275C:  BRA    270E
275E:  MOVFF  01,451
....................    if(ec != MMCSD_GOODEC) 
2762:  MOVLB  4
2764:  MOVF   x51,F
2766:  BZ    2774
....................    { 
....................       mmcsd_deselect(); 
2768:  MOVLB  0
276A:  RCALL  246A
....................       return ec; 
276C:  MOVLB  4
276E:  MOVFF  451,01
2772:  BRA    27CC
....................    } 
....................     
....................    // read in the data 
....................    for(i = 0; i < size; i += 1) 
2774:  CLRF   x53
2776:  CLRF   x52
2778:  MOVF   x53,W
277A:  SUBWF  x4E,W
277C:  BNC   27B6
277E:  BNZ   2786
2780:  MOVF   x4D,W
2782:  SUBWF  x52,W
2784:  BC    27B6
....................       ptr[i] = MMCSD_SPI_XFER(0xFF); 
2786:  MOVF   x4F,W
2788:  ADDWF  x52,W
278A:  MOVWF  01
278C:  MOVF   x50,W
278E:  ADDWFC x53,W
2790:  MOVWF  03
2792:  MOVFF  01,454
2796:  MOVWF  x55
2798:  SETF   x63
279A:  MOVLB  0
279C:  RCALL  246E
279E:  MOVFF  455,FEA
27A2:  MOVFF  454,FE9
27A6:  MOVFF  01,FEF
27AA:  MOVLW  01
27AC:  MOVLB  4
27AE:  ADDWF  x52,F
27B0:  MOVLW  00
27B2:  ADDWFC x53,F
27B4:  BRA    2778
....................  
....................  /*  if(g_CRC_enabled)   // already FALSE 
....................    { 
....................       // check the crc 
....................       if(make16(MMCSD_SPI_XFER(0xFF), MMCSD_SPI_XFER(0xFF)) != mmcsd_crc16(g_mmcsd_buffer, MMCSD_MAX_BLOCK_SIZE)) 
....................       { 
....................          mmcsd_deselect(); 
....................          return MMCSD_CRC_ERR; 
....................       } 
....................    } 
....................    else 
....................    { */ 
....................       /* have the card transmit the CRC, but ignore it */ 
....................       MMCSD_SPI_XFER(0xFF); 
27B6:  SETF   x63
27B8:  MOVLB  0
27BA:  RCALL  246E
....................       MMCSD_SPI_XFER(0xFF); 
27BC:  MOVLB  4
27BE:  SETF   x63
27C0:  MOVLB  0
27C2:  RCALL  246E
.................... //   } 
....................    mmcsd_deselect(); 
27C4:  RCALL  246A
....................  
....................    return MMCSD_GOODEC; 
27C6:  MOVLW  00
27C8:  MOVWF  01
27CA:  MOVLB  4
27CC:  MOVLB  0
27CE:  GOTO   27F8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err ec; 
....................    uint16_t i;  // counter for loops 
....................    
....................    for(i = 0; i < size; i++) 
*
3A60:  MOVLB  4
3A62:  CLRF   x34
3A64:  CLRF   x33
3A66:  MOVF   x34,W
3A68:  SUBWF  x2F,W
3A6A:  BNC   3ADE
3A6C:  BNZ   3A74
3A6E:  MOVF   x2E,W
3A70:  SUBWF  x33,W
3A72:  BC    3ADE
....................    { 
....................       ec = mmcsd_write_byte(address++, *ptr++); 
3A74:  MOVFF  42D,43D
3A78:  MOVFF  42C,02
3A7C:  MOVFF  42B,01
3A80:  MOVFF  42A,00
3A84:  MOVLW  01
3A86:  ADDWF  x2A,F
3A88:  BTFSC  FD8.0
3A8A:  INCF   x2B,F
3A8C:  BTFSC  FD8.2
3A8E:  INCF   x2C,F
3A90:  BTFSC  FD8.2
3A92:  INCF   x2D,F
3A94:  MOVFF  02,437
3A98:  MOVFF  01,436
3A9C:  MOVFF  00,435
3AA0:  MOVFF  431,03
3AA4:  MOVF   x30,W
3AA6:  INCF   x30,F
3AA8:  BTFSC  FD8.2
3AAA:  INCF   x31,F
3AAC:  MOVWF  FE9
3AAE:  MOVFF  03,FEA
3AB2:  MOVFF  FEF,43E
3AB6:  MOVFF  02,43C
3ABA:  MOVFF  01,43B
3ABE:  MOVFF  00,43A
3AC2:  MOVLB  0
3AC4:  BRA    3A12
3AC6:  MOVFF  01,432
....................       if(ec != MMCSD_GOODEC) 
3ACA:  MOVLB  4
3ACC:  MOVF   x32,F
3ACE:  BZ    3AD6
....................          return ec; 
3AD0:  MOVFF  432,01
3AD4:  BRA    3AE2
3AD6:  INCF   x33,F
3AD8:  BTFSC  FD8.2
3ADA:  INCF   x34,F
3ADC:  BRA    3A66
....................    } 
....................     
....................    return MMCSD_GOODEC; 
3ADE:  MOVLW  00
3AE0:  MOVWF  01
3AE2:  MOVLB  0
3AE4:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {  
....................    MMCSD_err ec; 
....................    uint16_t i; 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
29D6:  RCALL  247E
....................    ec = mmcsd_write_single_block(address); 
29D8:  MOVFF  44C,457
29DC:  MOVFF  44B,456
29E0:  MOVFF  44A,455
29E4:  MOVFF  449,454
29E8:  BRA    29B4
29EA:  MOVFF  01,451
....................    if(ec != MMCSD_GOODEC) 
29EE:  MOVLB  4
29F0:  MOVF   x51,F
29F2:  BZ    2A00
....................    { 
....................       mmcsd_deselect(); 
29F4:  MOVLB  0
29F6:  RCALL  246A
....................       return ec; 
29F8:  MOVLB  4
29FA:  MOVFF  451,01
29FE:  BRA    2A7C
....................    } 
....................     
....................    // send a data start token 
....................    MMCSD_SPI_XFER(DATA_START_TOKEN); 
2A00:  MOVLW  FE
2A02:  MOVWF  x63
2A04:  MOVLB  0
2A06:  RCALL  246E
....................     
....................    // send all the data 
....................    for(i = 0; i < size; i += 1) 
2A08:  MOVLB  4
2A0A:  CLRF   x53
2A0C:  CLRF   x52
2A0E:  MOVF   x53,W
2A10:  SUBWF  x4E,W
2A12:  BNC   2A3C
2A14:  BNZ   2A1C
2A16:  MOVF   x4D,W
2A18:  SUBWF  x52,W
2A1A:  BC    2A3C
....................    { 
....................       MMCSD_SPI_XFER(ptr[i]); 
2A1C:  MOVF   x4F,W
2A1E:  ADDWF  x52,W
2A20:  MOVWF  FE9
2A22:  MOVF   x50,W
2A24:  ADDWFC x53,W
2A26:  MOVWF  FEA
2A28:  MOVFF  FEF,463
2A2C:  MOVLB  0
2A2E:  RCALL  246E
2A30:  MOVLW  01
2A32:  MOVLB  4
2A34:  ADDWF  x52,F
2A36:  MOVLW  00
2A38:  ADDWFC x53,F
2A3A:  BRA    2A0E
....................    } 
....................  
....................    // if the CRC is enabled we have to calculate it, otherwise just send an 0xFFFF 
.................... /*   if(g_CRC_enabled)   // already FALSE 
....................       MMCSD_SPI_XFER(mmcsd_crc16(ptr, size)); 
....................    else 
....................    {   */ 
....................       MMCSD_SPI_XFER(0xFF); 
2A3C:  SETF   x63
2A3E:  MOVLB  0
2A40:  RCALL  246E
....................       MMCSD_SPI_XFER(0xFF); 
2A42:  MOVLB  4
2A44:  SETF   x63
2A46:  MOVLB  0
2A48:  RCALL  246E
.................... //   } 
....................     
....................    // get the error code back from the card; "data accepted" is 0bXXX00101 
....................    ec = mmcsd_get_r1(); 
2A4A:  RCALL  253E
2A4C:  MOVFF  01,451
....................    if(ec & 0x0A) 
2A50:  MOVLB  4
2A52:  MOVF   x51,W
2A54:  ANDLW  0A
2A56:  BZ    2A64
....................    { 
....................       mmcsd_deselect(); 
2A58:  MOVLB  0
2A5A:  RCALL  246A
....................       return ec; 
2A5C:  MOVLB  4
2A5E:  MOVFF  451,01
2A62:  BRA    2A7C
....................    } 
....................     
....................    // wait for the line to go back high, this indicates that the write is complete 
....................    while(MMCSD_SPI_XFER(0xFF) == 0); 
2A64:  SETF   x63
2A66:  MOVLB  0
2A68:  RCALL  246E
2A6A:  MOVF   01,F
2A6C:  BTFSS  FD8.2
2A6E:  BRA    2A74
2A70:  MOVLB  4
2A72:  BRA    2A64
....................    mmcsd_deselect(); 
2A74:  RCALL  246A
....................  
....................    return MMCSD_GOODEC; 
2A76:  MOVLW  00
2A78:  MOVWF  01
2A7A:  MOVLB  4
2A7C:  MOVLB  0
2A7E:  GOTO   2AAC (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_go_idle_state(void) 
.................... { 
....................    mmcsd_send_cmd(GO_IDLE_STATE, 0); 
*
256C:  MOVLB  4
256E:  CLRF   x58
2570:  CLRF   x5C
2572:  CLRF   x5B
2574:  CLRF   x5A
2576:  CLRF   x59
2578:  MOVLB  0
257A:  RCALL  24D6
....................     
....................    return mmcsd_get_r1(); 
257C:  RCALL  253E
257E:  MOVF   01,W
2580:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SEND_OP_COND, 0); 
2582:  MOVLW  01
2584:  MOVLB  4
2586:  MOVWF  x58
2588:  CLRF   x5C
258A:  CLRF   x5B
258C:  CLRF   x5A
258E:  CLRF   x59
2590:  MOVLB  0
2592:  RCALL  24D6
....................     
....................    return mmcsd_get_r1(); 
2594:  RCALL  253E
2596:  MOVF   01,W
2598:  GOTO   2886 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_IF_COND, 0x1AA); 
*
260E:  MOVLW  08
2610:  MOVLB  4
2612:  MOVWF  x58
2614:  CLRF   x5C
2616:  CLRF   x5B
2618:  MOVLW  01
261A:  MOVWF  x5A
261C:  MOVLW  AA
261E:  MOVWF  x59
2620:  MOVLB  0
2622:  RCALL  24D6
....................  
....................    return mmcsd_get_r7(r7); 
2624:  MOVFF  35F,363
2628:  MOVFF  35E,362
262C:  RCALL  259C
262E:  MOVF   01,W
2630:  GOTO   28CC (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_print_csd() 
.................... {   
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................  
....................    mmcsd_select();    
....................    mmcsd_send_cmd(SEND_CSD, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................  
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
.................... /* 
....................    printf("\r\nCSD_STRUCTURE: %X", (buf[0] & 0x0C) >> 2); 
....................    printf("\r\nTAAC: %X", buf[1]); 
....................    printf("\r\nNSAC: %X", buf[2]); 
....................    printf("\r\nTRAN_SPEED: %X", buf[3]); 
....................    printf("\r\nCCC: %lX", (make16(buf[4], buf[5]) & 0xFFF0) >> 4); 
....................    printf("\r\nREAD_BL_LEN: %X", buf[5] & 0x0F);    
....................    printf("\r\nREAD_BL_PARTIAL: %X", (buf[6] & 0x80) >> 7); 
....................    printf("\r\nWRITE_BLK_MISALIGN: %X", (buf[6] & 0x40) >> 6); 
....................    printf("\r\nREAD_BLK_MISALIGN: %X", (buf[6] & 0x20) >> 5); 
....................    printf("\r\nDSR_IMP: %X", (buf[6] & 0x10) >> 4); 
....................    printf("\r\nC_SIZE: %lX", (((buf[6] & 0x03) << 10) | (buf[7] << 2) | ((buf[8] & 0xC0) >> 6))); 
....................    printf("\r\nVDD_R_CURR_MIN: %X", (buf[8] & 0x38) >> 3); 
....................    printf("\r\nVDD_R_CURR_MAX: %X", buf[8] & 0x07); 
....................    printf("\r\nVDD_W_CURR_MIN: %X", (buf[9] & 0xE0) >> 5); 
....................    printf("\r\nVDD_W_CURR_MAX: %X", (buf[9] & 0x1C) >> 2); 
....................    printf("\r\nC_SIZE_MULT: %X", ((buf[9] & 0x03) << 1) | ((buf[10] & 0x80) >> 7)); 
....................    printf("\r\nERASE_BLK_EN: %X", (buf[10] & 0x40) >> 6); 
....................    printf("\r\nSECTOR_SIZE: %X", ((buf[10] & 0x3F) << 1) | ((buf[11] & 0x80) >> 7)); 
....................    printf("\r\nWP_GRP_SIZE: %X", buf[11] & 0x7F); 
....................    printf("\r\nWP_GRP_ENABLE: %X", (buf[12] & 0x80) >> 7); 
....................    printf("\r\nR2W_FACTOR: %X", (buf[12] & 0x1C) >> 2); 
....................    printf("\r\nWRITE_BL_LEN: %X", ((buf[12] & 0x03) << 2) | ((buf[13] & 0xC0) >> 6)); 
....................    printf("\r\nWRITE_BL_PARTIAL: %X", (buf[13] & 0x20) >> 5); 
....................    printf("\r\nFILE_FORMAT_GRP: %X", (buf[14] & 0x80) >> 7); 
....................    printf("\r\nCOPY: %X", (buf[14] & 0x40) >> 6); 
....................    printf("\r\nPERM_WRITE_PROTECT: %X", (buf[14] & 0x20) >> 5); 
....................    printf("\r\nTMP_WRITE_PROTECT: %X", (buf[14] & 0x10) >> 4); 
....................    printf("\r\nFILE_FORMAT: %X", (buf[14] & 0x0C) >> 2); 
....................    printf("\r\nCRC: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_cid() 
.................... { 
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................     
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SEND_CID, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
....................    /* 
....................    printf("\r\nManufacturer ID: %X", buf[0]); 
....................    printf("\r\nOEM/Application ID: %c%c", buf[1], buf[2]); 
....................    printf("\r\nOEM/Application ID: %c%c%c%c%c", buf[3], buf[4], buf[5], buf[6], buf[7]); 
....................    printf("\r\nProduct Revision: %X", buf[8]); 
....................    printf("\r\nSerial Number: %X%X%X%X", buf[9], buf[10], buf[11], buf[12]); 
....................    printf("\r\nManufacturer Date Code: %X%X", buf[13] & 0x0F, buf[14]); 
....................    printf("\r\nCRC-7 Checksum: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]) 
.................... { 
....................    uint8_t i; 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(APP_CMD, 0); 
....................    r2[0]=mmcsd_get_r1(); 
....................    mmcsd_deselect(); 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SD_STATUS, 0); 
....................  
....................    for(i = 0; i < 64; i++) 
....................       MMCSD_SPI_XFER(0xFF);       
....................  
....................    mmcsd_deselect(); 
....................  
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_STATUS, 0);    
....................     
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen) 
.................... { 
....................    mmcsd_send_cmd(SET_BLOCKLEN, blocklen); 
*
269C:  MOVLW  10
269E:  MOVLB  4
26A0:  MOVWF  x58
26A2:  MOVFF  361,45C
26A6:  MOVFF  360,45B
26AA:  MOVFF  35F,45A
26AE:  MOVFF  35E,459
26B2:  MOVLB  0
26B4:  RCALL  24D6
....................     
....................    return mmcsd_get_r1(); 
26B6:  RCALL  253E
26B8:  MOVF   01,W
26BA:  GOTO   296E (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(READ_SINGLE_BLOCK, address); 
*
26EC:  MOVLW  11
26EE:  MOVLB  4
26F0:  MOVWF  x58
26F2:  MOVFF  457,45C
26F6:  MOVFF  456,45B
26FA:  MOVFF  455,45A
26FE:  MOVFF  454,459
2702:  MOVLB  0
2704:  RCALL  24D6
....................     
....................    return mmcsd_get_r1(); 
2706:  RCALL  253E
2708:  MOVF   01,W
270A:  GOTO   2740 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(WRITE_BLOCK, address); 
*
29B4:  MOVLW  18
29B6:  MOVLB  4
29B8:  MOVWF  x58
29BA:  MOVFF  457,45C
29BE:  MOVFF  456,45B
29C2:  MOVFF  455,45A
29C6:  MOVFF  454,459
29CA:  MOVLB  0
29CC:  RCALL  24D6
....................    
....................    return mmcsd_get_r1(); 
29CE:  RCALL  253E
29D0:  MOVF   01,W
29D2:  GOTO   29EA (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SD_SEND_OP_COND, 0x40000000); 
*
264E:  MOVLW  29
2650:  MOVLB  4
2652:  MOVWF  x58
2654:  MOVLW  40
2656:  MOVWF  x5C
2658:  CLRF   x5B
265A:  CLRF   x5A
265C:  CLRF   x59
265E:  MOVLB  0
2660:  RCALL  24D6
....................     
....................    return mmcsd_get_r1(); 
2662:  RCALL  253E
2664:  MOVF   01,W
2666:  GOTO   28EE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_app_cmd(void) 
.................... { 
....................    mmcsd_send_cmd(APP_CMD, 0); 
*
2634:  MOVLW  37
2636:  MOVLB  4
2638:  MOVWF  x58
263A:  CLRF   x5C
263C:  CLRF   x5B
263E:  CLRF   x5A
2640:  CLRF   x59
2642:  MOVLB  0
2644:  RCALL  24D6
....................     
....................    return mmcsd_get_r1(); 
2646:  RCALL  253E
2648:  MOVF   01,W
264A:  GOTO   28E8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_ocr(int r3[]) 
.................... { 
....................    mmcsd_send_cmd(READ_OCR, 0); 
*
267A:  MOVLW  3A
267C:  MOVLB  4
267E:  MOVWF  x58
2680:  CLRF   x5C
2682:  CLRF   x5B
2684:  CLRF   x5A
2686:  CLRF   x59
2688:  MOVLB  0
268A:  RCALL  24D6
....................     
....................    return mmcsd_get_r3(r3); 
268C:  MOVFF  35F,361
2690:  MOVFF  35E,360
2694:  BRA    266A
2696:  MOVF   01,W
2698:  GOTO   293C (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled) 
.................... { 
....................    mmcsd_send_cmd(CRC_ON_OFF, crc_enabled); 
*
26BE:  MOVLW  3B
26C0:  MOVLB  4
26C2:  MOVWF  x58
26C4:  CLRF   x5C
26C6:  CLRF   x5B
26C8:  CLRF   x5A
26CA:  MOVFF  35E,459
26CE:  MOVLB  0
26D0:  RCALL  24D6
....................     
....................    g_CRC_enabled = crc_enabled; 
26D2:  MOVLB  2
26D4:  BCF    x04.0
26D6:  MOVLB  3
26D8:  BTFSS  x5E.0
26DA:  BRA    26E2
26DC:  MOVLB  2
26DE:  BSF    x04.0
26E0:  MOVLB  3
....................     
....................    return mmcsd_get_r1(); 
26E2:  MOVLB  0
26E4:  RCALL  253E
26E6:  MOVF   01,W
26E8:  GOTO   299C (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg) 
.................... {    
....................    uint8_t packet[6]; // the entire command, argument, and crc in one variable 
....................  
....................    // construct the packet 
....................    // every command on an SD card is or'ed with 0x40 
....................    packet[0] = cmd | 0x40; 
*
24D6:  MOVLB  4
24D8:  MOVF   x58,W
24DA:  IORLW  40
24DC:  MOVWF  x5D
....................    packet[1] = make8(arg, 3); 
24DE:  MOVFF  45C,45E
....................    packet[2] = make8(arg, 2); 
24E2:  MOVFF  45B,45F
....................    packet[3] = make8(arg, 1); 
24E6:  MOVFF  45A,460
....................    packet[4] = make8(arg, 0); 
24EA:  MOVFF  459,461
....................  
....................    // calculate the crc if needed 
....................    if(g_CRC_enabled) 
24EE:  MOVLB  2
24F0:  BTFSS  x04.0
24F2:  BRA    250E
....................       packet[5] = mmcsd_crc7(packet, 5); 
24F4:  MOVLW  04
24F6:  MOVLB  4
24F8:  MOVWF  x64
24FA:  MOVLW  5D
24FC:  MOVWF  x63
24FE:  MOVLW  05
2500:  MOVWF  x65
2502:  MOVLB  0
2504:  BRA    2482
2506:  MOVFF  01,462
250A:  BRA    2514
250C:  MOVLB  2
....................    else 
....................       packet[5] = 0xFF; 
250E:  MOVLB  4
2510:  SETF   x62
2512:  MOVLB  0
....................  
....................    // transfer the command and argument, with an extra 0xFF hacked in there 
....................    MMCSD_SPI_XFER(packet[0]); 
2514:  MOVFF  45D,463
2518:  RCALL  246E
....................    MMCSD_SPI_XFER(packet[1]); 
251A:  MOVFF  45E,463
251E:  RCALL  246E
....................    MMCSD_SPI_XFER(packet[2]); 
2520:  MOVFF  45F,463
2524:  RCALL  246E
....................    MMCSD_SPI_XFER(packet[3]); 
2526:  MOVFF  460,463
252A:  RCALL  246E
....................    MMCSD_SPI_XFER(packet[4]); 
252C:  MOVFF  461,463
2530:  RCALL  246E
....................    MMCSD_SPI_XFER(packet[5]); 
2532:  MOVFF  462,463
2536:  RCALL  246E
.................... //!   spi_write2(packet[0]); 
.................... //!   spi_write2(packet[1]); 
.................... //!   spi_write2(packet[2]); 
.................... //!   spi_write2(packet[3]); 
.................... //!   spi_write2(packet[4]); 
.................... //!   spi_write2(packet[5]); 
....................     
....................  
....................    return MMCSD_GOODEC; 
2538:  MOVLW  00
253A:  MOVWF  01
253C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r1(void) 
253E:  MOVLB  4
2540:  CLRF   x58
2542:  SETF   x59
.................... { 
....................    uint8_t 
....................       response = 0,  // place to hold the response coming back from the SPI line 
....................       timeout = 0xFF; // maximum amount loops to wait for idle before getting impatient and leaving the function with an error code 
....................      
....................    // loop until timeout == 0 
....................    while(timeout) 
2544:  MOVF   x59,F
2546:  BZ    2564
....................    { 
....................       // read what's on the SPI line 
....................       //  the SD/MMC requires that you leave the line high when you're waiting for data from it 
....................       response = MMCSD_SPI_XFER(0xFF); 
2548:  SETF   x63
254A:  MOVLB  0
254C:  RCALL  246E
254E:  MOVFF  01,458
....................       //response = MMCSD_SPI_XFER(0x00);//leave the line idle 
....................        
....................       // check to see if we got a response 
....................       if(response != 0xFF) 
2552:  MOVLB  4
2554:  INCFSZ x58,W
2556:  BRA    255A
2558:  BRA    2560
....................       {    
....................          // fill in the response that we got and leave the function 
....................          return response; 
255A:  MOVFF  458,01
255E:  BRA    2568
....................       } 
....................  
....................       // wait for a little bit longer 
....................       timeout--; 
2560:  DECF   x59,F
2562:  BRA    2544
....................    } 
....................     
....................    // for some reason, we didn't get a response back from the card 
....................    //  return the proper error codes 
....................    return RESP_TIMEOUT; 
2564:  MOVLW  80
2566:  MOVWF  01
2568:  MOVLB  0
256A:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]) 
.................... { 
....................    r2[1] = mmcsd_get_r1(); 
....................     
....................    r2[0] = MMCSD_SPI_XFER(0xFF); 
....................     
....................    return 0; 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]) 
.................... { 
....................    return mmcsd_get_r7(r3); 
*
266A:  MOVFF  361,363
266E:  MOVFF  360,362
2672:  RCALL  259C
2674:  MOVF   01,W
2676:  GOTO   2696 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]) 
.................... { 
....................    uint8_t i;   // counter for loop 
....................     
....................    // the top byte of r7 is r1 
....................    r7[4]=mmcsd_get_r1(); 
*
259C:  MOVLW  04
259E:  MOVLB  3
25A0:  ADDWF  x62,W
25A2:  MOVWF  01
25A4:  MOVLW  00
25A6:  ADDWFC x63,W
25A8:  MOVWF  03
25AA:  MOVFF  01,365
25AE:  MOVWF  x66
25B0:  MOVLB  0
25B2:  RCALL  253E
25B4:  MOVFF  366,FEA
25B8:  MOVFF  365,FE9
25BC:  MOVFF  01,FEF
....................     
....................    // fill in the other 4 bytes 
....................    for(i = 0; i < 4; i++) 
25C0:  MOVLB  3
25C2:  CLRF   x64
25C4:  MOVF   x64,W
25C6:  SUBLW  03
25C8:  BNC   25FA
....................       r7[3 - i] = MMCSD_SPI_XFER(0xFF); 
25CA:  MOVLW  03
25CC:  BSF    FD8.0
25CE:  SUBFWB x64,W
25D0:  ADDWF  x62,W
25D2:  MOVWF  01
25D4:  MOVLW  00
25D6:  ADDWFC x63,W
25D8:  MOVWF  03
25DA:  MOVFF  01,365
25DE:  MOVWF  x66
25E0:  MOVLB  4
25E2:  SETF   x63
25E4:  MOVLB  0
25E6:  RCALL  246E
25E8:  MOVFF  366,FEA
25EC:  MOVFF  365,FE9
25F0:  MOVFF  01,FEF
25F4:  MOVLB  3
25F6:  INCF   x64,F
25F8:  BRA    25C4
....................  
....................    return r7[4]; 
25FA:  MOVLW  04
25FC:  ADDWF  x62,W
25FE:  MOVWF  FE9
2600:  MOVLW  00
2602:  ADDWFC x63,W
2604:  MOVWF  FEA
2606:  MOVFF  FEF,01
260A:  MOVLB  0
260C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token) 
.................... { 
....................    MMCSD_err r1; 
....................     
....................    // get a token 
....................    r1 = mmcsd_get_r1(); 
*
270E:  RCALL  253E
2710:  MOVFF  01,455
....................     
....................    // check to see if the token we recieved was the one that we were looking for 
....................    if(r1 == token) 
2714:  MOVLB  4
2716:  MOVF   x54,W
2718:  SUBWF  x55,W
271A:  BNZ   2722
....................       return MMCSD_GOODEC; 
271C:  MOVLW  00
271E:  MOVWF  01
2720:  BRA    2726
....................     
....................    // if that wasn't right, return the error 
....................    return r1;    
2722:  MOVFF  455,01
2726:  MOVLB  0
2728:  GOTO   275E (RETURN)
.................... } 
....................  
.................... unsigned int8 mmcsd_crc7(char *data,uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c, crc; 
....................      
....................    crc = 0x00;                                                                // Set initial value 
*
2482:  MOVLB  4
2484:  CLRF   x69
....................  
....................    for (i = 0; i < length; i++, data++) 
2486:  CLRF   x66
2488:  MOVF   x65,W
248A:  SUBWF  x66,W
248C:  BC    24C8
....................    { 
....................       c = *data; 
248E:  MOVFF  463,FE9
2492:  MOVFF  464,FEA
2496:  MOVFF  FEF,468
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
249A:  CLRF   x67
249C:  MOVF   x67,W
249E:  SUBLW  07
24A0:  BNC   24BA
....................       { 
....................          crc = crc << 1; 
24A2:  BCF    FD8.0
24A4:  RLCF   x69,F
....................          if ((c ^ crc) & 0x80) crc = crc ^ 0x09;                              // ^ is XOR 
24A6:  MOVF   x68,W
24A8:  XORWF  x69,W
24AA:  ANDLW  80
24AC:  BZ    24B2
24AE:  MOVLW  09
24B0:  XORWF  x69,F
....................          c = c << 1; 
24B2:  BCF    FD8.0
24B4:  RLCF   x68,F
24B6:  INCF   x67,F
24B8:  BRA    249C
....................       } 
....................  
....................        crc = crc & 0x7F; 
24BA:  BCF    x69.7
24BC:  MOVF   x66,W
24BE:  INCF   x66,F
24C0:  INCF   x63,F
24C2:  BTFSC  FD8.2
24C4:  INCF   x64,F
24C6:  BRA    2488
....................    } 
....................  
....................    shift_left(&crc, 1, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
24C8:  BSF    FD8.0
24CA:  RLCF   x69,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
24CC:  MOVFF  469,01
24D0:  MOVLB  0
24D2:  GOTO   2506 (RETURN)
.................... } 
....................  
.................... /* Not needed function (CRC is OFF) 
.................... uint16_t mmcsd_crc16(char *data, uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c; 
....................  
....................    uint16_t crc; 
....................  
....................    crc = 0x0000;                                                                // Set initial value 
....................  
....................    for (i = 0; i < length; i++, data++) 
....................    { 
....................       c = *data; 
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
....................       { 
....................          crc = crc << 1; 
....................          if ((c ^ crc) & 0x8000) crc = crc ^ 0x1021;                              // ^ is XOR 
....................          c = c << 1; 
....................       } 
....................  
....................        crc = crc & 0x7FFF; 
....................    } 
....................  
....................    shift_left(&crc, 2, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
.................... } 
.................... */ 
....................  
.................... void mmcsd_select() 
.................... { 
....................    output_low(MMCSD_PIN_SELECT); 
*
247E:  BCF    F89.2
2480:  RETURN 0
.................... } 
....................  
.................... void mmcsd_deselect() 
.................... { 
....................    //MMCSD_SPI_XFER(0xFF); 
....................    output_high(MMCSD_PIN_SELECT); 
*
246A:  BSF    F89.2
246C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_load_buffer(void) 
.................... { 
....................    g_MMCSDBufferChanged = FALSE; 
*
27D2:  MOVLB  2
27D4:  BCF    x04.1
....................    return(mmcsd_read_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
27D6:  MOVFF  208,44C
27DA:  MOVFF  207,44B
27DE:  MOVFF  206,44A
27E2:  MOVFF  205,449
27E6:  MOVLW  02
27E8:  MOVLB  4
27EA:  MOVWF  x4E
27EC:  CLRF   x4D
27EE:  CLRF   x50
27F0:  MOVLW  04
27F2:  MOVWF  x4F
27F4:  MOVLB  0
27F6:  BRA    272C
27F8:  MOVF   01,W
27FA:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_flush_buffer(void) 
.................... { 
....................    if (g_MMCSDBufferChanged) 
*
2A82:  MOVLB  2
2A84:  BTFSS  x04.1
2A86:  BRA    2AB2
....................    { 
....................       g_MMCSDBufferChanged = FALSE; 
2A88:  BCF    x04.1
....................       return(mmcsd_write_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
2A8A:  MOVFF  208,44C
2A8E:  MOVFF  207,44B
2A92:  MOVFF  206,44A
2A96:  MOVFF  205,449
2A9A:  MOVLW  02
2A9C:  MOVLB  4
2A9E:  MOVWF  x4E
2AA0:  CLRF   x4D
2AA2:  CLRF   x50
2AA4:  MOVLW  04
2AA6:  MOVWF  x4F
2AA8:  MOVLB  0
2AAA:  BRA    29D6
2AAC:  MOVF   01,W
2AAE:  BRA    2AB8
2AB0:  MOVLB  2
....................    } 
....................    return(0);  //ok 
2AB2:  MOVLW  00
2AB4:  MOVWF  01
2AB6:  MOVLB  0
2AB8:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr) 
2ABA:  MOVLB  4
2ABC:  CLRF   x44
.................... { 
....................    MMCSD_err ec = MMCSD_GOODEC; 
....................    uint32_t 
....................       //cur_block, 
....................       new_block; 
....................     
....................    // make sure we're still on the same block 
....................    //cur_block = g_mmcsdBufferAddress - (g_mmcsdBufferAddress % MMCSD_MAX_BLOCK_SIZE); 
....................    if(g_card_type == SDHC) 
2ABE:  MOVLB  2
2AC0:  MOVF   x09,W
2AC2:  SUBLW  02
2AC4:  BNZ   2ADC
....................      new_block = new_addr / MMCSD_MAX_BLOCK_SIZE; 
2AC6:  BCF    FD8.0
2AC8:  MOVLB  4
2ACA:  CLRF   x48
2ACC:  RRCF   x43,W
2ACE:  MOVWF  x47
2AD0:  RRCF   x42,W
2AD2:  MOVWF  x46
2AD4:  RRCF   x41,W
2AD6:  MOVWF  x45
2AD8:  BRA    2B00
2ADA:  MOVLB  2
....................    else 
....................      new_block = new_addr - (new_addr % MMCSD_MAX_BLOCK_SIZE); 
2ADC:  MOVLB  4
2ADE:  MOVF   x41,W
2AE0:  ANDLW  01
2AE2:  MOVWF  01
2AE4:  CLRF   02
2AE6:  CLRF   03
2AE8:  MOVF   x40,W
2AEA:  SUBWF  x40,W
2AEC:  MOVWF  x45
2AEE:  MOVF   01,W
2AF0:  SUBWFB x41,W
2AF2:  MOVWF  x46
2AF4:  MOVF   02,W
2AF6:  SUBWFB x42,W
2AF8:  MOVWF  x47
2AFA:  MOVF   03,W
2AFC:  SUBWFB x43,W
2AFE:  MOVWF  x48
....................     
....................    //if(cur_block != new_block) 
....................    if(g_mmcsdBufferAddress != new_block) 
2B00:  MOVF   x45,W
2B02:  MOVLB  2
2B04:  SUBWF  x05,W
2B06:  BNZ   2B26
2B08:  MOVLB  4
2B0A:  MOVF   x46,W
2B0C:  MOVLB  2
2B0E:  SUBWF  x06,W
2B10:  BNZ   2B26
2B12:  MOVLB  4
2B14:  MOVF   x47,W
2B16:  MOVLB  2
2B18:  SUBWF  x07,W
2B1A:  BNZ   2B26
2B1C:  MOVLB  4
2B1E:  MOVF   x48,W
2B20:  MOVLB  2
2B22:  SUBWF  x08,W
2B24:  BZ    2B5C
....................    { 
....................       // dump the old buffer 
....................       if (g_MMCSDBufferChanged) 
2B26:  BTFSS  x04.1
2B28:  BRA    2B42
....................       { 
....................          ec = mmcsd_flush_buffer(); 
2B2A:  MOVLB  0
2B2C:  RCALL  2A82
2B2E:  MOVFF  01,444
....................          if(ec != MMCSD_GOODEC) 
2B32:  MOVLB  4
2B34:  MOVF   x44,F
2B36:  BZ    2B3E
....................             return ec; 
2B38:  MOVFF  444,01
2B3C:  BRA    2B62
....................          g_MMCSDBufferChanged = FALSE; 
2B3E:  MOVLB  2
2B40:  BCF    x04.1
....................       } 
....................           
....................       // figure out the best place for a block 
....................       g_mmcsdBufferAddress = new_block; 
2B42:  MOVFF  448,208
2B46:  MOVFF  447,207
2B4A:  MOVFF  446,206
2B4E:  MOVFF  445,205
....................  
....................       // load up a new buffer 
....................       ec = mmcsd_load_buffer(); 
2B52:  MOVLB  0
2B54:  RCALL  27D2
2B56:  MOVFF  01,444
2B5A:  MOVLB  2
....................    } 
....................     
....................    return ec; 
2B5C:  MOVLB  4
2B5E:  MOVFF  444,01
2B62:  MOVLB  0
2B64:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data) 
.................... { 
....................    MMCSD_err ec; 
....................     
....................    ec = mmcsd_move_buffer(addr); 
2B66:  MOVFF  42A,443
2B6A:  MOVFF  429,442
2B6E:  MOVFF  428,441
2B72:  MOVFF  427,440
2B76:  RCALL  2ABA
2B78:  MOVFF  01,42D
....................    if(ec != MMCSD_GOODEC) 
2B7C:  MOVLB  4
2B7E:  MOVF   x2D,F
2B80:  BZ    2B88
....................    { 
....................      return ec; 
2B82:  MOVFF  42D,01
2B86:  BRA    2BB2
....................    } 
....................   
....................    *data = g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE]; 
2B88:  MOVF   x28,W
2B8A:  ANDLW  01
2B8C:  MOVWF  x31
2B8E:  CLRF   x32
2B90:  CLRF   x33
2B92:  MOVLW  04
2B94:  ADDWF  x27,W
2B96:  MOVWF  FE9
2B98:  MOVLW  00
2B9A:  ADDWFC x31,W
2B9C:  MOVWF  FEA
2B9E:  MOVFF  FEF,434
2BA2:  MOVFF  42C,FEA
2BA6:  MOVFF  42B,FE9
2BAA:  MOVFF  434,FEF
....................  
....................    return MMCSD_GOODEC; 
2BAE:  MOVLW  00
2BB0:  MOVWF  01
2BB2:  MOVLB  0
2BB4:  GOTO   2C20 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data) 
.................... {   
....................    MMCSD_err ec; 
....................    ec = mmcsd_move_buffer(addr); 
*
3A12:  MOVFF  43D,443
3A16:  MOVFF  43C,442
3A1A:  MOVFF  43B,441
3A1E:  MOVFF  43A,440
3A22:  CALL   2ABA
3A26:  MOVFF  01,43F
....................    if(ec != MMCSD_GOODEC) 
3A2A:  MOVLB  4
3A2C:  MOVF   x3F,F
3A2E:  BZ    3A36
....................      return ec; 
3A30:  MOVFF  43F,01
3A34:  BRA    3A5A
....................     
....................    g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE] = data; 
3A36:  MOVF   x3B,W
3A38:  ANDLW  01
3A3A:  MOVWF  x41
3A3C:  CLRF   x42
3A3E:  CLRF   x43
3A40:  MOVLW  04
3A42:  ADDWF  x3A,W
3A44:  MOVWF  FE9
3A46:  MOVLW  00
3A48:  ADDWFC x41,W
3A4A:  MOVWF  FEA
3A4C:  MOVFF  43E,FEF
....................     
....................    g_MMCSDBufferChanged = TRUE; 
3A50:  MOVLB  2
3A52:  BSF    x04.1
....................  
....................    return MMCSD_GOODEC; 
3A54:  MOVLW  00
3A56:  MOVWF  01
3A58:  MOVLB  4
3A5A:  MOVLB  0
3A5C:  GOTO   3AC6 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................   
.................... // Include FAT library source file 
.................... #include <fat_m.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          fat_m.c                                //// 
.................... ////                                                                 //// 
.................... ////        Driver/Library for a FAT filesystem with a PIC           //// 
.................... ////                                                                 //// 
.................... ////  This library is modified version of CCS C compiler FAT library //// 
.................... ////  source file fat.c, it now supports SDHC (high capacity) cards. //// 
.................... ////                                                                 //// 
.................... ////               https://simple-circuit.com/                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This Library was designed to resemble standard ANSI C I/O as    //// 
.................... ////  much as possible. There are, however, some caveats to this.    //// 
.................... ////  Please read the comments to make sure the inputs and outputs   //// 
.................... ////  to each function are understood before using anything in       //// 
.................... ////  this library.                                                  //// 
.................... ////                                                                 //// 
.................... //// This library supports FAT16 and FAT32, but not both at the same //// 
.................... //// time (this is a compile option, see options below).  It is      //// 
.................... //// recommended to use FAT32, FAT32 also has been tested more.      //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a file name must be in  //// 
.................... ////  the form of...                                                 //// 
.................... ////  "/filename.fil" for a file in the root directory               //// 
.................... ////  "/Directory/filename.fil" for a file in a subdirectory of root //// 
.................... ////  "/Directory/Subdirectory/filename.fil" and so on...            //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a directory name must   //// 
.................... ////  be in the form of...                                           //// 
.................... ////  "/Dirname/" for a directory in the root directory              //// 
.................... ////  "/Dirname/Subdirname/" for a directory in a subdirectory of    //// 
.................... ////  root and so on...                                              //// 
.................... ////                                                                 //// 
.................... //// A compatable media library must be provided.  This is           //// 
.................... //// documented after the User Functions.                            //// 
.................... ////                                                                 //// 
.................... //// -- User Functions --                                            //// 
.................... ////                                                                 //// 
.................... //// fat_init()                                                      //// 
.................... ////  Initializes the FAT library, also initializes the media.       //// 
.................... ////                                                                 //// 
.................... //// fatopen(char *name, char *mode, FILE *fstream)                  //// 
.................... ////  Opens up a FILE stream to a specified file with the specified  ////  
.................... ////  permission mode:                                               //// 
.................... ////             Permissions: "r" = read                             //// 
.................... ////                          "w" = write                            //// 
.................... ////                          "a" = append                           //// 
.................... ////                          "rb" = read binarily                   //// 
.................... ////             "w" will erase all of the data in the file upon     //// 
.................... ////              the opening of the file.                           //// 
.................... ////             "a" will tack on all of the data to the end of the  //// 
.................... ////              file.                                              //// 
.................... ////             "r" will keep on reading until the stream           //// 
.................... ////              hits an '\0'                                       //// 
.................... ////             "rb" will keep on reading until the amount of       //// 
.................... ////              bytes read equals the size of the file.            //// 
.................... ////                                                                 //// 
.................... ////  Unlike standard C fopen(), this does not malloc a FILE -       //// 
.................... ////  instead the caller will have to have allready allocated a      //// 
.................... ////  a FILE and pass a pointer to it.                               //// 
.................... ////                                                                 //// 
.................... //// fatreopen(char *name, char *mode, FILE *fstream)                //// 
.................... ////  Closes a FILE stream, then reopens the stream with a new file  //// 
.................... ////  and new permissions.                                           //// 
.................... ////                                                                 //// 
.................... //// fatclose(FILE *fstream)                                         //// 
.................... ////  Closes a FILE stream. It is very important to call this        ////  
.................... ////  function when you're done reading or writing to a file.        ////                             //// 
.................... ////                                                                 //// 
.................... //// fatgetc(FILE *fstream)                                          //// 
.................... ////  Gets a character from a stream. An EOF will be returned at     ////  
.................... ////  different times depending on whether or not the stream is      ////  
.................... ////  reading binarily.  If not reading binarily: EOF when the       ////  
.................... ////  stream reads a '\0'.  If reading binarily: EOF when the amount ////  
.................... ////  of bytes read equals the size of the file (end of file).       //// 
.................... ////                                                                 //// 
.................... //// fatputc(char c, FILE *fstream)                                  //// 
.................... ////  Puts a character into a stream (write to the file).            //// 
.................... ////  Writes are buffered, so the media may not be written to until  //// 
.................... ////  a fatclose().                                                  //// 
.................... ////                                                                 //// 
.................... //// char* fatgets(char* str, int num, FILE *fstream)                ////  
.................... ////  Gets characters from a stream until either a '\r',  EOF, or    ////  
.................... ////  num - 1 is hit.                                                //// 
.................... ////                                                                 //// 
.................... //// fatputs(char* str, FILE *fstream)                               //// 
.................... ////  Puts a string into a stream (write a string to the file).      //// 
.................... ////                                                                 //// 
.................... //// fatprintf(FILE *stream): Printfs the entire stream.             //// 
.................... ////  printf()'s the entire stream (printf()'s the contents of the 
.................... ////  file). 
.................... ////                                                                 //// 
.................... //// fatgetpos(FILE *fstream, fatpos_t *pos)                         //// 
.................... ////  Gets the current position of the stream/file, saves to pos.    //// 
.................... ////                                                                 //// 
.................... //// fatsetpos(FILE *fstream, fatpos_t *pos)                          //// 
.................... ////  Sets the current position of the stream/file.                  //// 
.................... ////                                                                 //// 
.................... //// fatseek(FILE *fstream, int32 offset, int origin)                 //// 
.................... ////  Sets the current position of the stream according to the       //// 
.................... ////  origin parameter:                                              //// 
.................... ////             SEEK_CUR: Set position relative to the              //// 
.................... ////              current stream position.                           //// 
.................... ////             SEEK_END: Set position relative to the              //// 
.................... ////              end of the stream.                                 //// 
.................... ////             SEEK_SET: Set position relative to the              //// 
.................... ////              beginning of the stream.                           //// 
.................... ////                                                                 //// 
.................... //// fateof(FILE *fstream)                                           //// 
.................... ////  Returns non-zero if the stream/file position is at EOF,        ////  
.................... ////  non-zero if there are still data left in the stream.           //// 
.................... ////                                                                 //// 
.................... //// faterror(FILE *fstream):                                        //// 
.................... ////  Returns non-zero if there have been errors with the stream,    //// 
.................... ////  zero if the stream has been operating correctly since it has   //// 
.................... ////  been opened.                                                   //// 
.................... ////                                                                 //// 
.................... //// fatread(void* buffer, int size, int32 num, FILE* fstream)       //// 
.................... ////  Reads size*num chars from the stream, saves to buffer.         //// 
.................... ////                                                                 //// 
.................... //// fatwrite(void* buffer, int size, int32 num, FILE* fstream)      ////  
.................... ////  Writes size*num chars from buffer to the stream.               //// 
.................... ////                                                                 //// 
.................... //// fatflush(FILE *fstream)                                         //// 
.................... ////  Flushes the buffer in a stream.                                //// 
.................... ////                                                                 //// 
.................... //// clearerr(FILE *fstream)                                         //// 
.................... ////  Clears any error flags in the stream.                          //// 
.................... ////                                                                 //// 
.................... //// rewind(FILE *fstream)                                           //// 
.................... ////  Send the stream back to the beginning of the file.             //// 
.................... ////                                                                 //// 
.................... //// fatpos_t fattell(FILE *fstream)                                 //// 
.................... ////  Returns the current position of the stream.                    //// 
.................... ////                                                                 //// 
.................... //// rm_file(char *fname)                                            //// 
.................... ////  Removes a file.                                                //// 
.................... ////                                                                 //// 
.................... //// rm_dir(char *dirname)                                           //// 
.................... ////  Removes a directory.                                           //// 
.................... ////                                                                 //// 
.................... //// mk_file(char *fname)                                            //// 
.................... ////  Makes a file, file will be blank.                              //// 
.................... ////                                                                 //// 
.................... //// mk_dir(char *dirname)                                           //// 
.................... ////  Makes a directory.                                             //// 
.................... ////                                                                 //// 
.................... //// format(int32 mediaSize)                                         //// 
.................... ////  Formats the media into a FAT32 or FAT16 file system.           //// 
.................... ////  If you specify a mediaSize larger than the actual media bad    //// 
.................... ////  things will happen.  If you specify a mediaSize smaller than   //// 
.................... ////  the actual media size will simply limit the filesystem from    //// 
.................... ////  using 0 to mediaSize-1.  Anything after mediaSize can be used  //// 
.................... ////  by the application (perhaps as a general purpose EEPROM?)      //// 
.................... ////  NOTE: Windows thinks the filesystem is RAW.                    //// 
.................... ////  NOTE: This may be a little buggy.                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This library was written to use CCS's MMC/SD library as the     //// 
.................... //// media source.  If you want to use a different media source,     //// 
.................... //// you must provide the following 4 functions:                     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_init(void);                                          //// 
.................... ////  Initializes the media.  This will be called by fat_init().     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_read_bytes(int32 a, int16 s, char *p);               //// 
.................... ////  Read s bytes from p to the media starting at address a.        //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_write_data(int32 a, int16 s, char *p);               //// 
.................... ////  Write s bytes from p to the media starting at address a.       //// 
.................... ////  To maximize throughput on some medias, it's a good idea to     //// 
.................... ////  buffer writes in this function.                                //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_flush_buffer(void);                                  //// 
.................... ////  If your write function is buffering writes, this will flush    //// 
.................... ////  the buffer and write it to the media.                          //// 
.................... ////                                                                 //// 
.................... //// All four functions should return 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // NOTE This library has no concept of what time and date it currently is. 
.................... //       All files and folders created or modified using this library 
.................... //       will have invalid/inaccurate timestamps and datestamps. 
....................  
.................... // NOTE To save on ROM and RAM space, the user of this library will have to  
.................... //       define what type of FAT they will be working with. The defines are  
.................... //       in the Useful Defines section below. 
....................  
.................... // NOTE For faster writing or appending for an application such as a logger,  
.................... //       uncomment #FAST_FAT below.  This will make the FAT library assume  
.................... //       there is one file on the card to write or append to, thereby 
.................... //       making writing and appending much faster. Reading is impossible in  
.................... //       this mode. 
.................... //       THIS IS NOT TESTED VERY WELL YET! 
....................  
.................... // NOTE The current maximum file name length (full path) is 32 characters  
.................... //       long. If longer file names are desired, change the  
.................... //       MAX_FILE_NAME_LENGTH define below. Creating a file whose full path  
.................... //       is longer than MAX_FILE_NAME_LENGTH may lead to weird operation. Keep 
.................... //       in mind that making this define larger will make your RAM usage go  
.................... //        up. 
....................  
.................... #ifndef FAT_PIC_C 
.................... #define FAT_PIC_C 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
3910:  MOVLB  3
3912:  MOVFF  3D6,FE9
3916:  MOVFF  3D7,FEA
391A:  MOVFF  FEF,3DA
391E:  MOVFF  3D9,03
3922:  MOVFF  3D8,FE9
3926:  MOVFF  3D9,FEA
392A:  MOVF   FEF,W
392C:  SUBWF  xDA,W
392E:  BNZ   395A
....................       if (*s1 == '\0') 
3930:  MOVFF  3D7,03
3934:  MOVFF  3D6,FE9
3938:  MOVFF  03,FEA
393C:  MOVF   FEF,F
393E:  BNZ   3946
....................          return(0); 
3940:  MOVLW  00
3942:  MOVWF  01
3944:  BRA    3984
3946:  MOVFF  3D7,03
394A:  MOVF   xD6,W
394C:  INCF   xD6,F
394E:  BTFSC  FD8.2
3950:  INCF   xD7,F
3952:  INCF   xD8,F
3954:  BTFSC  FD8.2
3956:  INCF   xD9,F
3958:  BRA    3912
....................    return((*s1 < *s2) ? -1: 1); 
395A:  MOVFF  3D7,03
395E:  MOVFF  3D6,FE9
3962:  MOVFF  3D7,FEA
3966:  MOVFF  FEF,3DA
396A:  MOVFF  3D9,03
396E:  MOVFF  3D8,FE9
3972:  MOVFF  3D9,FEA
3976:  MOVF   FEF,W
3978:  SUBWF  xDA,W
397A:  BC    3980
397C:  MOVLW  FF
397E:  BRA    3982
3980:  MOVLW  01
3982:  MOVWF  01
3984:  MOVLB  0
3986:  GOTO   4B70 (RETURN)
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
31AC:  MOVFF  3EF,3F1
31B0:  MOVFF  3EE,3F0
31B4:  MOVFF  3F1,03
31B8:  MOVLB  3
31BA:  MOVFF  3F0,FE9
31BE:  MOVFF  3F1,FEA
31C2:  MOVF   FEF,F
31C4:  BZ    31D2
31C6:  INCF   xF0,F
31C8:  BTFSC  FD8.2
31CA:  INCF   xF1,F
31CC:  MOVLB  0
31CE:  BRA    31B4
31D0:  MOVLB  3
....................    return(sc - s); 
31D2:  MOVF   xEE,W
31D4:  SUBWF  xF0,W
31D6:  MOVWF  00
31D8:  MOVF   xEF,W
31DA:  SUBWFB xF1,W
31DC:  MOVWF  03
31DE:  MOVFF  00,01
31E2:  MOVWF  02
31E4:  MOVLB  0
31E6:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #case 
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... /// Define your FAT type here /// 
.................... #ifndef FAT16 
....................   #define FAT32 
.................... #endif 
....................  
.................... /// For faster single-file writing, uncomment this line below /// 
.................... //#define FAST_FAT 
....................  
.................... /// Everything else /// 
.................... #define MAX_FILE_NAME_LENGTH 0x20  // the maximum length of a file name for our FAT, including /0 terminator 
.................... #define STREAM_BUF_SIZE 0x20       // how big the FILE buffer is. 0x20 is optimal 
....................  
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #define EOF -1 
.................... #define GOODEC 0 
.................... #define fatpos_t int32 
.................... #define SEEK_CUR 0 
.................... #define SEEK_END 1 
.................... #define SEEK_SET 2 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... int16 
....................    Bytes_Per_Cluster;   // number of addressable bytes per cluster 
....................  
.................... int32 
....................    FAT_Start,           // when the first FAT begins 
....................    Data_Start,          // when data starts 
....................    FAT_Length,          // the length of one FAT 
....................    Next_Free_Clust,     // where the next free cluster is 
....................    Root_Dir;            // when the root directory starts 
....................  
.................... enum filetype 
.................... { 
....................    Data_File,  // the stream is pointing to a binary, data file 
....................    Directory,  // the stream is pointing to a directory 
....................    None        // the stream isn't currently pointing to anything 
.................... }; 
....................  
.................... enum ioflags 
.................... { 
....................    Closed = 0x00, 
....................    Read = 0x01, 
....................    Write = 0x02, 
....................    Append = 0x04, 
....................    Binary = 0x08, 
....................    EOF_Reached = 0x10, 
....................    Read_Error = 0x20, 
....................    Write_Error = 0x40, 
....................    File_Not_Found = 0x80 
.................... }; 
....................  
.................... struct iobuf 
.................... { 
....................    fatpos_t 
....................       Bytes_Until_EOF,     // how many bytes until the stream's end of file 
....................       Cur_Char,            // the current byte that the stream is pointing at 
....................       Entry_Addr,          // the entry address of the file that is associated with the stream 
....................       Parent_Start_Addr,   // the parent's start adddress of the file that is associated with the stream 
....................       Size,                // the size of the file that is associated with the stream 
....................       Start_Addr;          // the beginning of the data in the file that is associated with the stream 
....................  
....................    enum filetype File_Type;   // the type of file that is associated with the stream 
....................  
....................    enum ioflags Flags;        // any associated input/output flag 
....................  
....................    int Buf[STREAM_BUF_SIZE];  // this is a buffer so that during fatputc() or fatgetc() 
....................                               //  the media won't have to be read at every character 
.................... }; 
.................... typedef struct iobuf FILE; 
....................  
.................... /////////////////////////// 
.................... ///                     /// 
.................... /// Function Prototypes /// 
.................... ///                     /// 
.................... /////////////////////////// 
....................  
.................... /// Standard C Functions /// 
.................... signed int fatopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatclose(FILE* stream); 
.................... signed int fatgetc(FILE* stream); 
.................... signed int fatputc(int ch, FILE* stream); 
.................... char* fatgets(char* str, int num, FILE* stream); 
.................... signed int fatputs(char* str, FILE* stream); 
.................... signed int fatprintf(FILE* stream); 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatseek(FILE* stream, int32 offset, int origin); 
.................... signed int fateof(FILE* stream); 
.................... signed int faterror(FILE* stream); 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream); 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ); 
.................... signed int fatflush(FILE* stream); 
.................... signed int remove(char* fname); 
.................... void clearerr(FILE* stream); 
.................... void rewind(FILE* stream); 
.................... fatpos_t fattell(FILE* stream); 
....................  
.................... /// Non-Standard C Functions /// 
.................... signed int rm_file(char fname[]); 
.................... signed int rm_dir(char dname[]); 
.................... signed int mk_file(char fname[]); 
.................... signed int mk_dir(char dname[]); 
....................  
.................... /// Functions' Utility Functions /// 
.................... signed int set_file(char fname[], int attrib, FILE* stream); 
.................... signed int get_file_name(int32 file_entry_addr, char name[]); 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]); 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type); 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]); 
.................... int long_name_chksum (int* pFcbName); 
.................... signed int check_invalid_char(char fname[]); 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster); 
.................... signed int dealloc_clusters(int32 start_cluster); 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int32 cluster); 
.................... signed int write_fat(int32 cluster, int32 data); 
.................... #else // FAT16 
.................... signed int get_next_free_cluster(int16* my_cluster); 
.................... signed int dealloc_clusters(int16 start_cluster); 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int16 cluster); 
.................... signed int write_fat(int16 cluster, int16 data); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_file(FILE* stream); 
.................... signed int get_prev_file(FILE* stream); 
.................... signed int get_next_free_addr(int32* my_addr); 
.................... signed int get_next_free_entry(int32* start_addr); 
.................... signed int get_next_entry(int32* start_addr); 
.................... signed int get_prev_entry(int32* start_addr); 
.................... signed int read_buffer(FILE* stream, int* val); 
.................... signed int write_buffer(FILE* stream, int val); 
.................... void fill_entry(char the_entry[], char val, int8 start_ind); 
.................... void disp_timestamp(int16 timestamp); 
.................... void disp_datestamp(int16 datestamp); 
....................  
.................... /// Data Utility Functions /// 
.................... signed int fat_init(); 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster); 
.................... signed int get_prev_cluster(int32* my_cluster); 
.................... int32 cluster_to_addr(int32 cluster); 
.................... int32 addr_to_cluster(int32 addr); 
.................... #else // FAT16 
.................... signed int get_next_cluster(int16* my_cluster); 
.................... signed int get_prev_cluster(int16* my_cluster); 
.................... int32 cluster_to_addr(int16 cluster); 
.................... int16 addr_to_cluster(int32 addr); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_addr(int32* my_addr); 
.................... signed int get_prev_addr(int32* my_addr); 
.................... signed int format(int32 DskSize); 
....................  
.................... /// Debugging Utility Functions /// 
.................... signed int disp_folder_contents(char foldername[]); 
.................... signed int dump_addr(int32 from, int32 to); 
.................... signed int dump_clusters(int32 from, int32 to); 
.................... void disp_fat_stats(); 
.................... signed int fatprintfinfo(FILE* stream); 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /// Standard C Functions /// 
....................  
.................... /* 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... Summary: This will open up a file stream for reading, writing, or appending. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to open up. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
*
5150:  MOVLW  01
5152:  MOVLB  3
5154:  MOVWF  x4D
5156:  CLRF   xA8
.................... { 
....................    int fname_parse_pos = 1;    // the current index of the fname character 
....................  
....................    char target_file[MAX_FILE_NAME_LENGTH];   // temporary buffer to hold names of files 
....................  
....................    FILE cur_stream;     // this will   be the stream that will be returned if all goes well 
....................  
.................... #ifndef FAST_FAT 
....................    int 
....................       depth = 0,              // how many subdirectories deep the file is 
....................       target_file_parse_pos;  // the current index of the target_file character 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set flags 
.................... #ifdef FAST_FAT 
....................    switch(mode[0]) 
....................    { 
....................       case 'w': 
....................          cur_stream.Flags = Write; 
....................          break; 
....................       case 'a': 
....................          cur_stream.Flags = Append; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
....................  
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
....................       target_file[fname_parse_pos - 1] = fname[fname_parse_pos]; 
....................       fname_parse_pos += 1; 
....................    } 
....................  
....................    target_file[fname_parse_pos] = '\0'; 
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
....................       *stream = cur_stream; 
....................       return EOF; 
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................    switch(mode[0]) 
5158:  MOVF   x49,W
515A:  MOVWF  FE9
515C:  MOVF   x4A,W
515E:  MOVWF  FEA
5160:  MOVF   FEF,W
5162:  XORLW  72
5164:  MOVLB  0
5166:  BZ    5172
5168:  XORLW  05
516A:  BZ    517A
516C:  XORLW  16
516E:  BZ    5182
5170:  BRA    518C
....................    { 
....................       case 'r': 
....................          cur_stream.Flags = Read; 
5172:  MOVLW  01
5174:  MOVLB  3
5176:  MOVWF  x87
....................          break; 
5178:  BRA    5194
....................       case 'w': 
....................          cur_stream.Flags = Write; 
517A:  MOVLW  02
517C:  MOVLB  3
517E:  MOVWF  x87
....................          break; 
5180:  BRA    5194
....................       case 'a': 
....................          cur_stream.Flags = Append; 
5182:  MOVLW  04
5184:  MOVLB  3
5186:  MOVWF  x87
....................          break; 
5188:  BRA    5194
518A:  MOVLB  0
....................       default: 
....................          return EOF; 
518C:  MOVLW  FF
518E:  MOVWF  01
5190:  BRA    53BA
5192:  MOVLB  3
....................    } 
....................  
....................    if(mode[1] == 'b') 
5194:  MOVLW  01
5196:  ADDWF  x49,W
5198:  MOVWF  FE9
519A:  MOVLW  00
519C:  ADDWFC x4A,W
519E:  MOVWF  FEA
51A0:  MOVF   FEF,W
51A2:  SUBLW  62
51A4:  BNZ   51A8
....................       cur_stream.Flags |= Binary; 
51A6:  BSF    x87.3
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
51A8:  MOVFF  221,37D
51AC:  MOVFF  220,37C
51B0:  MOVFF  21F,37B
51B4:  MOVFF  21E,37A
51B8:  MOVFF  37D,385
51BC:  MOVFF  37C,384
51C0:  MOVFF  37B,383
51C4:  MOVFF  37A,382
....................  
....................    // figure out how deep we have to go, count how many '/' we have in the string 
....................    while(fname[fname_parse_pos] != '\0') 
51C8:  MOVF   x4D,W
51CA:  ADDWF  x47,W
51CC:  MOVWF  FE9
51CE:  MOVLW  00
51D0:  ADDWFC x48,W
51D2:  MOVWF  FEA
51D4:  MOVF   FEF,F
51D6:  BZ    51F2
....................    { 
....................       if(fname[fname_parse_pos] == '/') 
51D8:  MOVF   x4D,W
51DA:  ADDWF  x47,W
51DC:  MOVWF  FE9
51DE:  MOVLW  00
51E0:  ADDWFC x48,W
51E2:  MOVWF  FEA
51E4:  MOVF   FEF,W
51E6:  SUBLW  2F
51E8:  BNZ   51EC
....................          depth++; 
51EA:  INCF   xA8,F
....................       fname_parse_pos += 1; 
51EC:  MOVLW  01
51EE:  ADDWF  x4D,F
51F0:  BRA    51C8
....................    } 
....................  
....................    // start the fname index at 1 to skip over the '/' 
....................    fname_parse_pos = 1; 
51F2:  MOVLW  01
51F4:  MOVWF  x4D
....................  
....................    // open up to the subdirectory, if possible 
....................    while(depth > 0) 
51F6:  MOVF   xA8,F
51F8:  BZ    52BE
....................    { 
....................       // find the name of our next target directory 
....................       target_file_parse_pos = 0; 
51FA:  CLRF   xA9
....................       while(fname[fname_parse_pos] != '/') 
51FC:  MOVF   x4D,W
51FE:  ADDWF  x47,W
5200:  MOVWF  FE9
5202:  MOVLW  00
5204:  ADDWFC x48,W
5206:  MOVWF  FEA
5208:  MOVF   FEF,W
520A:  SUBLW  2F
520C:  BZ    5258
....................       { 
....................          // check to make sure that we're not at the end of a poorly formatted string 
....................          if(fname[fname_parse_pos] == '\0') 
520E:  MOVF   x4D,W
5210:  ADDWF  x47,W
5212:  MOVWF  FE9
5214:  MOVLW  00
5216:  ADDWFC x48,W
5218:  MOVWF  FEA
521A:  MOVF   FEF,F
521C:  BNZ   5228
....................             return EOF; 
521E:  MOVLW  FF
5220:  MOVWF  01
5222:  MOVLB  0
5224:  BRA    53BA
5226:  MOVLB  3
....................  
....................          // fill up the buffer and increment the indexes 
....................          target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
5228:  CLRF   03
522A:  MOVF   xA9,W
522C:  ADDLW  4E
522E:  MOVWF  01
5230:  MOVLW  03
5232:  ADDWFC 03,F
5234:  MOVF   x4D,W
5236:  ADDWF  x47,W
5238:  MOVWF  FE9
523A:  MOVLW  00
523C:  ADDWFC x48,W
523E:  MOVWF  FEA
5240:  MOVFF  FEF,3AC
5244:  MOVFF  03,FEA
5248:  MOVFF  01,FE9
524C:  MOVFF  3AC,FEF
....................          fname_parse_pos += 1; 
5250:  MOVLW  01
5252:  ADDWF  x4D,F
....................          target_file_parse_pos += 1; 
5254:  ADDWF  xA9,F
5256:  BRA    51FC
....................       } 
....................  
....................       // increment the fname index one more because it's currently pointing at the '/' 
....................       fname_parse_pos += 1; 
5258:  MOVLW  01
525A:  ADDWF  x4D,F
....................  
....................       // tack on a \0 to the end of the target file to terminate the string 
....................       target_file[target_file_parse_pos] = '\0'; 
525C:  CLRF   03
525E:  MOVF   xA9,W
5260:  ADDLW  4E
5262:  MOVWF  FE9
5264:  MOVLW  03
5266:  ADDWFC 03,W
5268:  MOVWF  FEA
526A:  CLRF   FEF
....................  
....................       // check to see if the directory exists and open it if possible, otherwise exit because the directory doesn't exist 
....................       if(set_file(target_file, 0x10, &cur_stream) != GOODEC) 
526C:  MOVLW  03
526E:  MOVWF  xAB
5270:  MOVLW  4E
5272:  MOVWF  xAA
5274:  MOVLW  10
5276:  MOVWF  xAC
5278:  MOVLW  03
527A:  MOVWF  xAE
527C:  MOVLW  6E
527E:  MOVWF  xAD
5280:  MOVLB  0
5282:  CALL   4A6E
5286:  MOVF   01,F
5288:  BZ    52B6
....................       { 
....................          cur_stream.Flags |= File_Not_Found; 
528A:  MOVLB  3
528C:  BSF    x87.7
....................          *stream = cur_stream; 
528E:  MOVFF  34C,03
5292:  MOVFF  34B,FE9
5296:  MOVFF  34C,FEA
529A:  MOVLW  03
529C:  MOVWF  FE2
529E:  MOVLW  6E
52A0:  MOVWF  FE1
52A2:  MOVLW  3A
52A4:  MOVWF  01
52A6:  MOVFF  FE6,FEE
52AA:  DECFSZ 01,F
52AC:  BRA    52A6
....................          return EOF; 
52AE:  MOVLW  FF
52B0:  MOVWF  01
52B2:  MOVLB  0
52B4:  BRA    53BA
....................       } 
....................       depth -= 1; 
52B6:  MOVLW  01
52B8:  MOVLB  3
52BA:  SUBWF  xA8,F
52BC:  BRA    51F6
....................    } 
....................  
....................    // check to see if we're trying to open just a directory 
....................    if(fname[fname_parse_pos] == '\0') 
52BE:  MOVF   x4D,W
52C0:  ADDWF  x47,W
52C2:  MOVWF  FE9
52C4:  MOVLW  00
52C6:  ADDWFC x48,W
52C8:  MOVWF  FEA
52CA:  MOVF   FEF,F
52CC:  BNZ   52F8
....................    { 
....................       *stream = cur_stream; 
52CE:  MOVFF  34C,03
52D2:  MOVFF  34B,FE9
52D6:  MOVFF  34C,FEA
52DA:  MOVLW  03
52DC:  MOVWF  FE2
52DE:  MOVLW  6E
52E0:  MOVWF  FE1
52E2:  MOVLW  3A
52E4:  MOVWF  01
52E6:  MOVFF  FE6,FEE
52EA:  DECFSZ 01,F
52EC:  BRA    52E6
....................       return GOODEC; 
52EE:  MOVLW  00
52F0:  MOVWF  01
52F2:  MOVLB  0
52F4:  BRA    53BA
52F6:  MOVLB  3
....................    } 
....................  
....................    // now that we have the location of the subdirectory that the file is in, attempt to open the file 
....................    target_file_parse_pos = 0; 
52F8:  CLRF   xA9
....................    while(fname[fname_parse_pos] != '\0') 
52FA:  MOVF   x4D,W
52FC:  ADDWF  x47,W
52FE:  MOVWF  FE9
5300:  MOVLW  00
5302:  ADDWFC x48,W
5304:  MOVWF  FEA
5306:  MOVF   FEF,F
5308:  BZ    533A
....................    { 
....................       // fill up the buffer and increment the indexes 
....................       target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
530A:  CLRF   03
530C:  MOVF   xA9,W
530E:  ADDLW  4E
5310:  MOVWF  01
5312:  MOVLW  03
5314:  ADDWFC 03,F
5316:  MOVF   x4D,W
5318:  ADDWF  x47,W
531A:  MOVWF  FE9
531C:  MOVLW  00
531E:  ADDWFC x48,W
5320:  MOVWF  FEA
5322:  MOVFF  FEF,3AC
5326:  MOVFF  03,FEA
532A:  MOVFF  01,FE9
532E:  MOVFF  3AC,FEF
....................       fname_parse_pos += 1; 
5332:  MOVLW  01
5334:  ADDWF  x4D,F
....................       target_file_parse_pos += 1; 
5336:  ADDWF  xA9,F
5338:  BRA    52FA
....................    } 
....................  
....................    // tack on a \0 to the end of the target file to terminate the string 
....................    target_file[target_file_parse_pos] = '\0'; 
533A:  CLRF   03
533C:  MOVF   xA9,W
533E:  ADDLW  4E
5340:  MOVWF  FE9
5342:  MOVLW  03
5344:  ADDWFC 03,W
5346:  MOVWF  FEA
5348:  CLRF   FEF
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
534A:  MOVLW  03
534C:  MOVWF  xAB
534E:  MOVLW  4E
5350:  MOVWF  xAA
5352:  MOVLW  20
5354:  MOVWF  xAC
5356:  MOVLW  03
5358:  MOVWF  xAE
535A:  MOVLW  6E
535C:  MOVWF  xAD
535E:  MOVLB  0
5360:  CALL   4A6E
5364:  MOVF   01,F
5366:  BZ    5394
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
5368:  MOVLB  3
536A:  BSF    x87.7
....................       *stream = cur_stream; 
536C:  MOVFF  34C,03
5370:  MOVFF  34B,FE9
5374:  MOVFF  34C,FEA
5378:  MOVLW  03
537A:  MOVWF  FE2
537C:  MOVLW  6E
537E:  MOVWF  FE1
5380:  MOVLW  3A
5382:  MOVWF  01
5384:  MOVFF  FE6,FEE
5388:  DECFSZ 01,F
538A:  BRA    5384
....................       return EOF; 
538C:  MOVLW  FF
538E:  MOVWF  01
5390:  MOVLB  0
5392:  BRA    53BA
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
5394:  MOVFF  34C,03
5398:  MOVLB  3
539A:  MOVFF  34B,FE9
539E:  MOVFF  34C,FEA
53A2:  MOVLW  03
53A4:  MOVWF  FE2
53A6:  MOVLW  6E
53A8:  MOVWF  FE1
53AA:  MOVLW  3A
53AC:  MOVWF  01
53AE:  MOVFF  FE6,FEE
53B2:  DECFSZ 01,F
53B4:  BRA    53AE
....................    return GOODEC; 
53B6:  MOVLW  00
53B8:  MOVWF  01
53BA:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
53BC:  GOTO   5404 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatreopen(char fname[], char mode[], FILE* old_stream, FILE* new_stream) 
.................... Summary: This will close a stream and then reopen it using new parameters. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to close and reopen. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................          /Directory/filename.fil for a file in a subdirectory of root 
....................          /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream) 
.................... { 
....................    // close the old stream 
....................    if(fatclose(stream) == EOF) 
....................      return EOF; 
....................  
....................    // open the new stream 
....................    if(fatopen(fname, mode, stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatclose(FILE* stream) 
.................... Summary: Closes a stream and commits any changes done to the file. 
.................... Param: The stream to close. 
.................... Returns: EOF if there was a problem, 0 if everything went okay. 
.................... */ 
.................... signed int fatclose(FILE* stream) 
*
58C2:  MOVLB  3
58C4:  CLRF   x38
.................... { 
....................    int ec = 0; 
....................  
....................    int32 first_cluster; 
....................  
....................    // commit data back to the stream's entry, if needed 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
58C6:  MOVLW  19
58C8:  ADDWF  x36,W
58CA:  MOVWF  FE9
58CC:  MOVLW  00
58CE:  ADDWFC x37,W
58D0:  MOVWF  FEA
58D2:  BTFSC  FEF.1
58D4:  BRA    58E6
58D6:  MOVLW  19
58D8:  ADDWF  x36,W
58DA:  MOVWF  FE9
58DC:  MOVLW  00
58DE:  ADDWFC x37,W
58E0:  MOVWF  FEA
58E2:  BTFSS  FEF.2
58E4:  BRA    5B56
....................    {  
....................       // write the new size of the file 
....................       if(mmcsd_write_data(stream->Entry_Addr + 0x1C, 4, &(stream->Size)) != GOODEC) 
58E6:  MOVLW  08
58E8:  ADDWF  x36,W
58EA:  MOVWF  FE9
58EC:  MOVLW  00
58EE:  ADDWFC x37,W
58F0:  MOVWF  FEA
58F2:  MOVFF  FEF,33D
58F6:  MOVFF  FEC,33E
58FA:  MOVFF  FEC,33F
58FE:  MOVFF  FEC,340
5902:  MOVLW  1C
5904:  ADDWF  x3D,F
5906:  MOVLW  00
5908:  ADDWFC x3E,F
590A:  ADDWFC x3F,F
590C:  ADDWFC x40,F
590E:  MOVLW  10
5910:  ADDWF  x36,W
5912:  MOVWF  01
5914:  MOVLW  00
5916:  ADDWFC x37,W
5918:  MOVWF  03
591A:  MOVFF  01,341
591E:  MOVWF  x42
5920:  MOVFF  340,42D
5924:  MOVFF  33F,42C
5928:  MOVFF  33E,42B
592C:  MOVFF  33D,42A
5930:  MOVLB  4
5932:  CLRF   x2F
5934:  MOVLW  04
5936:  MOVWF  x2E
5938:  MOVFF  03,431
593C:  MOVFF  01,430
5940:  MOVLB  0
5942:  CALL   3A60
5946:  MOVF   01,F
5948:  BZ    5966
....................       { 
....................          stream->Flags |= Write_Error; 
594A:  MOVLW  19
594C:  MOVLB  3
594E:  ADDWF  x36,W
5950:  MOVWF  FE9
5952:  MOVLW  00
5954:  ADDWFC x37,W
5956:  MOVWF  FEA
5958:  MOVF   FEF,W
595A:  IORLW  40
595C:  MOVWF  FEF
....................          return EOF; 
595E:  MOVLW  FF
5960:  MOVWF  01
5962:  BRA    5BE4
5964:  MOVLB  0
....................       } 
....................  
....................       // check to see if the first cluster is already linked in the file 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
5966:  MOVLW  08
5968:  MOVLB  3
596A:  ADDWF  x36,W
596C:  MOVWF  FE9
596E:  MOVLW  00
5970:  ADDWFC x37,W
5972:  MOVWF  FEA
5974:  MOVFF  FEF,33D
5978:  MOVFF  FEC,33E
597C:  MOVFF  FEC,33F
5980:  MOVFF  FEC,340
5984:  MOVLW  14
5986:  ADDWF  x3D,F
5988:  MOVLW  00
598A:  ADDWFC x3E,F
598C:  ADDWFC x3F,F
598E:  ADDWFC x40,F
5990:  MOVFF  340,419
5994:  MOVFF  33F,418
5998:  MOVFF  33E,417
599C:  MOVFF  33D,416
59A0:  MOVLB  4
59A2:  CLRF   x1B
59A4:  MOVLW  02
59A6:  MOVWF  x1A
59A8:  MOVLW  03
59AA:  MOVWF  x1D
59AC:  MOVLW  3B
59AE:  MOVWF  x1C
59B0:  MOVLB  0
59B2:  CALL   2BB8
59B6:  MOVF   01,W
59B8:  MOVLB  3
59BA:  ADDWF  x38,F
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
59BC:  MOVLW  08
59BE:  ADDWF  x36,W
59C0:  MOVWF  FE9
59C2:  MOVLW  00
59C4:  ADDWFC x37,W
59C6:  MOVWF  FEA
59C8:  MOVFF  FEF,33D
59CC:  MOVFF  FEC,33E
59D0:  MOVFF  FEC,33F
59D4:  MOVFF  FEC,340
59D8:  MOVLW  1A
59DA:  ADDWF  x3D,F
59DC:  MOVLW  00
59DE:  ADDWFC x3E,F
59E0:  ADDWFC x3F,F
59E2:  ADDWFC x40,F
59E4:  MOVFF  340,419
59E8:  MOVFF  33F,418
59EC:  MOVFF  33E,417
59F0:  MOVFF  33D,416
59F4:  MOVLB  4
59F6:  CLRF   x1B
59F8:  MOVLW  02
59FA:  MOVWF  x1A
59FC:  MOVLW  03
59FE:  MOVWF  x1D
5A00:  MOVLW  39
5A02:  MOVWF  x1C
5A04:  MOVLB  0
5A06:  CALL   2BB8
5A0A:  MOVF   01,W
5A0C:  MOVLB  3
5A0E:  ADDWF  x38,F
....................  
....................       if(ec != GOODEC) 
5A10:  MOVF   x38,F
5A12:  BZ    5A2C
....................       { 
....................          stream->Flags |= Read_Error; 
5A14:  MOVLW  19
5A16:  ADDWF  x36,W
5A18:  MOVWF  FE9
5A1A:  MOVLW  00
5A1C:  ADDWFC x37,W
5A1E:  MOVWF  FEA
5A20:  MOVF   FEF,W
5A22:  IORLW  20
5A24:  MOVWF  FEF
....................          return EOF; 
5A26:  MOVLW  FF
5A28:  MOVWF  01
5A2A:  BRA    5BE4
....................       } 
....................  
....................       // write the first cluster to the entry if needed 
....................       if(first_cluster == 0) 
5A2C:  MOVF   x39,F
5A2E:  BTFSS  FD8.2
5A30:  BRA    5B3C
5A32:  MOVF   x3A,F
5A34:  BTFSS  FD8.2
5A36:  BRA    5B3C
5A38:  MOVF   x3B,F
5A3A:  BTFSS  FD8.2
5A3C:  BRA    5B3C
5A3E:  MOVF   x3C,F
5A40:  BTFSS  FD8.2
5A42:  BRA    5B3C
....................       { 
....................          // convert the start address to a cluster number 
....................          first_cluster = addr_to_cluster(stream->Start_Addr); 
5A44:  MOVLW  14
5A46:  ADDWF  x36,W
5A48:  MOVWF  FE9
5A4A:  MOVLW  00
5A4C:  ADDWFC x37,W
5A4E:  MOVWF  FEA
5A50:  MOVFF  FEF,3F4
5A54:  MOVFF  FEC,3F5
5A58:  MOVFF  FEC,3F6
5A5C:  MOVFF  FEC,3F7
5A60:  MOVLB  0
5A62:  CALL   3324
5A66:  MOVFF  03,33C
5A6A:  MOVFF  02,33B
5A6E:  MOVFF  01,33A
5A72:  MOVFF  00,339
....................  
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
5A76:  MOVLW  08
5A78:  MOVLB  3
5A7A:  ADDWF  x36,W
5A7C:  MOVWF  FE9
5A7E:  MOVLW  00
5A80:  ADDWFC x37,W
5A82:  MOVWF  FEA
5A84:  MOVFF  FEF,33D
5A88:  MOVFF  FEC,33E
5A8C:  MOVFF  FEC,33F
5A90:  MOVFF  FEC,340
5A94:  MOVLW  14
5A96:  ADDWF  x3D,F
5A98:  MOVLW  00
5A9A:  ADDWFC x3E,F
5A9C:  ADDWFC x3F,F
5A9E:  ADDWFC x40,F
5AA0:  MOVFF  340,42D
5AA4:  MOVFF  33F,42C
5AA8:  MOVFF  33E,42B
5AAC:  MOVFF  33D,42A
5AB0:  MOVLB  4
5AB2:  CLRF   x2F
5AB4:  MOVLW  02
5AB6:  MOVWF  x2E
5AB8:  MOVLW  03
5ABA:  MOVWF  x31
5ABC:  MOVLW  3B
5ABE:  MOVWF  x30
5AC0:  MOVLB  0
5AC2:  CALL   3A60
5AC6:  MOVF   01,W
5AC8:  MOVLB  3
5ACA:  ADDWF  x38,F
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
5ACC:  MOVLW  08
5ACE:  ADDWF  x36,W
5AD0:  MOVWF  FE9
5AD2:  MOVLW  00
5AD4:  ADDWFC x37,W
5AD6:  MOVWF  FEA
5AD8:  MOVFF  FEF,33D
5ADC:  MOVFF  FEC,33E
5AE0:  MOVFF  FEC,33F
5AE4:  MOVFF  FEC,340
5AE8:  MOVLW  1A
5AEA:  ADDWF  x3D,F
5AEC:  MOVLW  00
5AEE:  ADDWFC x3E,F
5AF0:  ADDWFC x3F,F
5AF2:  ADDWFC x40,F
5AF4:  MOVFF  340,42D
5AF8:  MOVFF  33F,42C
5AFC:  MOVFF  33E,42B
5B00:  MOVFF  33D,42A
5B04:  MOVLB  4
5B06:  CLRF   x2F
5B08:  MOVLW  02
5B0A:  MOVWF  x2E
5B0C:  MOVLW  03
5B0E:  MOVWF  x31
5B10:  MOVLW  39
5B12:  MOVWF  x30
5B14:  MOVLB  0
5B16:  CALL   3A60
5B1A:  MOVF   01,W
5B1C:  MOVLB  3
5B1E:  ADDWF  x38,F
....................  
....................          if(ec != GOODEC) 
5B20:  MOVF   x38,F
5B22:  BZ    5B3C
....................          { 
....................             stream->Flags |= Write_Error; 
5B24:  MOVLW  19
5B26:  ADDWF  x36,W
5B28:  MOVWF  FE9
5B2A:  MOVLW  00
5B2C:  ADDWFC x37,W
5B2E:  MOVWF  FEA
5B30:  MOVF   FEF,W
5B32:  IORLW  40
5B34:  MOVWF  FEF
....................             return EOF; 
5B36:  MOVLW  FF
5B38:  MOVWF  01
5B3A:  BRA    5BE4
....................          } 
....................       } 
....................        
....................       // dump the remaining buffer to the card 
....................       if(fatflush(stream) == EOF) 
5B3C:  MOVFF  337,33E
5B40:  MOVFF  336,33D
5B44:  MOVLB  0
5B46:  BRA    5726
5B48:  MOVF   01,W
5B4A:  SUBLW  FF
5B4C:  BNZ   5B58
....................          return EOF; 
5B4E:  MOVLW  FF
5B50:  MOVWF  01
5B52:  MOVLB  3
5B54:  BRA    5BE4
5B56:  MOVLB  0
....................    } 
....................    // nullify the data 
....................    stream->Cur_Char = 0; 
5B58:  MOVLW  04
5B5A:  MOVLB  3
5B5C:  ADDWF  x36,W
5B5E:  MOVWF  FE9
5B60:  MOVLW  00
5B62:  ADDWFC x37,W
5B64:  MOVWF  FEA
5B66:  MOVF   FEE,F
5B68:  MOVF   FEE,F
5B6A:  CLRF   FEC
5B6C:  MOVF   FED,F
5B6E:  CLRF   FEF
5B70:  MOVF   FED,F
5B72:  CLRF   FEF
5B74:  MOVF   FED,F
5B76:  CLRF   FEF
....................    stream->Entry_Addr = 0; 
5B78:  MOVLW  08
5B7A:  ADDWF  x36,W
5B7C:  MOVWF  FE9
5B7E:  MOVLW  00
5B80:  ADDWFC x37,W
5B82:  MOVWF  FEA
5B84:  MOVF   FEE,F
5B86:  MOVF   FEE,F
5B88:  CLRF   FEC
5B8A:  MOVF   FED,F
5B8C:  CLRF   FEF
5B8E:  MOVF   FED,F
5B90:  CLRF   FEF
5B92:  MOVF   FED,F
5B94:  CLRF   FEF
....................    stream->Size = 0; 
5B96:  MOVLW  10
5B98:  ADDWF  x36,W
5B9A:  MOVWF  FE9
5B9C:  MOVLW  00
5B9E:  ADDWFC x37,W
5BA0:  MOVWF  FEA
5BA2:  MOVF   FEE,F
5BA4:  MOVF   FEE,F
5BA6:  CLRF   FEC
5BA8:  MOVF   FED,F
5BAA:  CLRF   FEF
5BAC:  MOVF   FED,F
5BAE:  CLRF   FEF
5BB0:  MOVF   FED,F
5BB2:  CLRF   FEF
....................    stream->Start_Addr = 0; 
5BB4:  MOVLW  14
5BB6:  ADDWF  x36,W
5BB8:  MOVWF  FE9
5BBA:  MOVLW  00
5BBC:  ADDWFC x37,W
5BBE:  MOVWF  FEA
5BC0:  MOVF   FEE,F
5BC2:  MOVF   FEE,F
5BC4:  CLRF   FEC
5BC6:  MOVF   FED,F
5BC8:  CLRF   FEF
5BCA:  MOVF   FED,F
5BCC:  CLRF   FEF
5BCE:  MOVF   FED,F
5BD0:  CLRF   FEF
....................    stream->Flags = 0; 
5BD2:  MOVLW  19
5BD4:  ADDWF  x36,W
5BD6:  MOVWF  FE9
5BD8:  MOVLW  00
5BDA:  ADDWFC x37,W
5BDC:  MOVWF  FEA
5BDE:  CLRF   FEF
....................    return 0; 
5BE0:  MOVLW  00
5BE2:  MOVWF  01
5BE4:  MOVLB  0
5BE6:  GOTO   5BF8 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatgetc(FILE* stream) 
.................... Summary: Gets a character from a stream. 
.................... Param: The stream to get a character from. 
.................... Returns: The character that was gotten from the stream, 
....................           EOF if the stream has reached the end of the file or doesn't have permissions to read, 
.................... */ 
.................... signed int fatgetc(FILE* stream) 
.................... { 
....................    char ch; // character read in 
....................  
....................    // check to see if the stream has proper permissions to read 
....................    if(stream->Flags & Read) 
....................    { 
....................       // when the number of bytes until eof hit zero, we know we are at the end of any file 
....................       if(stream->Bytes_Until_EOF == 0) 
....................       { 
....................          stream->Flags |= EOF_Reached; 
....................          return EOF; 
....................       } 
....................  
....................       // read in the next byte in the buffer 
....................       if(read_buffer(stream, &ch) == EOF) 
....................          return EOF; 
....................  
....................       // a 0x00 will signify the end of a non-binary file 
....................       if((ch == '\0') && !(stream->Flags & Binary)) 
....................       { 
....................          stream->Flags |= EOF_Reached; 
....................          return EOF; 
....................       } 
....................  
....................       // get the next contiguous address of the stream 
....................       if(get_next_addr(&(stream->Cur_Char)) != GOODEC) 
....................          return EOF; 
....................           
....................       // we just got 1 byte closer to the end of the file 
....................       stream->Bytes_Until_EOF -= 1; 
....................       return ch; 
....................    } 
....................  
....................    // if the stream doesn't have proper permissions to read, return an EOF 
....................    else 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... signed int fatputc(int ch, FILE* stream) 
.................... Summary: Puts a character into a stream. 
.................... Param ch: The character to put into the stream. 
.................... Param stream: The stream to put a character into. 
.................... Returns: The character that was put into the stream, 
....................           EOF if the stream doesn't have permissions to write, or if a problem happened. 
.................... */ 
.................... signed int fatputc(int ch, FILE* stream) 
.................... { 
....................    // check to see if the stream has proper permissions to write 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->File_Type == Data_File)) 
*
4330:  MOVLW  19
4332:  MOVLB  3
4334:  ADDWF  xE5,W
4336:  MOVWF  FE9
4338:  MOVLW  00
433A:  ADDWFC xE6,W
433C:  MOVWF  FEA
433E:  BTFSC  FEF.1
4340:  BRA    4352
4342:  MOVLW  19
4344:  ADDWF  xE5,W
4346:  MOVWF  FE9
4348:  MOVLW  00
434A:  ADDWFC xE6,W
434C:  MOVWF  FEA
434E:  BTFSS  FEF.2
4350:  BRA    4608
4352:  MOVLW  18
4354:  ADDWF  xE5,W
4356:  MOVWF  FE9
4358:  MOVLW  00
435A:  ADDWFC xE6,W
435C:  MOVWF  FEA
435E:  MOVF   FEF,F
4360:  BTFSS  FD8.2
4362:  BRA    4608
....................    { 
....................       // if there isn't any space allocated yet, allocate some 
....................       if(stream->Cur_Char < Data_Start) 
4364:  MOVLW  04
4366:  ADDWF  xE5,W
4368:  MOVWF  FE9
436A:  MOVLW  00
436C:  ADDWFC xE6,W
436E:  MOVWF  FEA
4370:  MOVFF  FEF,3E7
4374:  MOVFF  FEC,3E8
4378:  MOVFF  FEC,3E9
437C:  MOVFF  FEC,3EA
4380:  MOVF   xEA,W
4382:  MOVLB  2
4384:  SUBWF  x15,W
4386:  BTFSS  FD8.0
4388:  BRA    448E
438A:  BNZ   43B8
438C:  MOVLB  3
438E:  MOVF   xE9,W
4390:  MOVLB  2
4392:  SUBWF  x14,W
4394:  BTFSS  FD8.0
4396:  BRA    448E
4398:  BNZ   43B8
439A:  MOVLB  3
439C:  MOVF   xE8,W
439E:  MOVLB  2
43A0:  SUBWF  x13,W
43A2:  BTFSS  FD8.0
43A4:  BRA    448E
43A6:  BNZ   43B8
43A8:  MOVF   x12,W
43AA:  MOVLB  3
43AC:  SUBWF  xE7,W
43AE:  BTFSS  FD8.0
43B0:  BRA    43B6
43B2:  MOVLB  2
43B4:  BRA    448E
43B6:  MOVLB  2
....................       { 
....................          if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
43B8:  MOVLW  02
43BA:  MOVLB  3
43BC:  MOVWF  xFC
43BE:  MOVLW  1A
43C0:  MOVWF  xFB
43C2:  MOVLB  0
43C4:  RCALL  3C90
43C6:  MOVF   01,W
43C8:  SUBLW  FF
43CA:  BNZ   43D2
....................             return EOF; 
43CC:  MOVLW  FF
43CE:  MOVWF  01
43D0:  BRA    460E
.................... #ifdef FAT32 
....................          if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
43D2:  MOVFF  21D,3FE
43D6:  MOVFF  21C,3FD
43DA:  MOVFF  21B,3FC
43DE:  MOVFF  21A,3FB
43E2:  MOVLW  0F
43E4:  MOVLB  4
43E6:  MOVWF  x02
43E8:  SETF   x01
43EA:  SETF   x00
43EC:  MOVLB  3
43EE:  SETF   xFF
43F0:  MOVLB  0
43F2:  CALL   3AE6
43F6:  MOVF   01,W
43F8:  SUBLW  FF
43FA:  BNZ   4402
....................             return EOF; 
43FC:  MOVLW  FF
43FE:  MOVWF  01
4400:  BRA    460E
.................... #else // FAT16 
....................          if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................             return EOF; 
.................... #endif // #ifdef FAT32 
....................          if(clear_cluster(Next_Free_Clust) == EOF) 
4402:  MOVFF  21D,3FE
4406:  MOVFF  21C,3FD
440A:  MOVFF  21B,3FC
440E:  MOVFF  21A,3FB
4412:  RCALL  3E1C
4414:  MOVF   01,W
4416:  SUBLW  FF
4418:  BNZ   4420
....................             return EOF; 
441A:  MOVLW  FF
441C:  MOVWF  01
441E:  BRA    460E
....................          stream->Cur_Char = stream->Start_Addr = cluster_to_addr(Next_Free_Clust); 
4420:  MOVLW  04
4422:  MOVLB  3
4424:  ADDWF  xE5,W
4426:  MOVWF  01
4428:  MOVLW  00
442A:  ADDWFC xE6,W
442C:  MOVWF  03
442E:  MOVFF  01,3E7
4432:  MOVWF  xE8
4434:  MOVLW  14
4436:  ADDWF  xE5,W
4438:  MOVWF  01
443A:  MOVLW  00
443C:  ADDWFC xE6,W
443E:  MOVWF  03
4440:  MOVFF  01,3E9
4444:  MOVWF  xEA
4446:  MOVFF  21D,429
444A:  MOVFF  21C,428
444E:  MOVFF  21B,427
4452:  MOVFF  21A,426
4456:  MOVLB  0
4458:  CALL   3480
445C:  MOVFF  3EA,FEA
4460:  MOVFF  3E9,FE9
4464:  MOVFF  00,FEF
4468:  MOVFF  01,FEC
446C:  MOVFF  02,FEC
4470:  MOVFF  03,FEC
4474:  MOVFF  3E8,FEA
4478:  MOVFF  3E7,FE9
447C:  MOVFF  00,FEF
4480:  MOVFF  01,FEC
4484:  MOVFF  02,FEC
4488:  MOVFF  03,FEC
448C:  MOVLB  2
....................       } 
....................  
....................       // write the next character to the buffer 
....................       if(write_buffer(stream, ch) == EOF) 
448E:  MOVFF  3E6,3E8
4492:  MOVFF  3E5,3E7
4496:  MOVFF  3E4,3E9
449A:  MOVLB  0
449C:  BRA    3ED6
449E:  MOVF   01,W
44A0:  SUBLW  FF
44A2:  BNZ   44AA
....................          return EOF; 
44A4:  MOVLW  FF
44A6:  MOVWF  01
44A8:  BRA    460E
....................  
....................       // get the next address, increment Cur_Char 
....................       if(get_next_addr(&(stream->Cur_Char)) == EOF) 
44AA:  MOVLW  04
44AC:  MOVLB  3
44AE:  ADDWF  xE5,W
44B0:  MOVWF  01
44B2:  MOVLW  00
44B4:  ADDWFC xE6,W
44B6:  MOVWF  03
44B8:  MOVFF  01,3E7
44BC:  MOVWF  xE8
44BE:  MOVWF  xEA
44C0:  MOVFF  01,3E9
44C4:  MOVLB  0
44C6:  RCALL  4034
44C8:  MOVF   01,W
44CA:  SUBLW  FF
44CC:  BTFSS  FD8.2
44CE:  BRA    45C4
....................       { 
....................          // write the current buffer to the end of the current cluster 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE + 1, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
44D0:  MOVLW  04
44D2:  MOVLB  3
44D4:  ADDWF  xE5,W
44D6:  MOVWF  FE9
44D8:  MOVLW  00
44DA:  ADDWFC xE6,W
44DC:  MOVWF  FEA
44DE:  MOVFF  FEF,3E7
44E2:  MOVFF  FEC,3E8
44E6:  MOVFF  FEC,3E9
44EA:  MOVFF  FEC,3EA
44EE:  MOVLW  20
44F0:  SUBWF  xE7,F
44F2:  MOVLW  00
44F4:  SUBWFB xE8,F
44F6:  SUBWFB xE9,F
44F8:  SUBWFB xEA,F
44FA:  MOVLW  01
44FC:  ADDWF  xE7,F
44FE:  MOVLW  00
4500:  ADDWFC xE8,F
4502:  ADDWFC xE9,F
4504:  ADDWFC xEA,F
4506:  MOVLW  1A
4508:  ADDWF  xE5,W
450A:  MOVWF  01
450C:  MOVLW  00
450E:  ADDWFC xE6,W
4510:  MOVWF  03
4512:  MOVFF  01,3EB
4516:  MOVWF  xEC
4518:  MOVFF  3EA,42D
451C:  MOVFF  3E9,42C
4520:  MOVFF  3E8,42B
4524:  MOVFF  3E7,42A
4528:  MOVLB  4
452A:  CLRF   x2F
452C:  MOVLW  20
452E:  MOVWF  x2E
4530:  MOVFF  03,431
4534:  MOVFF  01,430
4538:  MOVLB  0
453A:  CALL   3A60
453E:  MOVF   01,F
4540:  BZ    455E
....................          { 
....................             stream->Flags |= Write_Error; 
4542:  MOVLW  19
4544:  MOVLB  3
4546:  ADDWF  xE5,W
4548:  MOVWF  FE9
454A:  MOVLW  00
454C:  ADDWFC xE6,W
454E:  MOVWF  FEA
4550:  MOVF   FEF,W
4552:  IORLW  40
4554:  MOVWF  FEF
....................             return EOF; 
4556:  MOVLW  FF
4558:  MOVWF  01
455A:  MOVLB  0
455C:  BRA    460E
....................          } 
....................          // start looking for a new cluster to allocate 
....................          if(alloc_clusters(addr_to_cluster(stream->Cur_Char), &(stream->Cur_Char)) == EOF) 
455E:  MOVLW  04
4560:  MOVLB  3
4562:  ADDWF  xE5,W
4564:  MOVWF  FE9
4566:  MOVLW  00
4568:  ADDWFC xE6,W
456A:  MOVWF  FEA
456C:  MOVFF  FEF,3F4
4570:  MOVFF  FEC,3F5
4574:  MOVFF  FEC,3F6
4578:  MOVFF  FEC,3F7
457C:  MOVLB  0
457E:  CALL   3324
4582:  MOVFF  03,3F0
4586:  MOVFF  02,3E9
458A:  MOVFF  01,3EE
458E:  MOVFF  00,3E7
4592:  MOVLW  04
4594:  MOVLB  3
4596:  ADDWF  xE5,W
4598:  MOVWF  01
459A:  MOVLW  00
459C:  ADDWFC xE6,W
459E:  MOVWF  03
45A0:  MOVFF  01,3EB
45A4:  MOVWF  xEC
45A6:  MOVFF  02,3EF
45AA:  MOVFF  00,3ED
45AE:  MOVWF  xF2
45B0:  MOVFF  01,3F1
45B4:  MOVLB  0
45B6:  BRA    423A
45B8:  MOVF   01,W
45BA:  SUBLW  FF
45BC:  BNZ   45C4
....................             return EOF; 
45BE:  MOVLW  FF
45C0:  MOVWF  01
45C2:  BRA    460E
....................       } 
....................  
....................       // our file just got bigger by 1 byte 
....................       stream->Size += 1; 
45C4:  MOVLW  10
45C6:  MOVLB  3
45C8:  ADDWF  xE5,W
45CA:  MOVWF  FE9
45CC:  MOVLW  00
45CE:  ADDWFC xE6,W
45D0:  MOVWF  FEA
45D2:  MOVLW  01
45D4:  ADDWF  FEF,W
45D6:  MOVWF  00
45D8:  MOVLW  00
45DA:  ADDWFC FEC,W
45DC:  MOVWF  01
45DE:  MOVLW  00
45E0:  ADDWFC FEC,W
45E2:  MOVWF  02
45E4:  MOVLW  00
45E6:  ADDWFC FEC,W
45E8:  MOVF   FED,F
45EA:  MOVF   FED,F
45EC:  MOVF   FED,F
45EE:  MOVFF  00,FEF
45F2:  MOVFF  01,FEC
45F6:  MOVFF  02,FEC
45FA:  MOVWF  FEC
....................  
....................       return ch; 
45FC:  MOVFF  3E4,01
4600:  MOVLB  0
4602:  BRA    460E
....................    } 
4604:  BRA    460E
4606:  MOVLB  3
....................  
....................    // if the stream doesn't have proper permissions to write, return an EOF 
....................    else 
....................       return EOF; 
4608:  MOVLW  FF
460A:  MOVWF  01
460C:  MOVLB  0
460E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... Summary: Reads characters from a stream into a string. 
.................... Param str: A pointer to the beginning of the string to put characters into. 
.................... Param num: The number of characters to put into the string - 1. 
.................... Param stream: The stream to read from. 
.................... Returns: A pointer to the most recently added character, or NULL if there was an error. 
.................... Note: If a newline is read from the stream, then str will be terminated with a newline. 
....................        If num - 1 or EOF is reached, then str will be null terminated. 
.................... */ 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... { 
....................    int i;   // counter for loops 
....................  
....................    // loop until num - 1 
....................    for(i = 0; i < num - 1; i += 1) 
....................    { 
....................       str[i] = fatgetc(stream); 
....................       if(str[i] == '\n') 
....................          return str; 
....................       if(str[i] == EOF) 
....................          break; 
....................    } 
....................  
....................    // close off str with a null terminator 
....................    str[i] = '\0'; 
....................  
....................    return str; 
.................... } 
....................  
.................... /* 
.................... signed int fatputs(char* str, FILE* stream) 
.................... Summary: Writes characters from a string into a stream. 
.................... Param str: A pointer to the beginning of the string to write into the stream. 
.................... Param stream: The stream to write into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatputs(char* str, FILE* stream) 
*
5690:  MOVLB  3
5692:  CLRF   x3F
.................... { 
....................    int i = 0;   // counter for loops 
....................  
....................    // fatputc every character in the stream 
....................    while(str[i] != '\0') 
5694:  MOVF   x3F,W
5696:  ADDWF  x3B,W
5698:  MOVWF  FE9
569A:  MOVLW  00
569C:  ADDWFC x3C,W
569E:  MOVWF  FEA
56A0:  MOVF   FEF,F
56A2:  BZ    56D6
....................    { 
....................       if(fatputc(str[i], stream) == EOF) 
56A4:  MOVF   x3F,W
56A6:  ADDWF  x3B,W
56A8:  MOVWF  FE9
56AA:  MOVLW  00
56AC:  ADDWFC x3C,W
56AE:  MOVWF  FEA
56B0:  MOVFF  FEF,3E4
56B4:  MOVFF  33E,3E6
56B8:  MOVFF  33D,3E5
56BC:  MOVLB  0
56BE:  CALL   4330
56C2:  MOVF   01,W
56C4:  SUBLW  FF
56C6:  BNZ   56CE
....................         return EOF; 
56C8:  MOVLW  FF
56CA:  MOVWF  01
56CC:  BRA    56DC
....................       i += 1; 
56CE:  MOVLW  01
56D0:  MOVLB  3
56D2:  ADDWF  x3F,F
56D4:  BRA    5694
....................    } 
....................  
....................    return GOODEC; 
56D6:  MOVLW  00
56D8:  MOVWF  01
56DA:  MOVLB  0
56DC:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatprintf(FILE* stream) 
.................... Summary: This will print off the entire contents of the stream to the console. 
.................... Param: The stream to print off. 
.................... Returns: The last character printed off to the console. 
.................... */ 
.................... signed int fatprintf(FILE* stream) 
.................... { 
....................    signed int ch; // character read in 
....................  
....................    // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................    do 
....................    { 
....................       ch = fatgetc(stream); 
....................       printf("%c", ch); 
....................    } while(ch != EOF); 
....................  
....................    return ch; 
.................... } 
....................  
.................... /* 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param stream: The stream to get the position of. 
.................... Param position: A pointer to a variable put the current position of the pointer into. 
.................... Returns: 0 on success. 
.................... */ 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... { 
....................    *position = stream->Size - stream->Bytes_Until_EOF; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Sets the current position of where the stream is pointing to in memory relative to the beginning of the stream. 
.................... Param stream: The stream to set the position of. 
.................... Param position: A pointer the a variable that has the value of the new position. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... { 
.................... #ifndef FAST_FAT 
.................... #ifdef FAT32 
....................    int32 cur_cluster; // the current cluster we're pointing to 
.................... #else // FAT16 
....................    int16 cur_cluster; // the current cluster we're pointing to 
.................... #endif // #ifdef FAT32 
....................    int32 i;    // pointer to memory 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // check to see if we want to just rewind the file 
....................    if(*position == 0) 
*
4610:  MOVFF  3DB,03
4614:  MOVLB  3
4616:  MOVFF  3DA,FE9
461A:  MOVFF  3DB,FEA
461E:  MOVFF  FEF,3E4
4622:  MOVFF  FEC,3E5
4626:  MOVFF  FEC,3E6
462A:  MOVFF  FEC,3E7
462E:  MOVF   xE4,F
4630:  BNZ   4654
4632:  MOVF   xE5,F
4634:  BNZ   4654
4636:  MOVF   xE6,F
4638:  BNZ   4654
463A:  MOVF   xE7,F
463C:  BNZ   4654
....................    { 
....................       rewind(stream); 
463E:  MOVFF  3D9,3E5
4642:  MOVFF  3D8,3E4
4646:  MOVLB  0
4648:  GOTO   3C0E
....................       return GOODEC; 
464C:  MOVLW  00
464E:  MOVWF  01
4650:  BRA    4A06
4652:  MOVLB  3
....................    } 
....................     
....................    // this whole process is much different and easier if we're writing or appending at a spot after EOF 
....................    //  this will essentially write null characters to the file from EOF to the desired position 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->Size < *position)) 
4654:  MOVLW  19
4656:  ADDWF  xD8,W
4658:  MOVWF  FE9
465A:  MOVLW  00
465C:  ADDWFC xD9,W
465E:  MOVWF  FEA
4660:  BTFSC  FEF.1
4662:  BRA    4674
4664:  MOVLW  19
4666:  ADDWF  xD8,W
4668:  MOVWF  FE9
466A:  MOVLW  00
466C:  ADDWFC xD9,W
466E:  MOVWF  FEA
4670:  BTFSS  FEF.2
4672:  BRA    4740
4674:  MOVLW  10
4676:  ADDWF  xD8,W
4678:  MOVWF  FE9
467A:  MOVLW  00
467C:  ADDWFC xD9,W
467E:  MOVWF  FEA
4680:  MOVFF  FEF,3E4
4684:  MOVFF  FEC,3E5
4688:  MOVFF  FEC,3E6
468C:  MOVFF  FEC,3E7
4690:  MOVFF  3DA,FE9
4694:  MOVFF  3DB,FEA
4698:  MOVFF  FEF,00
469C:  MOVFF  FEC,01
46A0:  MOVFF  FEC,02
46A4:  MOVFF  FEC,03
46A8:  MOVF   xE7,W
46AA:  SUBWF  03,W
46AC:  BNC   4740
46AE:  BNZ   46C6
46B0:  MOVF   xE6,W
46B2:  SUBWF  02,W
46B4:  BNC   4740
46B6:  BNZ   46C6
46B8:  MOVF   xE5,W
46BA:  SUBWF  01,W
46BC:  BNC   4740
46BE:  BNZ   46C6
46C0:  MOVF   00,W
46C2:  SUBWF  xE4,W
46C4:  BC    4740
....................    { 
....................       while(stream->Size < *position) 
46C6:  MOVLW  10
46C8:  ADDWF  xD8,W
46CA:  MOVWF  FE9
46CC:  MOVLW  00
46CE:  ADDWFC xD9,W
46D0:  MOVWF  FEA
46D2:  MOVFF  FEF,3E4
46D6:  MOVFF  FEC,3E5
46DA:  MOVFF  FEC,3E6
46DE:  MOVFF  FEC,3E7
46E2:  MOVFF  3DA,FE9
46E6:  MOVFF  3DB,FEA
46EA:  MOVFF  FEF,00
46EE:  MOVFF  FEC,01
46F2:  MOVFF  FEC,02
46F6:  MOVFF  FEC,03
46FA:  MOVF   xE7,W
46FC:  SUBWF  03,W
46FE:  BNC   4736
4700:  BNZ   4718
4702:  MOVF   xE6,W
4704:  SUBWF  02,W
4706:  BNC   4736
4708:  BNZ   4718
470A:  MOVF   xE5,W
470C:  SUBWF  01,W
470E:  BNC   4736
4710:  BNZ   4718
4712:  MOVF   00,W
4714:  SUBWF  xE4,W
4716:  BC    4736
....................          if(fatputc('\0', stream) == EOF) 
4718:  CLRF   xE4
471A:  MOVFF  3D9,3E6
471E:  MOVFF  3D8,3E5
4722:  MOVLB  0
4724:  RCALL  4330
4726:  MOVF   01,W
4728:  SUBLW  FF
472A:  BNZ   4732
....................             return EOF; 
472C:  MOVLW  FF
472E:  MOVWF  01
4730:  BRA    4A06
4732:  MOVLB  3
4734:  BRA    46C6
....................        
....................       return 0; 
4736:  MOVLW  00
4738:  MOVWF  01
473A:  MOVLB  0
473C:  BRA    4A06
473E:  MOVLB  3
....................    } 
....................  
.................... #ifdef FAST_FAT 
....................    stream->Cur_Char = stream->Start_Addr + *position; 
.................... #else // NO FAST_FAT 
....................    // figure out how many clusters into the file the position is to be set to 
....................    i = *position / Bytes_Per_Cluster; 
4740:  MOVFF  3DB,03
4744:  MOVFF  3DA,FE9
4748:  MOVFF  3DB,FEA
474C:  MOVFF  FEF,3FC
4750:  MOVFF  FEC,3FD
4754:  MOVFF  FEC,3FE
4758:  MOVFF  FEC,3FF
475C:  MOVFF  FEA,3E9
4760:  MOVFF  FE9,3E8
4764:  BCF    FD8.1
4766:  MOVLB  4
4768:  CLRF   x03
476A:  CLRF   x02
476C:  MOVFF  20D,401
4770:  MOVFF  20C,400
4774:  MOVLB  0
4776:  CALL   0E8E
477A:  MOVFF  3E9,FEA
477E:  MOVFF  3E8,FE9
4782:  MOVFF  03,3E3
4786:  MOVFF  02,3E2
478A:  MOVFF  01,3E1
478E:  MOVFF  00,3E0
....................    cur_cluster = addr_to_cluster(stream->Start_Addr); 
4792:  MOVLW  14
4794:  MOVLB  3
4796:  ADDWF  xD8,W
4798:  MOVWF  FE9
479A:  MOVLW  00
479C:  ADDWFC xD9,W
479E:  MOVWF  FEA
47A0:  MOVFF  FEF,3F4
47A4:  MOVFF  FEC,3F5
47A8:  MOVFF  FEC,3F6
47AC:  MOVFF  FEC,3F7
47B0:  MOVLB  0
47B2:  CALL   3324
47B6:  MOVFF  03,3DF
47BA:  MOVFF  02,3DE
47BE:  MOVFF  01,3DD
47C2:  MOVFF  00,3DC
....................  
....................    // head to that cluster 
....................    while(i > 0) 
47C6:  MOVLB  3
47C8:  MOVF   xE0,F
47CA:  BNZ   47D8
47CC:  MOVF   xE1,F
47CE:  BNZ   47D8
47D0:  MOVF   xE2,F
47D2:  BNZ   47D8
47D4:  MOVF   xE3,F
47D6:  BZ    4800
....................    { 
....................       if(get_next_cluster(&cur_cluster) != GOODEC) 
47D8:  MOVLW  03
47DA:  MOVWF  xF0
47DC:  MOVLW  DC
47DE:  MOVWF  xEF
47E0:  MOVLB  0
47E2:  CALL   398A
47E6:  MOVF   01,F
47E8:  BZ    47F0
....................          return EOF; 
47EA:  MOVLW  FF
47EC:  MOVWF  01
47EE:  BRA    4A06
....................       i -= 1; 
47F0:  MOVLW  01
47F2:  MOVLB  3
47F4:  SUBWF  xE0,F
47F6:  MOVLW  00
47F8:  SUBWFB xE1,F
47FA:  SUBWFB xE2,F
47FC:  SUBWFB xE3,F
47FE:  BRA    47C8
....................    } 
....................  
....................    // head to the correct cluster 
....................    stream->Cur_Char = cluster_to_addr(cur_cluster); 
4800:  MOVLW  04
4802:  ADDWF  xD8,W
4804:  MOVWF  01
4806:  MOVLW  00
4808:  ADDWFC xD9,W
480A:  MOVWF  03
480C:  MOVFF  01,3E4
4810:  MOVWF  xE5
4812:  MOVFF  3DF,429
4816:  MOVFF  3DE,428
481A:  MOVFF  3DD,427
481E:  MOVFF  3DC,426
4822:  MOVLB  0
4824:  CALL   3480
4828:  MOVFF  3E5,FEA
482C:  MOVFF  3E4,FE9
4830:  MOVFF  00,FEF
4834:  MOVFF  01,FEC
4838:  MOVFF  02,FEC
483C:  MOVFF  03,FEC
....................  
....................    // now that we're in the correct cluster, tack on the remaining position 
....................    stream->Cur_Char += (*position % Bytes_Per_Cluster); 
4840:  MOVLW  04
4842:  MOVLB  3
4844:  ADDWF  xD8,W
4846:  MOVWF  01
4848:  MOVLW  00
484A:  ADDWFC xD9,W
484C:  MOVFF  01,3E4
4850:  MOVWF  xE5
4852:  MOVWF  FEA
4854:  MOVFF  01,FE9
4858:  MOVFF  FEF,3E6
485C:  MOVFF  FEC,3E7
4860:  MOVFF  FEC,3E8
4864:  MOVFF  FEC,3E9
4868:  MOVFF  3DB,03
486C:  MOVFF  3DA,FE9
4870:  MOVFF  3DB,FEA
4874:  MOVFF  FEF,3FC
4878:  MOVFF  FEC,3FD
487C:  MOVFF  FEC,3FE
4880:  MOVFF  FEC,3FF
4884:  MOVFF  FEA,3EF
4888:  MOVFF  FE9,3EE
488C:  BSF    FD8.1
488E:  MOVLW  03
4890:  MOVWF  FEA
4892:  MOVLW  F0
4894:  MOVWF  FE9
4896:  MOVLB  4
4898:  CLRF   x03
489A:  CLRF   x02
489C:  MOVFF  20D,401
48A0:  MOVFF  20C,400
48A4:  MOVLB  0
48A6:  CALL   0E8E
48AA:  MOVFF  3F0,00
48AE:  MOVFF  3F1,01
48B2:  MOVFF  3F2,02
48B6:  MOVFF  3F3,03
48BA:  MOVFF  3EF,FEA
48BE:  MOVFF  3EE,FE9
48C2:  MOVLB  3
48C4:  MOVF   xE6,W
48C6:  ADDWF  00,F
48C8:  MOVF   xE7,W
48CA:  ADDWFC 01,F
48CC:  MOVF   xE8,W
48CE:  ADDWFC 02,F
48D0:  MOVF   xE9,W
48D2:  ADDWFC 03,F
48D4:  MOVFF  3E5,FEA
48D8:  MOVFF  3E4,FE9
48DC:  MOVFF  00,FEF
48E0:  MOVFF  01,FEC
48E4:  MOVFF  02,FEC
48E8:  MOVFF  03,FEC
....................  
....................    if(stream->Flags & Read) 
48EC:  MOVLW  19
48EE:  ADDWF  xD8,W
48F0:  MOVWF  FE9
48F2:  MOVLW  00
48F4:  ADDWFC xD9,W
48F6:  MOVWF  FEA
48F8:  BTFSS  FEF.0
48FA:  BRA    49C4
....................    { 
....................       // we now need to change how far it is until EOF 
....................       stream->Bytes_Until_EOF = stream->Size - *position; 
48FC:  MOVLW  10
48FE:  ADDWF  xD8,W
4900:  MOVWF  FE9
4902:  MOVLW  00
4904:  ADDWFC xD9,W
4906:  MOVWF  FEA
4908:  MOVFF  FEF,3E6
490C:  MOVFF  FEC,3E7
4910:  MOVFF  FEC,3E8
4914:  MOVFF  FEC,3E9
4918:  MOVFF  3DA,FE9
491C:  MOVFF  3DB,FEA
4920:  MOVFF  FEF,00
4924:  MOVFF  FEC,01
4928:  MOVFF  FEC,02
492C:  MOVFF  FEC,03
4930:  MOVF   00,W
4932:  SUBWF  xE6,W
4934:  MOVWF  00
4936:  MOVF   01,W
4938:  SUBWFB xE7,W
493A:  MOVWF  01
493C:  MOVF   02,W
493E:  SUBWFB xE8,W
4940:  MOVWF  02
4942:  MOVF   03,W
4944:  SUBWFB xE9,W
4946:  MOVFF  3D9,FEA
494A:  MOVFF  3D8,FE9
494E:  MOVFF  00,FEF
4952:  MOVFF  01,FEC
4956:  MOVFF  02,FEC
495A:  MOVWF  FEC
....................  
....................       // fill up the buffer 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
495C:  MOVLW  04
495E:  ADDWF  xD8,W
4960:  MOVWF  FE9
4962:  MOVLW  00
4964:  ADDWFC xD9,W
4966:  MOVWF  FEA
4968:  MOVFF  FEF,416
496C:  MOVFF  FEC,417
4970:  MOVFF  FEC,418
4974:  MOVFF  FEC,419
4978:  MOVLW  1A
497A:  ADDWF  xD8,W
497C:  MOVWF  01
497E:  MOVLW  00
4980:  ADDWFC xD9,W
4982:  MOVWF  03
4984:  MOVFF  01,3E8
4988:  MOVWF  xE9
498A:  MOVLB  4
498C:  CLRF   x1B
498E:  MOVLW  20
4990:  MOVWF  x1A
4992:  MOVFF  03,41D
4996:  MOVFF  01,41C
499A:  MOVLB  0
499C:  CALL   2BB8
49A0:  MOVF   01,F
49A2:  BZ    49C0
....................       { 
....................          stream->Flags |= Read_Error; 
49A4:  MOVLW  19
49A6:  MOVLB  3
49A8:  ADDWF  xD8,W
49AA:  MOVWF  FE9
49AC:  MOVLW  00
49AE:  ADDWFC xD9,W
49B0:  MOVWF  FEA
49B2:  MOVF   FEF,W
49B4:  IORLW  20
49B6:  MOVWF  FEF
....................          return EOF; 
49B8:  MOVLW  FF
49BA:  MOVWF  01
49BC:  MOVLB  0
49BE:  BRA    4A06
....................       } 
....................    } 
49C0:  BRA    4A02
49C2:  MOVLB  3
....................  
....................    else 
....................       stream->Size = *position; 
49C4:  MOVLW  10
49C6:  ADDWF  xD8,W
49C8:  MOVWF  01
49CA:  MOVLW  00
49CC:  ADDWFC xD9,W
49CE:  MOVFF  01,3E4
49D2:  MOVFF  3DA,FE9
49D6:  MOVFF  3DB,FEA
49DA:  MOVFF  FEF,00
49DE:  MOVFF  FEC,01
49E2:  MOVFF  FEC,02
49E6:  MOVFF  FEC,03
49EA:  MOVWF  FEA
49EC:  MOVFF  3E4,FE9
49F0:  MOVFF  00,FEF
49F4:  MOVFF  01,FEC
49F8:  MOVFF  02,FEC
49FC:  MOVFF  03,FEC
4A00:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
....................    return 0; 
4A02:  MOVLW  00
4A04:  MOVWF  01
4A06:  GOTO   4F04 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... Summary: This will set the position of the file stream according to the input. The EOF flag will also be cleared. 
.................... Param stream: The stream to set the position of. 
.................... Param offset: How many bytes relative of origin the file stream position will be set. 
.................... Param origin: This will be one of 3 values... 
....................                SEEK_CUR: Set position relative to the current stream position. 
....................                SEEK_END: Set position relative to the end of the stream. 
....................                SEEK_SET: Set position relative to the beginning of the stream. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... { 
....................    int32 myoffset;   // since fatsetpos requires a pointer to a variable, we need this here 
....................  
....................    switch(origin) 
....................    { 
....................       case SEEK_CUR: 
....................          myoffset = stream->Cur_Char + offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_END: 
....................          myoffset = stream->Size - offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_SET: 
....................          myoffset = offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // clear the EOF flag 
....................    stream->Flags &= 0xEF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fateof(FILE* stream) 
.................... Summary: Determines whether or not the stream is at the end of the file. 
.................... Param: The stream to query for EOF. 
.................... Returns: A non-zero value if the file is at EOF, 
....................           0 if the file is not at EOF. 
.................... */ 
.................... signed int fateof(FILE* stream) 
.................... { 
....................    return stream->Flags & EOF_Reached; 
.................... } 
....................  
.................... /* 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... Summary: Fills up an array with data from a stream. 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to fill in the array. 
.................... Param stream: The stream to read from. 
.................... Returns: How many values were written to the array. 
.................... */ 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // fill up every byte 
....................    for(i = 0; i < (num * size); i += 1) 
....................       buffer[i] = fatgetc(stream); 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... Summary: Fills up a stream with data from an array 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to write to the stream. 
.................... Param stream: The stream to write to. 
.................... Returns: How many values were written to the stream. 
.................... */ 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // write every byte 
....................    for(i = 0; i < (count * (int32)size); i += 1) 
....................       if(fatputc(buffer[i], stream) == EOF) 
....................          return EOF; 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatflush(FILE* stream) 
.................... Summary: Flushes the buffer of a given stream. 
.................... Param: The stream to flush the buffer of. 
.................... Returns: EOF if there was a problem, 0 if everything went okay 
.................... */ 
.................... signed int fatflush(FILE* stream) 
.................... { 
....................    // check to see if we have a buffer 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
*
5726:  MOVLW  19
5728:  MOVLB  3
572A:  ADDWF  x3D,W
572C:  MOVWF  FE9
572E:  MOVLW  00
5730:  ADDWFC x3E,W
5732:  MOVWF  FEA
5734:  BTFSC  FEF.1
5736:  BRA    5748
5738:  MOVLW  19
573A:  ADDWF  x3D,W
573C:  MOVWF  FE9
573E:  MOVLW  00
5740:  ADDWFC x3E,W
5742:  MOVWF  FEA
5744:  BTFSS  FEF.2
5746:  BRA    58B8
....................    { 
....................       // check to see if we need to flush the buffer 
....................       if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
5748:  MOVLW  04
574A:  ADDWF  x3D,W
574C:  MOVWF  FE9
574E:  MOVLW  00
5750:  ADDWFC x3E,W
5752:  MOVWF  FEA
5754:  MOVFF  FEF,33F
5758:  MOVFF  FEC,340
575C:  MOVFF  FEC,341
5760:  MOVFF  FEC,342
5764:  MOVLW  1F
5766:  ANDWF  x3F,F
5768:  CLRF   x40
576A:  CLRF   x41
576C:  CLRF   x42
576E:  MOVF   x3F,F
5770:  BNZ   5802
5772:  MOVF   x40,F
5774:  BNZ   5802
5776:  MOVF   x41,F
5778:  BNZ   5802
577A:  MOVF   x42,F
577C:  BNZ   5802
....................       { 
....................          // flush the buffer to the card 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
577E:  MOVLW  04
5780:  ADDWF  x3D,W
5782:  MOVWF  FE9
5784:  MOVLW  00
5786:  ADDWFC x3E,W
5788:  MOVWF  FEA
578A:  MOVFF  FEF,33F
578E:  MOVFF  FEC,340
5792:  MOVFF  FEC,341
5796:  MOVFF  FEC,342
579A:  MOVLW  20
579C:  SUBWF  x3F,F
579E:  MOVLW  00
57A0:  SUBWFB x40,F
57A2:  SUBWFB x41,F
57A4:  SUBWFB x42,F
57A6:  MOVLW  1A
57A8:  ADDWF  x3D,W
57AA:  MOVWF  01
57AC:  MOVLW  00
57AE:  ADDWFC x3E,W
57B0:  MOVWF  03
57B2:  MOVFF  01,343
57B6:  MOVWF  x44
57B8:  MOVFF  342,42D
57BC:  MOVFF  341,42C
57C0:  MOVFF  340,42B
57C4:  MOVFF  33F,42A
57C8:  MOVLB  4
57CA:  CLRF   x2F
57CC:  MOVLW  20
57CE:  MOVWF  x2E
57D0:  MOVFF  03,431
57D4:  MOVFF  01,430
57D8:  MOVLB  0
57DA:  CALL   3A60
57DE:  MOVF   01,F
57E0:  BZ    57FE
....................          { 
....................             stream->Flags |= Write_Error; 
57E2:  MOVLW  19
57E4:  MOVLB  3
57E6:  ADDWF  x3D,W
57E8:  MOVWF  FE9
57EA:  MOVLW  00
57EC:  ADDWFC x3E,W
57EE:  MOVWF  FEA
57F0:  MOVF   FEF,W
57F2:  IORLW  40
57F4:  MOVWF  FEF
....................             return EOF; 
57F6:  MOVLW  FF
57F8:  MOVWF  01
57FA:  BRA    58BC
57FC:  MOVLB  0
....................          } 
....................       } 
57FE:  BRA    58AE
5800:  MOVLB  3
....................       else 
....................       { 
....................          // flush the buffer to the card 
....................          //  we need to make sure that the buffer gets flushed into the proper location, hence all this weird % math 
....................          if(mmcsd_write_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
5802:  MOVLW  04
5804:  ADDWF  x3D,W
5806:  MOVWF  FE9
5808:  MOVLW  00
580A:  ADDWFC x3E,W
580C:  MOVWF  FEA
580E:  MOVFF  FEF,33F
5812:  MOVFF  FEC,340
5816:  MOVFF  FEC,341
581A:  MOVFF  FEC,342
581E:  MOVLW  04
5820:  ADDWF  x3D,W
5822:  MOVWF  FE9
5824:  MOVLW  00
5826:  ADDWFC x3E,W
5828:  MOVWF  FEA
582A:  MOVFF  FEF,343
582E:  MOVFF  FEC,344
5832:  MOVFF  FEC,345
5836:  MOVFF  FEC,346
583A:  MOVF   x43,W
583C:  ANDLW  1F
583E:  MOVWF  00
5840:  CLRF   01
5842:  CLRF   02
5844:  CLRF   03
5846:  MOVF   00,W
5848:  SUBWF  x3F,F
584A:  MOVF   01,W
584C:  SUBWFB x40,F
584E:  MOVF   02,W
5850:  SUBWFB x41,F
5852:  MOVF   03,W
5854:  SUBWFB x42,F
5856:  MOVLW  1A
5858:  ADDWF  x3D,W
585A:  MOVWF  01
585C:  MOVLW  00
585E:  ADDWFC x3E,W
5860:  MOVWF  03
5862:  MOVFF  01,343
5866:  MOVWF  x44
5868:  MOVFF  342,42D
586C:  MOVFF  341,42C
5870:  MOVFF  340,42B
5874:  MOVFF  33F,42A
5878:  MOVLB  4
587A:  CLRF   x2F
587C:  MOVLW  20
587E:  MOVWF  x2E
5880:  MOVFF  03,431
5884:  MOVFF  01,430
5888:  MOVLB  0
588A:  CALL   3A60
588E:  MOVF   01,F
5890:  BZ    58AE
....................          { 
....................             stream->Flags |= Write_Error; 
5892:  MOVLW  19
5894:  MOVLB  3
5896:  ADDWF  x3D,W
5898:  MOVWF  FE9
589A:  MOVLW  00
589C:  ADDWFC x3E,W
589E:  MOVWF  FEA
58A0:  MOVF   FEF,W
58A2:  IORLW  40
58A4:  MOVWF  FEF
....................             return EOF; 
58A6:  MOVLW  FF
58A8:  MOVWF  01
58AA:  BRA    58BC
58AC:  MOVLB  0
....................          } 
....................       } 
....................       return(mmcsd_flush_buffer()); 
58AE:  CALL   2A82
58B2:  MOVF   01,W
58B4:  MOVLB  3
58B6:  BRA    58BC
....................    } 
....................    return 0; 
58B8:  MOVLW  00
58BA:  MOVWF  01
58BC:  MOVLB  0
58BE:  GOTO   5B48 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int remove(char* fname) 
.................... Summary: Removes a file from disk. 
.................... Param: The full path of the file to remove. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... Note: This function does not work for removing directories, use rm_dir instead. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int remove(char* fname) 
.................... { 
....................    if(rm_file(fname) == EOF) 
....................        return EOF; 
....................  
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int faterror(FILE* stream) 
.................... Summary: Checks for an error in a given stream. 
.................... Param: The stream to check for an error in. 
.................... Returns: A non-zero value of there is an error in the stream, 
....................           0 if there is no error in the stream 
.................... */ 
.................... signed int faterror(FILE* stream) 
.................... { 
....................    return stream->Flags & 0xF0; 
.................... } 
....................  
.................... /* 
.................... void clearerr(FILE* stream) 
.................... Summary: Clears off all error in a given stream. 
.................... Param: The stream to clear off the errors in. 
.................... Returns: Nothing. 
.................... */ 
.................... void clearerr(FILE* stream) 
.................... { 
....................    stream->Flags &= 0x0F; 
.................... } 
....................  
.................... /* 
.................... void rewind(FILE* stream) 
.................... Summary: Sets the stream to point back to the beginning of a file. 
.................... Param: The stream to rewind. 
.................... Returns: Nothing. 
.................... */ 
.................... void rewind(FILE* stream) 
.................... { 
....................    // set the stream back to the beginning 
....................    stream->Cur_Char = stream->Start_Addr; 
*
3C0E:  MOVLW  04
3C10:  MOVLB  3
3C12:  ADDWF  xE4,W
3C14:  MOVWF  01
3C16:  MOVLW  00
3C18:  ADDWFC xE5,W
3C1A:  MOVWF  03
3C1C:  MOVFF  01,3E6
3C20:  MOVWF  xE7
3C22:  MOVLW  14
3C24:  ADDWF  xE4,W
3C26:  MOVWF  FE9
3C28:  MOVLW  00
3C2A:  ADDWFC xE5,W
3C2C:  MOVWF  FEA
3C2E:  MOVFF  FEF,00
3C32:  MOVFF  FEC,01
3C36:  MOVFF  FEC,02
3C3A:  MOVFF  FEC,03
3C3E:  MOVFF  3E7,FEA
3C42:  MOVFF  3E6,FE9
3C46:  MOVFF  00,FEF
3C4A:  MOVFF  01,FEC
3C4E:  MOVFF  02,FEC
3C52:  MOVFF  03,FEC
....................    stream->Bytes_Until_EOF = stream->Size; 
3C56:  MOVLW  10
3C58:  ADDWF  xE4,W
3C5A:  MOVWF  FE9
3C5C:  MOVLW  00
3C5E:  ADDWFC xE5,W
3C60:  MOVWF  FEA
3C62:  MOVFF  FEF,00
3C66:  MOVFF  FEC,01
3C6A:  MOVFF  FEC,02
3C6E:  MOVFF  FEC,03
3C72:  MOVFF  3E5,FEA
3C76:  MOVFF  3E4,FE9
3C7A:  MOVFF  00,FEF
3C7E:  MOVFF  01,FEC
3C82:  MOVFF  02,FEC
3C86:  MOVFF  03,FEC
3C8A:  MOVLB  0
3C8C:  GOTO   464C (RETURN)
.................... } 
....................  
.................... /* 
.................... fatpos_t fattell(FILE* stream) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param: The stream to return the position of. 
.................... Returns: The position of where the stream is pointing to relative to the beginning of the stream, or 0 if there was a problem. 
.................... */ 
.................... fatpos_t fattell(FILE* stream) 
.................... { 
....................    fatpos_t retval; 
....................  
....................    if(fatgetpos(stream, &retval) != 0) 
....................       return 0; 
....................  
....................    return retval; 
.................... } 
....................  
.................... /// Non-Standard C Functions /// 
....................  
.................... /* 
.................... signed int rm_file(char fname[]) 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int rm_file(char fname[]) 
.................... { 
....................    int 
....................       order, 
....................       ulinked_entry = 0xE5; // 0xE5 is put into the file's entry to indicate unlinking 
....................  
....................    int32 i; 
....................  
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(fname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // we need to un-link the file's clusters from the FAT if there are clusters allocated 
....................    if(stream.Start_Addr > Root_Dir) 
....................    { 
....................       if(dealloc_clusters(addr_to_cluster(stream.Start_Addr)) == EOF) 
....................          return EOF; 
....................    } 
....................    // get rid of the first entry 
....................    i = stream.Entry_Addr; 
....................    if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................       return EOF; 
....................     
....................    // check to see if there is a long file name 
....................    get_prev_entry(&i); 
....................    if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................       return EOF; 
....................  
....................    // get rid of all of the long file name entries if they're there 
....................    while(order == 0x0F) 
....................    { 
....................       if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................          return EOF; 
....................  
....................       if(get_prev_entry(&i) == EOF) 
....................          return EOF; 
....................  
....................       if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................          return EOF; 
....................    } 
....................     
....................    if(fatclose(&stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int rm_dir(char dname[]) 
.................... Summary: Deletes a directory. 
.................... Param: The full path of the directory to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... Note: This function cannot remove all of the files 
....................        and subdirectories of the directory. Manually remove all subdirectories 
....................        and files before calling this command. 
.................... */ 
.................... signed int rm_dir(char dname[]) 
.................... { 
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(dname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // jump over the . and .. entries in the directory 
....................    stream.Entry_Addr = stream.Start_Addr + 64; 
....................     
....................    // check to make sure that there isn't stuff in this directory 
....................    if(get_next_file(&stream) != EOF) 
....................       return EOF; 
....................  
....................    // since removing files is a lot like removing directories, we 
....................    //  can just call rm_file 
....................    if(rm_file(dname) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int mk_file(char fname[]) 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int mk_file(char fname[]) 
.................... { 
....................    char 
....................       filename[MAX_FILE_NAME_LENGTH],   // the file name we're trying to make 
....................       mode[] = "r";                     // reading is the safest mode to work in 
....................  
....................    int 
....................       buf,               // buffer to hold values 
....................       entire_entry[0x20],// entire first entry 
....................       filename_pos = 0,  // the current parse position of the file name we're trying to create 
....................       fname_pos;         // the current parse position of the input the the function 
....................  
....................    int32 i;      // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(fname, mode, &stream) == GOODEC) 
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
....................  
....................    // check to see if the file is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
....................       return EOF; 
....................  
....................    // make a file name 
....................    fname_pos = strrchr(fname, '/') - fname + 1; 
....................    while((fname[fname_pos] != '\0') && (filename_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
....................       filename[filename_pos] = fname[fname_pos]; 
....................       fname_pos += 1; 
....................       filename_pos += 1; 
....................    } 
....................    filename[filename_pos] = '\0'; 
....................  
....................    // write the name 
....................    if(set_file_name(stream.Start_Addr, &i, filename) == EOF) 
....................       return EOF; 
....................  
....................    // throw in some values in the file's first entry 
....................    for(buf = 0; buf < 0x20; buf += 1) 
....................       entire_entry[buf] = 0; 
....................  
....................    // this is a file 
....................    entire_entry[0x0B] = 0x20; 
....................  
....................    // read what set_file_name gave us for the short name 
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // write the entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int mk_dir(char dname[]) 
.................... Summary: Creates a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... */ 
.................... signed int mk_dir(char dname[]) 
.................... { 
....................    char 
....................       dirname[MAX_FILE_NAME_LENGTH],    // the directory name we're trying to make 
....................       entire_entry[0x20],               // used to hold the link entries (. and ..) to the directory and its parent 
....................       mode[] = "r";                     // reading is the safest mode to work in 
....................  
....................    int 
....................       dirname_pos = 0,   // the current parse position of the directory name we're trying to create 
....................       dname_pos,         // the current parse position of the input the the function 
....................       j;                 // counter for loops 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(dname, mode, &stream) == GOODEC) 
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
....................  
....................    // check to see if the directory is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
....................       return EOF; 
....................  
....................    // make the directory name 
....................    dname_pos = strrchr(dname, '/') - dname; 
....................    dname[dname_pos] = '\0'; 
....................    dname_pos = strrchr(dname, '/') - dname + 1; 
....................    while((dname[dname_pos] != '\0') && (dirname_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
....................       dirname[dirname_pos] = dname[dname_pos]; 
....................       dname_pos += 1; 
....................       dirname_pos += 1; 
....................    } 
....................    dirname[dirname_pos] = '\0'; 
....................    dname[dname_pos] = '/'; 
....................  
....................    // write the file's name 
....................    if(set_file_name(stream.Start_Addr, &i, dirname) == EOF) 
....................       return EOF; 
....................  
....................    // find and allocate an open cluster 
....................    if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
....................       return EOF; 
....................    if(clear_cluster(Next_Free_Clust) == EOF) 
....................       return EOF; 
.................... #ifdef FAT32 
....................    if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
....................       return EOF; 
.................... #else // FAT16 
....................    if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // throw in some values in the file's first entry 
....................    for(j = 0; j < 0x20; j += 1) 
....................       entire_entry[j] = 0; 
....................  
....................    // this is a directory 
....................    entire_entry[0x0B] = 0x10; 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // write the file's first entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // make the two links that point to the directory and the directory's parent 
....................    i = cluster_to_addr(Next_Free_Clust); 
....................  
....................    // put in the first link that points to the directory itself 
....................    for(j = 0; j < 0x20; j += 1) 
....................    { 
....................       if(j < 0x01) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else if(j == 0x0B) 
....................          entire_entry[j] = 0x10; 
....................       else 
....................          entire_entry[j] = 0x00; 
....................    } 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    for(j = 0; j < 0x0C; j += 1) 
....................    { 
....................       if(j < 0x02) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else 
....................          entire_entry[j] = 0x10; 
....................    } 
....................  
....................    if(stream.Parent_Start_Addr == Root_Dir) 
....................    { 
....................       entire_entry[0x14] = 0x00; 
....................       entire_entry[0x15] = 0x00; 
....................       entire_entry[0x1A] = 0x00; 
....................       entire_entry[0x1B] = 0x00; 
....................    } 
....................    else 
....................    { 
....................       entire_entry[0x1A] = make8(addr_to_cluster(stream.Parent_Start_Addr), 0); 
....................       entire_entry[0x1B] = make8(addr_to_cluster(stream.Parent_Start_Addr), 1); 
.................... #ifdef FAT32 
....................       entire_entry[0x14] = make8(addr_to_cluster(stream.Parent_Start_Addr), 2); 
....................       entire_entry[0x15] = make8(addr_to_cluster(stream.Parent_Start_Addr), 3); 
.................... #endif // #ifdef FAT32 
....................    } 
....................  
....................    if(mmcsd_write_data(i + 0x20, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Functions' Utility Functions /// 
.................... /// NOTE: A library user should not need to use any of the functions in this section /// 
....................  
.................... /* 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... Summary: This will set the stream to point to the specified file. 
.................... Param fname: The file name to search for. 
.................... Param attrib: The file attributes to search for. 0x10 is a directory, 0x20 is a file. 
.................... Param stream: The stream to set. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: The stream has to be pointing to the parent directory's start address when coming in to this function. 
.................... */ 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
*
4A6E:  MOVLB  3
4A70:  CLRF   xB1
.................... { 
....................    int 
....................       cur_attrib,    // the attribute of the most recently read entry 
....................       cur_state,     // the state of the most recently read entry 
....................       ec = 0;        // error checking byte 
....................  
....................    int32 i;   // pointer to memory 
.................... #ifndef FAST_FAT 
....................    char name_buffer[MAX_FILE_NAME_LENGTH];   // buffer to hold in the most recently read in name 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set the memory pointer to the parent start address 
....................    i = stream->Start_Addr; 
4A72:  MOVLW  14
4A74:  ADDWF  xAD,W
4A76:  MOVWF  FE9
4A78:  MOVLW  00
4A7A:  ADDWFC xAE,W
4A7C:  MOVWF  FEA
4A7E:  MOVFF  FEF,3B2
4A82:  MOVFF  FEC,3B3
4A86:  MOVFF  FEC,3B4
4A8A:  MOVFF  FEC,3B5
....................  
....................    // search for the name of our target file inside of the parent directory 
....................    do 
....................    { 
....................       // read the state and the attribute of the current entry 
....................       ec += mmcsd_read_data(i, 1, &cur_state); 
4A8E:  MOVFF  3B5,419
4A92:  MOVFF  3B4,418
4A96:  MOVFF  3B3,417
4A9A:  MOVFF  3B2,416
4A9E:  MOVLB  4
4AA0:  CLRF   x1B
4AA2:  MOVLW  01
4AA4:  MOVWF  x1A
4AA6:  MOVLW  03
4AA8:  MOVWF  x1D
4AAA:  MOVLW  B0
4AAC:  MOVWF  x1C
4AAE:  MOVLB  0
4AB0:  CALL   2BB8
4AB4:  MOVF   01,W
4AB6:  MOVLB  3
4AB8:  ADDWF  xB1,F
....................       ec += mmcsd_read_data(i + 0x0B, 1, &cur_attrib); 
4ABA:  MOVLW  0B
4ABC:  ADDWF  xB2,W
4ABE:  MOVWF  xD6
4AC0:  MOVLW  00
4AC2:  ADDWFC xB3,W
4AC4:  MOVWF  xD7
4AC6:  MOVLW  00
4AC8:  ADDWFC xB4,W
4ACA:  MOVWF  xD8
4ACC:  MOVLW  00
4ACE:  ADDWFC xB5,W
4AD0:  MOVWF  xD9
4AD2:  MOVFF  FE8,419
4AD6:  MOVFF  3D8,418
4ADA:  MOVFF  3D7,417
4ADE:  MOVFF  3D6,416
4AE2:  MOVLB  4
4AE4:  CLRF   x1B
4AE6:  MOVLW  01
4AE8:  MOVWF  x1A
4AEA:  MOVLW  03
4AEC:  MOVWF  x1D
4AEE:  MOVLW  AF
4AF0:  MOVWF  x1C
4AF2:  MOVLB  0
4AF4:  CALL   2BB8
4AF8:  MOVF   01,W
4AFA:  MOVLB  3
4AFC:  ADDWF  xB1,F
....................       if(ec != GOODEC) 
4AFE:  MOVF   xB1,F
4B00:  BZ    4B1A
....................       { 
....................          stream->Flags |= Read_Error; 
4B02:  MOVLW  19
4B04:  ADDWF  xAD,W
4B06:  MOVWF  FE9
4B08:  MOVLW  00
4B0A:  ADDWFC xAE,W
4B0C:  MOVWF  FEA
4B0E:  MOVF   FEF,W
4B10:  IORLW  20
4B12:  MOVWF  FEF
....................          return EOF; 
4B14:  MOVLW  FF
4B16:  MOVWF  01
4B18:  BRA    514C
....................       } 
....................  
....................        // check to make sure that this entry exists and the entry is the type we're looking for 
....................       if((cur_state != 0xE5) && (cur_attrib == attrib)) 
4B1A:  MOVF   xB0,W
4B1C:  SUBLW  E5
4B1E:  BTFSC  FD8.2
4B20:  BRA    510E
4B22:  MOVF   xAC,W
4B24:  SUBWF  xAF,W
4B26:  BTFSS  FD8.2
4B28:  BRA    510E
....................       { 
.................... #ifndef FAST_FAT 
....................          // get the long file name of the current entry 
....................          if(get_file_name(i, name_buffer) == EOF) 
4B2A:  MOVFF  3B5,3D9
4B2E:  MOVFF  3B4,3D8
4B32:  MOVFF  3B3,3D7
4B36:  MOVFF  3B2,3D6
4B3A:  MOVLW  03
4B3C:  MOVWF  xDB
4B3E:  MOVLW  B6
4B40:  MOVWF  xDA
4B42:  MOVLB  0
4B44:  GOTO   378A
4B48:  MOVF   01,W
4B4A:  SUBLW  FF
4B4C:  BNZ   4B58
....................             return EOF; 
4B4E:  MOVLW  FF
4B50:  MOVWF  01
4B52:  MOVLB  3
4B54:  BRA    514C
4B56:  MOVLB  0
....................  
....................          // if the target entry and the long file name are equal, strcmp will return a zero 
....................          if(strcmp(fname, name_buffer) == 0) 
4B58:  MOVFF  3AB,3D7
4B5C:  MOVFF  3AA,3D6
4B60:  MOVLW  03
4B62:  MOVLB  3
4B64:  MOVWF  xD9
4B66:  MOVLW  B6
4B68:  MOVWF  xD8
4B6A:  MOVLB  0
4B6C:  GOTO   3910
4B70:  MOVF   01,F
4B72:  BTFSS  FD8.2
4B74:  BRA    5110
.................... #endif // #ifndef FAST_FAT 
....................          { 
....................             // we have found our target entry, set the current entry and break out of this function 
....................             // set stream's parent address 
....................             stream->Parent_Start_Addr = stream->Start_Addr; 
4B76:  MOVLW  0C
4B78:  MOVLB  3
4B7A:  ADDWF  xAD,W
4B7C:  MOVWF  01
4B7E:  MOVLW  00
4B80:  ADDWFC xAE,W
4B82:  MOVWF  03
4B84:  MOVFF  01,3D6
4B88:  MOVWF  xD7
4B8A:  MOVLW  14
4B8C:  ADDWF  xAD,W
4B8E:  MOVWF  FE9
4B90:  MOVLW  00
4B92:  ADDWFC xAE,W
4B94:  MOVWF  FEA
4B96:  MOVFF  FEF,00
4B9A:  MOVFF  FEC,01
4B9E:  MOVFF  FEC,02
4BA2:  MOVFF  FEC,03
4BA6:  MOVFF  3D7,FEA
4BAA:  MOVFF  3D6,FE9
4BAE:  MOVFF  00,FEF
4BB2:  MOVFF  01,FEC
4BB6:  MOVFF  02,FEC
4BBA:  MOVFF  03,FEC
....................  
....................             ec += mmcsd_read_data(i + 0x1C, 4, &(stream->Size)); 
4BBE:  MOVLW  1C
4BC0:  ADDWF  xB2,W
4BC2:  MOVWF  xD6
4BC4:  MOVLW  00
4BC6:  ADDWFC xB3,W
4BC8:  MOVWF  xD7
4BCA:  MOVLW  00
4BCC:  ADDWFC xB4,W
4BCE:  MOVWF  xD8
4BD0:  MOVLW  00
4BD2:  ADDWFC xB5,W
4BD4:  MOVWF  xD9
4BD6:  MOVLW  10
4BD8:  ADDWF  xAD,W
4BDA:  MOVWF  01
4BDC:  MOVLW  00
4BDE:  ADDWFC xAE,W
4BE0:  MOVWF  03
4BE2:  MOVFF  01,3DA
4BE6:  MOVWF  xDB
4BE8:  MOVFF  3D9,419
4BEC:  MOVFF  3D8,418
4BF0:  MOVFF  3D7,417
4BF4:  MOVFF  3D6,416
4BF8:  MOVLB  4
4BFA:  CLRF   x1B
4BFC:  MOVLW  04
4BFE:  MOVWF  x1A
4C00:  MOVFF  03,41D
4C04:  MOVFF  01,41C
4C08:  MOVLB  0
4C0A:  CALL   2BB8
4C0E:  MOVF   01,W
4C10:  MOVLB  3
4C12:  ADDWF  xB1,F
....................  
....................             // stream->Start_Addr is going to temporarily have a cluster number 
....................             ec += mmcsd_read_data(i + 0x14, 2, (int16*)&stream->Start_Addr + 1); 
4C14:  MOVLW  14
4C16:  ADDWF  xB2,W
4C18:  MOVWF  xD6
4C1A:  MOVLW  00
4C1C:  ADDWFC xB3,W
4C1E:  MOVWF  xD7
4C20:  MOVLW  00
4C22:  ADDWFC xB4,W
4C24:  MOVWF  xD8
4C26:  MOVLW  00
4C28:  ADDWFC xB5,W
4C2A:  MOVWF  xD9
4C2C:  MOVLW  14
4C2E:  ADDWF  xAD,W
4C30:  MOVWF  01
4C32:  MOVLW  00
4C34:  ADDWFC xAE,W
4C36:  MOVWF  03
4C38:  MOVFF  01,3DA
4C3C:  MOVWF  xDB
4C3E:  MOVLW  02
4C40:  ADDWF  xDA,F
4C42:  MOVLW  00
4C44:  ADDWFC xDB,F
4C46:  MOVFF  3D9,419
4C4A:  MOVFF  3D8,418
4C4E:  MOVFF  3D7,417
4C52:  MOVFF  3D6,416
4C56:  MOVLB  4
4C58:  CLRF   x1B
4C5A:  MOVLW  02
4C5C:  MOVWF  x1A
4C5E:  MOVFF  3DB,41D
4C62:  MOVFF  3DA,41C
4C66:  MOVLB  0
4C68:  CALL   2BB8
4C6C:  MOVF   01,W
4C6E:  MOVLB  3
4C70:  ADDWF  xB1,F
....................             ec += mmcsd_read_data(i + 0x1A, 2, &stream->Start_Addr); 
4C72:  MOVLW  1A
4C74:  ADDWF  xB2,W
4C76:  MOVWF  xD6
4C78:  MOVLW  00
4C7A:  ADDWFC xB3,W
4C7C:  MOVWF  xD7
4C7E:  MOVLW  00
4C80:  ADDWFC xB4,W
4C82:  MOVWF  xD8
4C84:  MOVLW  00
4C86:  ADDWFC xB5,W
4C88:  MOVWF  xD9
4C8A:  MOVLW  14
4C8C:  ADDWF  xAD,W
4C8E:  MOVWF  01
4C90:  MOVLW  00
4C92:  ADDWFC xAE,W
4C94:  MOVWF  03
4C96:  MOVFF  01,3DA
4C9A:  MOVWF  xDB
4C9C:  MOVFF  3D9,419
4CA0:  MOVFF  3D8,418
4CA4:  MOVFF  3D7,417
4CA8:  MOVFF  3D6,416
4CAC:  MOVLB  4
4CAE:  CLRF   x1B
4CB0:  MOVLW  02
4CB2:  MOVWF  x1A
4CB4:  MOVFF  03,41D
4CB8:  MOVFF  01,41C
4CBC:  MOVLB  0
4CBE:  CALL   2BB8
4CC2:  MOVF   01,W
4CC4:  MOVLB  3
4CC6:  ADDWF  xB1,F
....................  
....................             if(ec != GOODEC) 
4CC8:  MOVF   xB1,F
4CCA:  BZ    4CE4
....................             { 
....................                stream->Flags |= Read_Error; 
4CCC:  MOVLW  19
4CCE:  ADDWF  xAD,W
4CD0:  MOVWF  FE9
4CD2:  MOVLW  00
4CD4:  ADDWFC xAE,W
4CD6:  MOVWF  FEA
4CD8:  MOVF   FEF,W
4CDA:  IORLW  20
4CDC:  MOVWF  FEF
....................                return EOF; 
4CDE:  MOVLW  FF
4CE0:  MOVWF  01
4CE2:  BRA    514C
....................             } 
....................  
....................             // convert stream->Start_Addr to an address 
....................             stream->Start_Addr = cluster_to_addr(stream->Start_Addr); 
4CE4:  MOVLW  14
4CE6:  ADDWF  xAD,W
4CE8:  MOVWF  01
4CEA:  MOVLW  00
4CEC:  ADDWFC xAE,W
4CEE:  MOVWF  03
4CF0:  MOVFF  01,3D6
4CF4:  MOVWF  xD7
4CF6:  MOVLW  14
4CF8:  ADDWF  xAD,W
4CFA:  MOVWF  FE9
4CFC:  MOVLW  00
4CFE:  ADDWFC xAE,W
4D00:  MOVWF  FEA
4D02:  MOVFF  FEF,426
4D06:  MOVFF  FEC,427
4D0A:  MOVFF  FEC,428
4D0E:  MOVFF  FEC,429
4D12:  MOVLB  0
4D14:  CALL   3480
4D18:  MOVFF  3D7,FEA
4D1C:  MOVFF  3D6,FE9
4D20:  MOVFF  00,FEF
4D24:  MOVFF  01,FEC
4D28:  MOVFF  02,FEC
4D2C:  MOVFF  03,FEC
....................  
....................             stream->Entry_Addr = i; 
4D30:  MOVLW  08
4D32:  MOVLB  3
4D34:  ADDWF  xAD,W
4D36:  MOVWF  FE9
4D38:  MOVLW  00
4D3A:  ADDWFC xAE,W
4D3C:  MOVWF  FEA
4D3E:  MOVFF  3B2,FEF
4D42:  MOVFF  3B3,FEC
4D46:  MOVFF  3B4,FEC
4D4A:  MOVFF  3B5,FEC
....................             stream->Bytes_Until_EOF = stream->Size; 
4D4E:  MOVLW  10
4D50:  ADDWF  xAD,W
4D52:  MOVWF  FE9
4D54:  MOVLW  00
4D56:  ADDWFC xAE,W
4D58:  MOVWF  FEA
4D5A:  MOVFF  FEF,00
4D5E:  MOVFF  FEC,01
4D62:  MOVFF  FEC,02
4D66:  MOVFF  FEC,03
4D6A:  MOVFF  3AE,FEA
4D6E:  MOVFF  3AD,FE9
4D72:  MOVFF  00,FEF
4D76:  MOVFF  01,FEC
4D7A:  MOVFF  02,FEC
4D7E:  MOVFF  03,FEC
....................  
....................             // set up some permission-specific parameters if we're at a file 
....................             if(attrib == 0x20) 
4D82:  MOVF   xAC,W
4D84:  SUBLW  20
4D86:  BTFSS  FD8.2
4D88:  BRA    50F8
....................             { 
....................                stream->File_Type = Data_File; 
4D8A:  MOVLW  18
4D8C:  ADDWF  xAD,W
4D8E:  MOVWF  FE9
4D90:  MOVLW  00
4D92:  ADDWFC xAE,W
4D94:  MOVWF  FEA
4D96:  CLRF   FEF
....................                if(stream->Flags & Write) 
4D98:  MOVLW  19
4D9A:  ADDWF  xAD,W
4D9C:  MOVWF  FE9
4D9E:  MOVLW  00
4DA0:  ADDWFC xAE,W
4DA2:  MOVWF  FEA
4DA4:  BTFSS  FEF.1
4DA6:  BRA    4EA0
....................                { 
....................                   // delete all previous data in the file 
....................                   stream->Bytes_Until_EOF = stream->Size = 0; 
4DA8:  MOVLW  10
4DAA:  ADDWF  xAD,W
4DAC:  MOVWF  FE9
4DAE:  MOVLW  00
4DB0:  ADDWFC xAE,W
4DB2:  MOVWF  FEA
4DB4:  MOVF   FEE,F
4DB6:  MOVF   FEE,F
4DB8:  CLRF   FEC
4DBA:  MOVF   FED,F
4DBC:  CLRF   FEF
4DBE:  MOVF   FED,F
4DC0:  CLRF   FEF
4DC2:  MOVF   FED,F
4DC4:  CLRF   FEF
4DC6:  MOVLW  00
4DC8:  MOVFF  3AE,FEA
4DCC:  MOVFF  3AD,FE9
4DD0:  MOVFF  00,FEF
4DD4:  MOVFF  3AD,FEC
4DD8:  MOVFF  02,FEC
4DDC:  MOVFF  3AE,FEC
....................  
....................                   // if there is already space allocated, get rid of it 
....................                   if(stream->Start_Addr >= Data_Start) 
4DE0:  MOVLW  14
4DE2:  ADDWF  xAD,W
4DE4:  MOVWF  FE9
4DE6:  MOVLW  00
4DE8:  ADDWFC xAE,W
4DEA:  MOVWF  FEA
4DEC:  MOVFF  FEF,3D6
4DF0:  MOVFF  FEC,3D7
4DF4:  MOVFF  FEC,3D8
4DF8:  MOVFF  FEC,3D9
4DFC:  MOVLB  2
4DFE:  MOVF   x15,W
4E00:  MOVLB  3
4E02:  SUBWF  xD9,W
4E04:  BNC   4E7E
4E06:  BNZ   4E2A
4E08:  MOVLB  2
4E0A:  MOVF   x14,W
4E0C:  MOVLB  3
4E0E:  SUBWF  xD8,W
4E10:  BNC   4E7E
4E12:  BNZ   4E2A
4E14:  MOVLB  2
4E16:  MOVF   x13,W
4E18:  MOVLB  3
4E1A:  SUBWF  xD7,W
4E1C:  BNC   4E7E
4E1E:  BNZ   4E2A
4E20:  MOVLB  2
4E22:  MOVF   x12,W
4E24:  MOVLB  3
4E26:  SUBWF  xD6,W
4E28:  BNC   4E7E
....................                      if(dealloc_clusters(addr_to_cluster(stream->Start_Addr)) == EOF) 
4E2A:  MOVLW  14
4E2C:  ADDWF  xAD,W
4E2E:  MOVWF  FE9
4E30:  MOVLW  00
4E32:  ADDWFC xAE,W
4E34:  MOVWF  FEA
4E36:  MOVFF  FEF,3F4
4E3A:  MOVFF  FEC,3F5
4E3E:  MOVFF  FEC,3F6
4E42:  MOVFF  FEC,3F7
4E46:  MOVLB  0
4E48:  CALL   3324
4E4C:  MOVFF  03,3D9
4E50:  MOVFF  02,3D8
4E54:  MOVFF  01,3D7
4E58:  MOVFF  00,3D6
4E5C:  MOVFF  03,3DD
4E60:  MOVFF  02,3DC
4E64:  MOVFF  01,3DB
4E68:  MOVFF  00,3DA
4E6C:  GOTO   3B62
4E70:  MOVF   01,W
4E72:  SUBLW  FF
4E74:  BNZ   4E80
....................                         return EOF; 
4E76:  MOVLW  FF
4E78:  MOVWF  01
4E7A:  MOVLB  3
4E7C:  BRA    514C
4E7E:  MOVLB  0
....................                   stream->Cur_Char = 0; 
4E80:  MOVLW  04
4E82:  MOVLB  3
4E84:  ADDWF  xAD,W
4E86:  MOVWF  FE9
4E88:  MOVLW  00
4E8A:  ADDWFC xAE,W
4E8C:  MOVWF  FEA
4E8E:  MOVF   FEE,F
4E90:  MOVF   FEE,F
4E92:  CLRF   FEC
4E94:  MOVF   FED,F
4E96:  CLRF   FEF
4E98:  MOVF   FED,F
4E9A:  CLRF   FEF
4E9C:  MOVF   FED,F
4E9E:  CLRF   FEF
....................                } 
....................  
....................                if((stream->Flags & Append) && (stream->Size != 0)) 
4EA0:  MOVLW  19
4EA2:  ADDWF  xAD,W
4EA4:  MOVWF  FE9
4EA6:  MOVLW  00
4EA8:  ADDWFC xAE,W
4EAA:  MOVWF  FEA
4EAC:  BTFSS  FEF.2
4EAE:  BRA    503A
4EB0:  MOVLW  10
4EB2:  ADDWF  xAD,W
4EB4:  MOVWF  FE9
4EB6:  MOVLW  00
4EB8:  ADDWFC xAE,W
4EBA:  MOVWF  FEA
4EBC:  MOVFF  FEF,3D6
4EC0:  MOVFF  FEC,3D7
4EC4:  MOVFF  FEC,3D8
4EC8:  MOVFF  FEC,3D9
4ECC:  MOVF   xD6,F
4ECE:  BNZ   4EDE
4ED0:  MOVF   xD7,F
4ED2:  BNZ   4EDE
4ED4:  MOVF   xD8,F
4ED6:  BNZ   4EDE
4ED8:  MOVF   xD9,F
4EDA:  BTFSC  FD8.2
4EDC:  BRA    503A
....................                { 
....................                   // set the position to the end of the file and fill the buffer with the contents of the end of the file 
....................                   ec = fatsetpos(stream, &(stream->Size)); 
4EDE:  MOVLW  10
4EE0:  ADDWF  xAD,W
4EE2:  MOVWF  01
4EE4:  MOVLW  00
4EE6:  ADDWFC xAE,W
4EE8:  MOVWF  03
4EEA:  MOVFF  01,3D6
4EEE:  MOVWF  xD7
4EF0:  MOVFF  3AE,3D9
4EF4:  MOVFF  3AD,3D8
4EF8:  MOVWF  xDB
4EFA:  MOVFF  01,3DA
4EFE:  MOVLB  0
4F00:  GOTO   4610
4F04:  MOVFF  01,3B1
....................                   if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
4F08:  MOVLW  04
4F0A:  MOVLB  3
4F0C:  ADDWF  xAD,W
4F0E:  MOVWF  FE9
4F10:  MOVLW  00
4F12:  ADDWFC xAE,W
4F14:  MOVWF  FEA
4F16:  MOVFF  FEF,3D6
4F1A:  MOVFF  FEC,3D7
4F1E:  MOVFF  FEC,3D8
4F22:  MOVFF  FEC,3D9
4F26:  MOVLW  1F
4F28:  ANDWF  xD6,F
4F2A:  CLRF   xD7
4F2C:  CLRF   xD8
4F2E:  CLRF   xD9
4F30:  MOVF   xD6,F
4F32:  BNZ   4FA8
4F34:  MOVF   xD7,F
4F36:  BNZ   4FA8
4F38:  MOVF   xD8,F
4F3A:  BNZ   4FA8
4F3C:  MOVF   xD9,F
4F3E:  BNZ   4FA8
....................                      ec += mmcsd_read_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf); 
4F40:  MOVLW  04
4F42:  ADDWF  xAD,W
4F44:  MOVWF  FE9
4F46:  MOVLW  00
4F48:  ADDWFC xAE,W
4F4A:  MOVWF  FEA
4F4C:  MOVFF  FEF,3D6
4F50:  MOVFF  FEC,3D7
4F54:  MOVFF  FEC,3D8
4F58:  MOVFF  FEC,3D9
4F5C:  MOVLW  20
4F5E:  SUBWF  xD6,F
4F60:  MOVLW  00
4F62:  SUBWFB xD7,F
4F64:  SUBWFB xD8,F
4F66:  SUBWFB xD9,F
4F68:  MOVLW  1A
4F6A:  ADDWF  xAD,W
4F6C:  MOVWF  01
4F6E:  MOVLW  00
4F70:  ADDWFC xAE,W
4F72:  MOVWF  03
4F74:  MOVFF  01,3DA
4F78:  MOVWF  xDB
4F7A:  MOVFF  3D9,419
4F7E:  MOVFF  3D8,418
4F82:  MOVFF  3D7,417
4F86:  MOVFF  3D6,416
4F8A:  MOVLB  4
4F8C:  CLRF   x1B
4F8E:  MOVLW  20
4F90:  MOVWF  x1A
4F92:  MOVFF  03,41D
4F96:  MOVFF  01,41C
4F9A:  MOVLB  0
4F9C:  CALL   2BB8
4FA0:  MOVF   01,W
4FA2:  MOVLB  3
4FA4:  ADDWF  xB1,F
4FA6:  BRA    503A
....................                   else 
....................                      ec += mmcsd_read_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf); 
4FA8:  MOVLW  04
4FAA:  ADDWF  xAD,W
4FAC:  MOVWF  FE9
4FAE:  MOVLW  00
4FB0:  ADDWFC xAE,W
4FB2:  MOVWF  FEA
4FB4:  MOVFF  FEF,3D6
4FB8:  MOVFF  FEC,3D7
4FBC:  MOVFF  FEC,3D8
4FC0:  MOVFF  FEC,3D9
4FC4:  MOVLW  04
4FC6:  ADDWF  xAD,W
4FC8:  MOVWF  FE9
4FCA:  MOVLW  00
4FCC:  ADDWFC xAE,W
4FCE:  MOVWF  FEA
4FD0:  MOVFF  FEF,3DA
4FD4:  MOVFF  FEC,3DB
4FD8:  MOVFF  FEC,3DC
4FDC:  MOVFF  FEC,3DD
4FE0:  MOVF   xDA,W
4FE2:  ANDLW  1F
4FE4:  MOVWF  00
4FE6:  CLRF   01
4FE8:  CLRF   02
4FEA:  CLRF   03
4FEC:  MOVF   00,W
4FEE:  SUBWF  xD6,F
4FF0:  MOVF   01,W
4FF2:  SUBWFB xD7,F
4FF4:  MOVF   02,W
4FF6:  SUBWFB xD8,F
4FF8:  MOVF   03,W
4FFA:  SUBWFB xD9,F
4FFC:  MOVLW  1A
4FFE:  ADDWF  xAD,W
5000:  MOVWF  01
5002:  MOVLW  00
5004:  ADDWFC xAE,W
5006:  MOVWF  03
5008:  MOVFF  01,3DA
500C:  MOVWF  xDB
500E:  MOVFF  3D9,419
5012:  MOVFF  3D8,418
5016:  MOVFF  3D7,417
501A:  MOVFF  3D6,416
501E:  MOVLB  4
5020:  CLRF   x1B
5022:  MOVLW  20
5024:  MOVWF  x1A
5026:  MOVFF  03,41D
502A:  MOVFF  01,41C
502E:  MOVLB  0
5030:  CALL   2BB8
5034:  MOVF   01,W
5036:  MOVLB  3
5038:  ADDWF  xB1,F
....................                } 
.................... #ifndef FAST_FAT 
....................                if(stream->Flags & Read) 
503A:  MOVLW  19
503C:  ADDWF  xAD,W
503E:  MOVWF  FE9
5040:  MOVLW  00
5042:  ADDWFC xAE,W
5044:  MOVWF  FEA
5046:  BTFSS  FEF.0
5048:  BRA    50DA
....................                { 
....................                   stream->Cur_Char = stream->Start_Addr; 
504A:  MOVLW  04
504C:  ADDWF  xAD,W
504E:  MOVWF  01
5050:  MOVLW  00
5052:  ADDWFC xAE,W
5054:  MOVWF  03
5056:  MOVFF  01,3D6
505A:  MOVWF  xD7
505C:  MOVLW  14
505E:  ADDWF  xAD,W
5060:  MOVWF  FE9
5062:  MOVLW  00
5064:  ADDWFC xAE,W
5066:  MOVWF  FEA
5068:  MOVFF  FEF,00
506C:  MOVFF  FEC,01
5070:  MOVFF  FEC,02
5074:  MOVFF  FEC,03
5078:  MOVFF  3D7,FEA
507C:  MOVFF  3D6,FE9
5080:  MOVFF  00,FEF
5084:  MOVFF  01,FEC
5088:  MOVFF  02,FEC
508C:  MOVFF  03,FEC
....................  
....................                   // fill up the read buffer for reading 
....................                   ec = mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf); 
5090:  MOVLW  04
5092:  ADDWF  xAD,W
5094:  MOVWF  FE9
5096:  MOVLW  00
5098:  ADDWFC xAE,W
509A:  MOVWF  FEA
509C:  MOVFF  FEF,416
50A0:  MOVFF  FEC,417
50A4:  MOVFF  FEC,418
50A8:  MOVFF  FEC,419
50AC:  MOVLW  1A
50AE:  ADDWF  xAD,W
50B0:  MOVWF  01
50B2:  MOVLW  00
50B4:  ADDWFC xAE,W
50B6:  MOVWF  03
50B8:  MOVFF  01,3DA
50BC:  MOVWF  xDB
50BE:  MOVLB  4
50C0:  CLRF   x1B
50C2:  MOVLW  20
50C4:  MOVWF  x1A
50C6:  MOVFF  03,41D
50CA:  MOVFF  01,41C
50CE:  MOVLB  0
50D0:  CALL   2BB8
50D4:  MOVFF  01,3B1
50D8:  MOVLB  3
....................                } 
.................... #endif // #ifndef FAST_FAT 
....................                if(ec != GOODEC) 
50DA:  MOVF   xB1,F
50DC:  BZ    50F6
....................                { 
....................                   stream->Flags |= Read_Error; 
50DE:  MOVLW  19
50E0:  ADDWF  xAD,W
50E2:  MOVWF  FE9
50E4:  MOVLW  00
50E6:  ADDWFC xAE,W
50E8:  MOVWF  FEA
50EA:  MOVF   FEF,W
50EC:  IORLW  20
50EE:  MOVWF  FEF
....................                   return EOF; 
50F0:  MOVLW  FF
50F2:  MOVWF  01
50F4:  BRA    514C
....................                }                
....................             } 
50F6:  BRA    5108
....................             else 
....................                stream->File_Type = Directory; 
50F8:  MOVLW  18
50FA:  ADDWF  xAD,W
50FC:  MOVWF  FE9
50FE:  MOVLW  00
5100:  ADDWFC xAE,W
5102:  MOVWF  FEA
5104:  MOVLW  01
5106:  MOVWF  FEF
....................             return GOODEC; 
5108:  MOVLW  00
510A:  MOVWF  01
510C:  BRA    514C
510E:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // check to make sure that the next iteration will give us a contiguous cluster 
....................       if(get_next_entry(&i) == EOF) 
5110:  MOVLW  03
5112:  MOVLB  3
5114:  MOVWF  xD7
5116:  MOVLW  B2
5118:  MOVWF  xD6
511A:  MOVLB  0
511C:  BRA    4A0A
511E:  MOVF   01,W
5120:  SUBLW  FF
5122:  BNZ   512E
....................          return EOF; 
5124:  MOVLW  FF
5126:  MOVWF  01
5128:  MOVLB  3
512A:  BRA    514C
512C:  MOVLB  0
....................  
....................    } while(cur_state != 0x00); 
512E:  MOVLB  3
5130:  MOVF   xB0,F
5132:  BTFSS  FD8.2
5134:  BRA    4A8E
....................  
....................    // if we reach this point, we know that the file won't be found 
....................    stream->Flags |= File_Not_Found; 
5136:  MOVLW  19
5138:  ADDWF  xAD,W
513A:  MOVWF  FE9
513C:  MOVLW  00
513E:  ADDWFC xAE,W
5140:  MOVWF  FEA
5142:  MOVF   FEF,W
5144:  IORLW  80
5146:  MOVWF  FEF
....................    return EOF; 
5148:  MOVLW  FF
514A:  MOVWF  01
514C:  MOVLB  0
514E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... Summary: This will get a name of a file. 
.................... Param file_entry_addr: The position in memory that the file's entry is. 
.................... Param name[]: The place to put the name of the file into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
*
378A:  MOVLB  3
378C:  CLRF   xDD
.................... { 
....................    int 
....................       j,       // counter for loops 
....................       k = 0,   // current character in array 
....................       order,   // byte to hold the current long file name order 
....................       type;    // the type of entry that was just read in 
....................  
....................    int32 i;          // pointer for memory 
....................  
....................    // the long file name isn't fragmented across clusters 
....................    i = file_entry_addr; 
378E:  MOVFF  3D9,3E3
3792:  MOVFF  3D8,3E2
3796:  MOVFF  3D7,3E1
379A:  MOVFF  3D6,3E0
....................  
....................    // check to make sure that this file has a long file name 
....................    if(mmcsd_read_data(i - 0x15, 1, &type) != GOODEC) 
379E:  MOVLW  15
37A0:  SUBWF  xE0,W
37A2:  MOVWF  xE4
37A4:  MOVLW  00
37A6:  SUBWFB xE1,W
37A8:  MOVWF  xE5
37AA:  MOVLW  00
37AC:  SUBWFB xE2,W
37AE:  MOVWF  xE6
37B0:  MOVLW  00
37B2:  SUBWFB xE3,W
37B4:  MOVWF  xE7
37B6:  MOVFF  FE8,419
37BA:  MOVFF  3E6,418
37BE:  MOVFF  3E5,417
37C2:  MOVFF  3E4,416
37C6:  MOVLB  4
37C8:  CLRF   x1B
37CA:  MOVLW  01
37CC:  MOVWF  x1A
37CE:  MOVLW  03
37D0:  MOVWF  x1D
37D2:  MOVLW  DF
37D4:  MOVWF  x1C
37D6:  MOVLB  0
37D8:  CALL   2BB8
37DC:  MOVF   01,F
37DE:  BZ    37E6
....................       return EOF; 
37E0:  MOVLW  FF
37E2:  MOVWF  01
37E4:  BRA    390A
....................  
....................    if(type != 0x0F) 
37E6:  MOVLB  3
37E8:  MOVF   xDF,W
37EA:  SUBLW  0F
37EC:  BZ    3822
....................    { 
....................       // this file doesn't have a long file name 
....................       if(get_short_file_name(i, name, type) == EOF) 
37EE:  MOVFF  3E3,3E7
37F2:  MOVFF  3E2,3E6
37F6:  MOVFF  3E1,3E5
37FA:  MOVFF  3E0,3E4
37FE:  MOVFF  3DB,3E9
3802:  MOVFF  3DA,3E8
3806:  MOVFF  3DF,3EA
380A:  MOVLB  0
380C:  BRA    31E8
380E:  MOVF   01,W
3810:  SUBLW  FF
3812:  BNZ   381A
....................          return EOF; 
3814:  MOVLW  FF
3816:  MOVWF  01
3818:  BRA    390A
....................       return GOODEC; 
381A:  MOVLW  00
381C:  MOVWF  01
381E:  BRA    390A
3820:  MOVLB  3
....................    } 
....................  
....................    do 
....................    { 
....................       // head to the previous entry 
....................       if(get_prev_entry(&i) == EOF) 
3822:  MOVLW  03
3824:  MOVWF  xE5
3826:  MOVLW  E0
3828:  MOVWF  xE4
382A:  MOVLB  0
382C:  BRA    3728
382E:  MOVF   01,W
3830:  SUBLW  FF
3832:  BNZ   383A
....................          return EOF; 
3834:  MOVLW  FF
3836:  MOVWF  01
3838:  BRA    390A
....................  
....................       for(j = 1; j < 0x20; j += 2, k += 1) 
383A:  MOVLW  01
383C:  MOVLB  3
383E:  MOVWF  xDC
3840:  MOVF   xDC,W
3842:  SUBLW  1F
3844:  BNC   38C2
....................       { 
....................          if(j == 11) 
3846:  MOVF   xDC,W
3848:  SUBLW  0B
384A:  BNZ   3852
....................             j = 14; 
384C:  MOVLW  0E
384E:  MOVWF  xDC
3850:  BRA    385C
....................          else if(j == 26) 
3852:  MOVF   xDC,W
3854:  SUBLW  1A
3856:  BNZ   385C
....................             j = 28; 
3858:  MOVLW  1C
385A:  MOVWF  xDC
....................          if(mmcsd_read_data(j + i, 1, &(name[k])) != GOODEC) 
385C:  MOVF   xDC,W
385E:  ADDWF  xE0,W
3860:  MOVWF  xE4
3862:  MOVLW  00
3864:  ADDWFC xE1,W
3866:  MOVWF  xE5
3868:  MOVLW  00
386A:  ADDWFC xE2,W
386C:  MOVWF  xE6
386E:  MOVLW  00
3870:  ADDWFC xE3,W
3872:  MOVWF  xE7
3874:  MOVF   xDD,W
3876:  ADDWF  xDA,W
3878:  MOVWF  01
387A:  MOVLW  00
387C:  ADDWFC xDB,W
387E:  MOVWF  03
3880:  MOVFF  01,3E8
3884:  MOVWF  xE9
3886:  MOVFF  3E7,419
388A:  MOVFF  3E6,418
388E:  MOVFF  3E5,417
3892:  MOVFF  3E4,416
3896:  MOVLB  4
3898:  CLRF   x1B
389A:  MOVLW  01
389C:  MOVWF  x1A
389E:  MOVFF  03,41D
38A2:  MOVFF  01,41C
38A6:  MOVLB  0
38A8:  CALL   2BB8
38AC:  MOVF   01,F
38AE:  BZ    38B6
....................             return EOF; 
38B0:  MOVLW  FF
38B2:  MOVWF  01
38B4:  BRA    390A
38B6:  MOVLW  02
38B8:  MOVLB  3
38BA:  ADDWF  xDC,F
38BC:  MOVLW  01
38BE:  ADDWF  xDD,F
38C0:  BRA    3840
....................       } 
....................  
....................       // now that that's done with, get the entry's order 
....................       if(mmcsd_read_data(i, 1, &order) != GOODEC) 
38C2:  MOVFF  3E3,419
38C6:  MOVFF  3E2,418
38CA:  MOVFF  3E1,417
38CE:  MOVFF  3E0,416
38D2:  MOVLB  4
38D4:  CLRF   x1B
38D6:  MOVLW  01
38D8:  MOVWF  x1A
38DA:  MOVLW  03
38DC:  MOVWF  x1D
38DE:  MOVLW  DE
38E0:  MOVWF  x1C
38E2:  MOVLB  0
38E4:  CALL   2BB8
38E8:  MOVF   01,F
38EA:  BZ    38F2
....................          return EOF; 
38EC:  MOVLW  FF
38EE:  MOVWF  01
38F0:  BRA    390A
....................  
....................    } while(!(order & 0x40));  // the last entry will be 0b01xxxxxx 
38F2:  MOVLB  3
38F4:  BTFSS  xDE.6
38F6:  BRA    3822
....................  
....................    // end the name[] buffer with a \0 
....................    name[k] = '\0'; 
38F8:  MOVF   xDD,W
38FA:  ADDWF  xDA,W
38FC:  MOVWF  FE9
38FE:  MOVLW  00
3900:  ADDWFC xDB,W
3902:  MOVWF  FEA
3904:  CLRF   FEF
....................  
....................    return GOODEC; 
3906:  MOVLW  00
3908:  MOVWF  01
390A:  MOVLB  0
390C:  GOTO   4B48 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int set_file_name(int32 parent_dir_addr, int32 entry_addr, char name[]) 
.................... Summary: Creates both a short and long file name at the first free entry in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param entry_addr: The address the function put the short file name entry. 
.................... Param name: The full file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]) 
.................... { 
....................    char sname[12];   // place to hold the short file name 
....................  
....................    signed int name_pos = 0;   // the current parse position of name[] 
....................  
....................    int 
....................       chksum,               // the long file name checksum 
....................       entire_entry[0x20],   // the entire entry to put write onto the media 
....................       entry_pos,            // the current position inside of entire_entry 
....................       long_entry = 1;       // the current long entry number we're on 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    // check for invalid characters 
....................    if(check_invalid_char(name) == EOF) 
....................       return EOF; 
....................  
....................    // make a short file name of this 
....................    if(make_short_file_name(parent_dir_addr, name, sname) == EOF) 
....................       return EOF; 
....................  
....................    // get a checksum for the long file name entries 
....................    chksum = long_name_chksum(sname); 
....................  
....................    // start writing the long file name 
....................    // zero out entry[] 
....................    for(entry_pos = 0; entry_pos < 0x20; entry_pos += 1) 
....................       entire_entry[entry_pos] = 0;    
....................  
....................    i = parent_dir_addr; 
....................    if(get_next_free_entry(&i) == EOF) 
....................       return EOF; 
....................  
....................    // 0x0F signifies an file entry 
....................    entire_entry[11] = 0x0F; 
....................  
....................    // since we're working in reverse, write the final long name entry 
....................    name_pos = strlen(name); 
....................    name_pos %= 13; 
....................  
....................    if(name_pos != 0) 
....................    { 
....................       // add 1 to account for the \0 terminator 
....................       name_pos += 1; 
....................  
....................       fill_entry(entire_entry, 0xFF, name_pos); 
....................    } 
....................  
....................    // start writing the long file name entries 
....................    name_pos = strlen(name); 
....................  
....................    // figure out how many entries this name will take up 
....................    long_entry = (name_pos / 13) + 1; 
....................  
....................    if(name_pos % 13 == 0) 
....................       long_entry -= 1; 
....................  
....................    // set the bit to signify this is the final entry 
....................    long_entry |= 0x40; 
....................  
....................    while(name_pos >= 0) 
....................    { 
....................       entry_pos = name_pos % 13; 
....................  
....................       if(entry_pos < 5) 
....................          entire_entry[(entry_pos << 1) + 1] = name[name_pos]; 
....................  
....................       else if(entry_pos < 11) 
....................          entire_entry[(entry_pos << 1) + 4] = name[name_pos]; 
....................  
....................       else 
....................          entire_entry[(entry_pos << 1) + 6] = name[name_pos]; 
....................  
....................       if((entry_pos == 0) 
....................          && (name_pos != strlen (name))) 
....................       { 
....................          entire_entry[0] = long_entry; 
....................  
....................          // clear off the bits at positions 6 and 7 if the most recent entry was the final one. 
....................          if(name_pos != 0) 
....................             long_entry &= 0x3F; 
....................  
....................          long_entry -= 1; 
....................  
....................          entire_entry[13] = chksum; 
....................          if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................             return EOF; 
....................          if(get_next_free_entry(&i) == EOF) 
....................             return EOF; 
....................          fill_entry(entire_entry, 0x00, 0); 
....................       } 
....................       name_pos -= 1; 
....................    } 
....................  
....................    // write the short file name to the entry 
....................    if(mmcsd_write_data(i, 11, sname) != GOODEC) 
....................       return EOF; 
....................  
....................    // set the new entry addr 
....................    *entry_addr = i; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... Summary: Reads a file's short file name, puts all the characters into lower case, and puts it into a buffer. 
.................... Param file_entry_addr: Where the file's entry address is located. 
.................... Param sname: The buffer to put the short file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
*
31E8:  MOVLB  3
31EA:  CLRF   xED
.................... { 
....................    int 
....................       buf, 
....................       i, 
....................       j = 0; 
....................  
....................    // one short file name has, at the most, 11 characters 
....................    for(i = 0; i < 11; i += 1) 
31EC:  CLRF   xEC
31EE:  MOVF   xEC,W
31F0:  SUBLW  0A
31F2:  BNC   326E
....................    {       
....................       // read in a character 
....................       if(mmcsd_read_data(i + file_entry_addr, 1, &buf) != GOODEC) 
31F4:  MOVF   xEC,W
31F6:  ADDWF  xE4,W
31F8:  MOVWF  xEE
31FA:  MOVLW  00
31FC:  ADDWFC xE5,W
31FE:  MOVWF  xEF
3200:  MOVLW  00
3202:  ADDWFC xE6,W
3204:  MOVWF  xF0
3206:  MOVLW  00
3208:  ADDWFC xE7,W
320A:  MOVWF  xF1
320C:  MOVFF  FE8,419
3210:  MOVFF  3F0,418
3214:  MOVFF  3EF,417
3218:  MOVFF  3EE,416
321C:  MOVLB  4
321E:  CLRF   x1B
3220:  MOVLW  01
3222:  MOVWF  x1A
3224:  MOVLW  03
3226:  MOVWF  x1D
3228:  MOVLW  EB
322A:  MOVWF  x1C
322C:  MOVLB  0
322E:  RCALL  2BB8
3230:  MOVF   01,F
3232:  BZ    323A
....................          return EOF; 
3234:  MOVLW  FF
3236:  MOVWF  01
3238:  BRA    331E
....................        
....................       // convert the character 
....................       if(buf != ' ') 
323A:  MOVLB  3
323C:  MOVF   xEB,W
323E:  SUBLW  20
3240:  BZ    3268
....................       {          
....................          sname[j] = tolower(buf); 
3242:  MOVF   xED,W
3244:  ADDWF  xE8,W
3246:  MOVWF  FE9
3248:  MOVLW  00
324A:  ADDWFC xE9,W
324C:  MOVWF  FEA
324E:  MOVF   xEB,W
3250:  SUBLW  40
3252:  BC    3260
3254:  MOVF   xEB,W
3256:  SUBLW  5A
3258:  BNC   3260
325A:  MOVF   xEB,W
325C:  IORLW  20
325E:  BRA    3262
3260:  MOVF   xEB,W
3262:  MOVWF  FEF
....................          j += 1; 
3264:  MOVLW  01
3266:  ADDWF  xED,F
....................       } 
3268:  MOVLW  01
326A:  ADDWF  xEC,F
326C:  BRA    31EE
....................        
....................    }    
....................  
....................    // tack on a null terminator 
....................    sname[j] = '\0'; 
326E:  MOVF   xED,W
3270:  ADDWF  xE8,W
3272:  MOVWF  FE9
3274:  MOVLW  00
3276:  ADDWFC xE9,W
3278:  MOVWF  FEA
327A:  CLRF   FEF
....................     
....................    //printf("\r\n%s, %u\r\n",sname, strlen(sname)); 
....................  
....................    if(type != 0x10 && strlen(sname) > 3) 
327C:  MOVF   xEA,W
327E:  SUBLW  10
3280:  BZ    330A
3282:  MOVFF  3E9,3EF
3286:  MOVFF  3E8,3EE
328A:  MOVLB  0
328C:  RCALL  31AC
328E:  MOVFF  02,3EF
3292:  MOVFF  01,3EE
3296:  MOVLB  3
3298:  MOVF   xEF,F
329A:  BNZ   32A2
329C:  MOVF   xEE,W
329E:  SUBLW  03
32A0:  BC    330A
....................    { 
....................       j = strlen(sname); 
32A2:  MOVFF  3E9,3EF
32A6:  MOVFF  3E8,3EE
32AA:  MOVLB  0
32AC:  RCALL  31AC
32AE:  MOVFF  01,3ED
....................       for(i=j; i > j-3; --i) 
32B2:  MOVFF  3ED,3EC
32B6:  MOVLW  03
32B8:  MOVLB  3
32BA:  SUBWF  xED,W
32BC:  SUBWF  xEC,W
32BE:  BZ    32FA
32C0:  BNC   32FA
....................          sname[i] = sname[i-1]; 
32C2:  MOVF   xEC,W
32C4:  ADDWF  xE8,W
32C6:  MOVWF  01
32C8:  MOVLW  00
32CA:  ADDWFC xE9,W
32CC:  MOVWF  03
32CE:  MOVFF  01,3EE
32D2:  MOVWF  xEF
32D4:  MOVLW  01
32D6:  SUBWF  xEC,W
32D8:  ADDWF  xE8,W
32DA:  MOVWF  FE9
32DC:  MOVLW  00
32DE:  ADDWFC xE9,W
32E0:  MOVWF  FEA
32E2:  MOVFF  FEF,3F0
32E6:  MOVFF  03,FEA
32EA:  MOVFF  01,FE9
32EE:  MOVFF  3F0,FEF
32F2:  DECF   xEC,F
32F4:  MOVLB  0
32F6:  BRA    32B6
32F8:  MOVLB  3
....................       sname[i] = '.'; 
32FA:  MOVF   xEC,W
32FC:  ADDWF  xE8,W
32FE:  MOVWF  FE9
3300:  MOVLW  00
3302:  ADDWFC xE9,W
3304:  MOVWF  FEA
3306:  MOVLW  2E
3308:  MOVWF  FEF
....................    } 
....................     
....................    sname[j+1] = '\0'; 
330A:  MOVLW  01
330C:  ADDWF  xED,W
330E:  ADDWF  xE8,W
3310:  MOVWF  FE9
3312:  MOVLW  00
3314:  ADDWFC xE9,W
3316:  MOVWF  FEA
3318:  CLRF   FEF
....................  
....................    return GOODEC; 
331A:  MOVLW  00
331C:  MOVWF  01
331E:  MOVLB  0
3320:  GOTO   380E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... Summary: Creates a unique short file name in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param fname: The full file name. 
.................... Param sname: Character array that will hold the short file name upon function completion. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... { 
....................    char 
....................       val[12] = "           ", 
....................       cur_fname[12] = "           ", 
....................       cur_fnum[7] = "      "; 
....................  
....................    int 
....................       buf, 
....................       ext_pos, 
....................       fname_parse_pos = 0, 
....................       val_parse_pos = 0; 
....................  
....................    int32 
....................       fnum = 0, 
....................       i; 
....................  
....................    // figure out where the extension position is 
....................    ext_pos = strchr(fname, '.'); 
....................  
....................    // check to see if this file has an extension 
....................    if(ext_pos == 0) 
....................    { 
....................       while((val_parse_pos < 8) && (fname[fname_parse_pos] != '\0')) 
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
....................          val_parse_pos += 1; 
....................          fname_parse_pos += 1; 
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
....................             fname_parse_pos += 1; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       ext_pos -= fname - 1; 
....................       while((val_parse_pos < 11) && (fname[fname_parse_pos] != '\0')) 
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
....................          val_parse_pos += 1; 
....................          fname_parse_pos += 1; 
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
....................             fname_parse_pos += 1; 
....................  
....................          // check to see if it's time to skip val_parse_pos ahead to the file extension 
....................          if(fname_parse_pos == ext_pos) 
....................             val_parse_pos = 8; 
....................  
....................          // check to see if it's time to skip name_parse_pos ahead to the file extension 
....................          else if(val_parse_pos == 8) 
....................             fname_parse_pos = ext_pos; 
....................       } 
....................    } 
....................  
....................    // now that we've got the short file name, we need to make it unique 
....................    i = parent_dir_addr; 
....................    if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
....................       return EOF; 
....................  
....................    // keep reading until we hit empty space 
....................    while(buf != 0x00) 
....................    { 
....................       // check to see if this is a short file name entry 
....................       if((buf == 0x20) || (buf == 0x10)) 
....................       { 
....................          // read in the short file name that we're currently pointing at 
....................          if(mmcsd_read_data(i, 11, cur_fname) != GOODEC) 
....................             return EOF; 
....................  
....................          cur_fname[11] = '\0'; 
....................  
....................          // strcmp will return a 0 if the file name we're currently pointing at and the file name that we created above are the same 
....................          if(strcmp(cur_fname, val) == 0) 
....................          { 
....................             // we now need to create a unique file name 
....................             //  increment the unique file number by one 
....................             fnum += 1; 
....................  
....................             // convert the unique file number to a string 
....................             sprintf(cur_fnum, "%lu", fnum); 
....................  
....................             // put the unique file number, along with a '~' into our short file name 
....................             fname_parse_pos = 0; 
....................  
....................             // find out the last posiiton of a space 
....................             val_parse_pos = strchr(val, ' '); 
....................             if(val_parse_pos == 0) 
....................                // if there isn't a space, then we're going to have to put the ~x at the end of the short name 
....................                val_parse_pos = 7 - strlen(cur_fnum); 
....................             else 
....................                // if there is a space, then put the ~x there 
....................                val_parse_pos -= val + 2; 
....................  
....................             // make some room for extra digits 
....................             buf = 10; 
....................             while(fnum >= buf) 
....................             { 
....................                val_parse_pos -= 1; 
....................                buf *= 10; 
....................             } 
....................  
....................             // write in the ~ 
....................             val[val_parse_pos] = '~'; 
....................  
....................             // write in the number 
....................             val_parse_pos += 1; 
....................             while(cur_fnum[fname_parse_pos] != '\0') 
....................             { 
....................                val[val_parse_pos] = cur_fnum[fname_parse_pos]; 
....................                val_parse_pos += 1; 
....................                fname_parse_pos += 1; 
....................             } 
....................  
....................             // start the search over again to see if that unique file name/number combination is still taken up 
....................             i = parent_dir_addr; 
....................          } 
....................       } 
....................  
....................       // head to the next entry 
....................       if(get_next_entry(&i) == EOF) 
....................       { 
....................          // we're going to have to allocate another cluster 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
....................             return EOF;          
....................       } 
....................       if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
....................          return EOF; 
....................    } 
....................  
....................    // copy the short name into the input buffer 
....................    for(i = 0; i < 12; i += 1) 
....................       sname[i] = val[i]; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... int long_name_chksum (int* FcbName) 
.................... Summary: Returns an unsigned byte checksum computed on an unsigned byte 
....................           array. The array must be 11 bytes long and is assumed to contain 
....................           a name stored in the format of a MS-DOS directory entry. 
.................... Param: Pointer to an unsigned byte array assumed to be 11 bytes long. 
.................... Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName. 
.................... */ 
.................... int long_name_chksum (int* pFcbName) 
.................... { 
....................    int 
....................       FcbNameLen, 
....................       Sum = 0; 
....................  
....................    for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen -= 1) 
....................       // The operation is an unsigned char rotate right 
....................       Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++; 
....................  
....................    return Sum; 
.................... } 
....................  
.................... /* 
.................... signed int check_invalid_char(char fname[]) 
.................... Summary: Checks the filename for any invalid characters. 
.................... Param: The name of the file to check. 
.................... Returns: EOF if an invalid character was found, GOODEC otherwise. 
.................... */ 
.................... signed int check_invalid_char(char fname[]) 
.................... { 
....................    int fname_pos; 
....................  
....................    for(fname_pos = 0; (fname[fname_pos] != '\0') && (fname_pos < MAX_FILE_NAME_LENGTH); fname_pos += 1) 
....................       if(isamoung(fname[fname_pos], "\\/:*?\"<>|")) 
....................          return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... Summary: Will go through the FAT and find the first unallocated cluster. 
.................... Param: Pointer to a variable that will the the starting cluster of the serach. 
....................         When a free cluster is found, the cluster number will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This gets a little slow when dealing with a card with lots of stuff on it; sorry about that. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAST_FAT 
....................    *my_cluster += 1; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................  
.................... #ifdef FAT32 
....................    int val[4];            // buffer to hold values 
....................  
....................    int32 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 2) + FAT_Start; 
*
3C90:  MOVFF  3FB,FE9
3C94:  MOVFF  3FC,FEA
3C98:  MOVFF  FEF,40D
3C9C:  MOVFF  FEC,40E
3CA0:  MOVFF  FEC,40F
3CA4:  MOVFF  FEC,410
3CA8:  MOVLB  4
3CAA:  RLCF   x0D,F
3CAC:  RLCF   x0E,F
3CAE:  RLCF   x0F,F
3CB0:  RLCF   x10,F
3CB2:  RLCF   x0D,F
3CB4:  RLCF   x0E,F
3CB6:  RLCF   x0F,F
3CB8:  RLCF   x10,F
3CBA:  MOVLW  FC
3CBC:  ANDWF  x0D,F
3CBE:  MOVLB  2
3CC0:  MOVF   x0E,W
3CC2:  MOVLB  4
3CC4:  ADDWF  x0D,W
3CC6:  MOVWF  x05
3CC8:  MOVLB  2
3CCA:  MOVF   x0F,W
3CCC:  MOVLB  4
3CCE:  ADDWFC x0E,W
3CD0:  MOVWF  x06
3CD2:  MOVLB  2
3CD4:  MOVF   x10,W
3CD6:  MOVLB  4
3CD8:  ADDWFC x0F,W
3CDA:  MOVWF  x07
3CDC:  MOVLB  2
3CDE:  MOVF   x11,W
3CE0:  MOVLB  4
3CE2:  ADDWFC x10,W
3CE4:  MOVWF  x08
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 4) 
3CE6:  CLRF   x0C
3CE8:  CLRF   x0B
3CEA:  CLRF   x0A
3CEC:  CLRF   x09
3CEE:  MOVF   x0C,W
3CF0:  MOVLB  2
3CF2:  SUBWF  x19,W
3CF4:  BTFSS  FD8.0
3CF6:  BRA    3E14
3CF8:  BNZ   3D26
3CFA:  MOVLB  4
3CFC:  MOVF   x0B,W
3CFE:  MOVLB  2
3D00:  SUBWF  x18,W
3D02:  BTFSS  FD8.0
3D04:  BRA    3E14
3D06:  BNZ   3D26
3D08:  MOVLB  4
3D0A:  MOVF   x0A,W
3D0C:  MOVLB  2
3D0E:  SUBWF  x17,W
3D10:  BTFSS  FD8.0
3D12:  BRA    3E14
3D14:  BNZ   3D26
3D16:  MOVF   x16,W
3D18:  MOVLB  4
3D1A:  SUBWF  x09,W
3D1C:  BTFSS  FD8.0
3D1E:  BRA    3D24
3D20:  MOVLB  2
3D22:  BRA    3E14
3D24:  MOVLB  2
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 4, val) != GOODEC) 
3D26:  MOVLB  4
3D28:  MOVF   x09,W
3D2A:  ADDWF  x05,W
3D2C:  MOVWF  x0D
3D2E:  MOVF   x0A,W
3D30:  ADDWFC x06,W
3D32:  MOVWF  x0E
3D34:  MOVF   x0B,W
3D36:  ADDWFC x07,W
3D38:  MOVWF  x0F
3D3A:  MOVF   x0C,W
3D3C:  ADDWFC x08,W
3D3E:  MOVWF  x10
3D40:  MOVWF  x19
3D42:  MOVFF  40F,418
3D46:  MOVFF  40E,417
3D4A:  MOVFF  40D,416
3D4E:  CLRF   x1B
3D50:  MOVLW  04
3D52:  MOVWF  x1A
3D54:  MOVLW  03
3D56:  MOVWF  x1D
3D58:  MOVLW  FD
3D5A:  MOVWF  x1C
3D5C:  MOVLB  0
3D5E:  CALL   2BB8
3D62:  MOVF   01,F
3D64:  BZ    3D6C
....................          return EOF; 
3D66:  MOVLW  FF
3D68:  MOVWF  01
3D6A:  BRA    3E1A
....................  
....................       cur_cluster = make32(val[3], val[2], val[1], val[0]); 
3D6C:  MOVFF  400,404
3D70:  MOVFF  3FF,403
3D74:  MOVFF  3FE,402
3D78:  MOVFF  3FD,401
....................  
....................       if(cur_cluster == 0) 
3D7C:  MOVLB  4
3D7E:  MOVF   x01,F
3D80:  BNZ   3E04
3D82:  MOVF   x02,F
3D84:  BNZ   3E04
3D86:  MOVF   x03,F
3D88:  BNZ   3E04
3D8A:  MOVF   x04,F
3D8C:  BNZ   3E04
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
3D8E:  MOVF   x09,W
3D90:  ADDWF  x05,F
3D92:  MOVF   x0A,W
3D94:  ADDWFC x06,F
3D96:  MOVF   x0B,W
3D98:  ADDWFC x07,F
3D9A:  MOVF   x0C,W
3D9C:  ADDWFC x08,F
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 2; 
3D9E:  MOVFF  3FB,FE9
3DA2:  MOVFF  3FC,FEA
3DA6:  MOVLB  2
3DA8:  MOVF   x0E,W
3DAA:  MOVLB  4
3DAC:  SUBWF  x05,W
3DAE:  MOVWF  x0F
3DB0:  MOVLB  2
3DB2:  MOVF   x0F,W
3DB4:  MOVLB  4
3DB6:  SUBWFB x06,W
3DB8:  MOVWF  x10
3DBA:  MOVLB  2
3DBC:  MOVF   x10,W
3DBE:  MOVLB  4
3DC0:  SUBWFB x07,W
3DC2:  MOVWF  x11
3DC4:  MOVLB  2
3DC6:  MOVF   x11,W
3DC8:  MOVLB  4
3DCA:  SUBWFB x08,W
3DCC:  MOVWF  x12
3DCE:  RRCF   x12,W
3DD0:  MOVWF  03
3DD2:  RRCF   x11,W
3DD4:  MOVWF  02
3DD6:  RRCF   x10,W
3DD8:  MOVWF  01
3DDA:  RRCF   x0F,W
3DDC:  MOVWF  00
3DDE:  RRCF   03,F
3DE0:  RRCF   02,F
3DE2:  RRCF   01,F
3DE4:  RRCF   00,F
3DE6:  MOVLW  3F
3DE8:  ANDWF  03,F
3DEA:  MOVFF  00,FEF
3DEE:  MOVFF  01,FEC
3DF2:  MOVFF  02,FEC
3DF6:  MOVFF  03,FEC
....................          return GOODEC; 
3DFA:  MOVLW  00
3DFC:  MOVWF  01
3DFE:  MOVLB  0
3E00:  BRA    3E1A
3E02:  MOVLB  4
....................       } 
3E04:  MOVLW  04
3E06:  ADDWF  x09,F
3E08:  MOVLW  00
3E0A:  ADDWFC x0A,F
3E0C:  ADDWFC x0B,F
3E0E:  ADDWFC x0C,F
3E10:  BRA    3CEE
3E12:  MOVLB  2
....................    } 
.................... #else // FAT16 
....................    int val[2]; 
....................  
....................    int16 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 1) + FAT_Start; 
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 2) 
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 2, val) != GOODEC) 
....................          return EOF; 
....................  
....................       cur_cluster = make16(val[1], val[0]); 
....................  
....................       if(cur_cluster == 0) 
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 1; 
....................          return GOODEC; 
....................       } 
....................    } 
....................  
.................... #endif // #ifdef FAT32 
....................    // if we reach this point, we are out of disk space 
....................    return EOF; 
3E14:  MOVLW  FF
3E16:  MOVWF  01
3E18:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
3E1A:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the next file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_next_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry, 
....................       filetype; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go forward an entry 
....................       if(get_next_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................     
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  cluster_to_addr(cluster); 
....................     
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the previous file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_prev_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry = 0xE5, 
....................       filetype = 0; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go backward an entry 
....................       if(get_prev_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................  
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  addr_to_cluster(cluster); 
....................  
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... Summary: Finds the next unallocated address. 
.................... Param: Pointer to a variable that will the the starting address of the serach. 
....................         When a free address is found, the address will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... { 
....................    int val;   // buffer to hold values 
....................  
....................    int32 cur_addr;   // pointer to memory 
....................  
....................    // make a copy of *my_addr 
....................    cur_addr = *my_addr; 
....................  
....................    // keep on getting addresses until we hit a free one 
....................    do 
....................    { 
....................       if(mmcsd_read_data(cur_addr, 1, &val) != GOODEC) 
....................          return EOF; 
....................  
....................       if(get_next_addr(&cur_addr) == EOF) 
....................          return EOF; 
....................    } while(val != 0); 
....................  
....................    *my_addr = cur_addr; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_entry(int32* start_addr) 
.................... Summary: Gets the next entry in a directory. 
.................... Param: The address to start looking for an entry. 
....................    If an entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
4A0A:  MOVLB  3
4A0C:  MOVFF  3D6,FE9
4A10:  MOVFF  3D7,FEA
4A14:  MOVFF  FEF,3D8
4A18:  MOVFF  FEC,3D9
4A1C:  MOVFF  FEC,3DA
4A20:  MOVFF  FEC,3DB
....................     
....................    i += 0x1F; 
4A24:  MOVLW  1F
4A26:  ADDWF  xD8,F
4A28:  MOVLW  00
4A2A:  ADDWFC xD9,F
4A2C:  ADDWFC xDA,F
4A2E:  ADDWFC xDB,F
....................     
....................    if(get_next_addr(&i) == EOF) 
4A30:  MOVLW  03
4A32:  MOVWF  xEA
4A34:  MOVLW  D8
4A36:  MOVWF  xE9
4A38:  MOVLB  0
4A3A:  CALL   4034
4A3E:  MOVF   01,W
4A40:  SUBLW  FF
4A42:  BNZ   4A4A
....................       return EOF; 
4A44:  MOVLW  FF
4A46:  MOVWF  01
4A48:  BRA    4A68
....................     
....................    *start_addr = i; 
4A4A:  MOVLB  3
4A4C:  MOVFF  3D6,FE9
4A50:  MOVFF  3D7,FEA
4A54:  MOVFF  3D8,FEF
4A58:  MOVFF  3D9,FEC
4A5C:  MOVFF  3DA,FEC
4A60:  MOVFF  3DB,FEC
....................     
....................    return GOODEC; 
4A64:  MOVLW  00
4A66:  MOVWF  01
4A68:  MOVLB  0
4A6A:  GOTO   511E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_prev_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
3728:  MOVLB  3
372A:  MOVFF  3E4,FE9
372E:  MOVFF  3E5,FEA
3732:  MOVFF  FEF,3E6
3736:  MOVFF  FEC,3E7
373A:  MOVFF  FEC,3E8
373E:  MOVFF  FEC,3E9
....................  
....................    i -= 0x1F; 
3742:  MOVLW  1F
3744:  SUBWF  xE6,F
3746:  MOVLW  00
3748:  SUBWFB xE7,F
374A:  SUBWFB xE8,F
374C:  SUBWFB xE9,F
....................  
....................    if(get_prev_addr(&i) == EOF) 
374E:  MOVLW  03
3750:  MOVWF  xEB
3752:  MOVLW  E6
3754:  MOVWF  xEA
3756:  MOVLB  0
3758:  BRA    34DE
375A:  MOVF   01,W
375C:  SUBLW  FF
375E:  BNZ   3766
....................       return EOF; 
3760:  MOVLW  FF
3762:  MOVWF  01
3764:  BRA    3784
....................  
....................    *start_addr = i; 
3766:  MOVLB  3
3768:  MOVFF  3E4,FE9
376C:  MOVFF  3E5,FEA
3770:  MOVFF  3E6,FEF
3774:  MOVFF  3E7,FEC
3778:  MOVFF  3E8,FEC
377C:  MOVFF  3E9,FEC
....................     
....................    return GOODEC; 
3780:  MOVLW  00
3782:  MOVWF  01
3784:  MOVLB  0
3786:  GOTO   382E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... { 
....................    int buf; 
....................  
....................    int32 i; 
....................  
....................    i = *start_addr; 
....................  
....................    if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
....................      return EOF; 
....................  
....................    while(buf != 0) 
....................    { 
....................       i += 0x1F; 
....................       // get the next address 
....................       if(get_next_addr(&i) == EOF) 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
....................             return EOF; 
....................  
....................       if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
....................         return EOF; 
....................    } 
....................  
....................    *start_addr = i; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... Summary: Find, allocate, and link a free cluster. 
.................... Param start_cluster: The cluster to begin looking for free clusters. This cluster will be linked to the newfound cluster in the FAT. 
.................... Param new_cluster_addr: The address of the newly allocated cluster. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr) 
.................... #else 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster, 
....................       next_cluster; 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster, 
....................       next_cluster; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're at the end of the file's allocated space, then we need to allocate some more space 
....................    //  figure out where the current character is pointing to 
....................    next_cluster = cur_cluster = start_cluster; 
*
423A:  MOVFF  3F0,3F6
423E:  MOVFF  3EF,3F5
4242:  MOVFF  3EE,3F4
4246:  MOVFF  3ED,3F3
424A:  MOVFF  3F6,3FA
424E:  MOVFF  3F5,3F9
4252:  MOVFF  3F4,3F8
4256:  MOVFF  3F3,3F7
....................  
....................    // get the next free cluster 
....................    if(get_next_free_cluster(&next_cluster) == EOF) 
425A:  MOVLW  03
425C:  MOVLB  3
425E:  MOVWF  xFC
4260:  MOVLW  F7
4262:  MOVWF  xFB
4264:  MOVLB  0
4266:  RCALL  3C90
4268:  MOVF   01,W
426A:  SUBLW  FF
426C:  BNZ   4274
....................       return EOF; 
426E:  MOVLW  FF
4270:  MOVWF  01
4272:  BRA    432C
....................  
....................    if(write_fat(cur_cluster, next_cluster) == EOF) 
4274:  MOVFF  3F6,3FE
4278:  MOVFF  3F5,3FD
427C:  MOVFF  3F4,3FC
4280:  MOVFF  3F3,3FB
4284:  MOVFF  3FA,402
4288:  MOVFF  3F9,401
428C:  MOVFF  3F8,400
4290:  MOVFF  3F7,3FF
4294:  RCALL  3AE6
4296:  MOVF   01,W
4298:  SUBLW  FF
429A:  BNZ   42A2
....................       return EOF; 
429C:  MOVLW  FF
429E:  MOVWF  01
42A0:  BRA    432C
....................  
.................... #ifdef FAT32 
....................    if(write_fat(next_cluster, 0x0FFFFFFF) == EOF) 
42A2:  MOVFF  3FA,3FE
42A6:  MOVFF  3F9,3FD
42AA:  MOVFF  3F8,3FC
42AE:  MOVFF  3F7,3FB
42B2:  MOVLW  0F
42B4:  MOVLB  4
42B6:  MOVWF  x02
42B8:  SETF   x01
42BA:  SETF   x00
42BC:  MOVLB  3
42BE:  SETF   xFF
42C0:  MOVLB  0
42C2:  RCALL  3AE6
42C4:  MOVF   01,W
42C6:  SUBLW  FF
42C8:  BNZ   42D0
....................       return EOF; 
42CA:  MOVLW  FF
42CC:  MOVWF  01
42CE:  BRA    432C
....................  
.................... #else // FAT16 
....................    if(write_fat(next_cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // erase all of the data in the newly linked cluster 
....................    if(clear_cluster(next_cluster) == EOF) 
42D0:  MOVFF  3FA,3FE
42D4:  MOVFF  3F9,3FD
42D8:  MOVFF  3F8,3FC
42DC:  MOVFF  3F7,3FB
42E0:  RCALL  3E1C
42E2:  MOVF   01,W
42E4:  SUBLW  FF
42E6:  BNZ   42EE
....................       return EOF; 
42E8:  MOVLW  FF
42EA:  MOVWF  01
42EC:  BRA    432C
....................  
....................    // put the current character to this position 
....................    *new_cluster_addr = cluster_to_addr(next_cluster); 
42EE:  MOVFF  3F2,03
42F2:  MOVFF  3F1,3FB
42F6:  MOVFF  3F2,3FC
42FA:  MOVFF  3FA,429
42FE:  MOVFF  3F9,428
4302:  MOVFF  3F8,427
4306:  MOVFF  3F7,426
430A:  MOVLB  0
430C:  CALL   3480
4310:  MOVFF  3FC,FEA
4314:  MOVFF  3FB,FE9
4318:  MOVFF  00,FEF
431C:  MOVFF  01,FEC
4320:  MOVFF  02,FEC
4324:  MOVFF  03,FEC
....................  
....................    return GOODEC; 
4328:  MOVLW  00
432A:  MOVWF  01
432C:  GOTO   45B8 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... Summary: De-allocates linked clusters from the FAT. 
.................... Param: The starting cluster to deallocate. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int dealloc_clusters(int32 start_cluster) 
.................... #else 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #endif // #ifdef FAT32 
....................  
....................    //  figure out where the first cluster is 
....................    next_cluster = cur_cluster = start_cluster; 
*
3B62:  MOVFF  3DD,3E1
3B66:  MOVFF  3DC,3E0
3B6A:  MOVFF  3DB,3DF
3B6E:  MOVFF  3DA,3DE
3B72:  MOVFF  3E1,3E5
3B76:  MOVFF  3E0,3E4
3B7A:  MOVFF  3DF,3E3
3B7E:  MOVFF  3DE,3E2
....................    do 
....................    { 
....................       // get the next cluster 
....................       if(get_next_cluster(&next_cluster) == EOF) 
3B82:  MOVLW  03
3B84:  MOVLB  3
3B86:  MOVWF  xF0
3B88:  MOVLW  E2
3B8A:  MOVWF  xEF
3B8C:  MOVLB  0
3B8E:  RCALL  398A
3B90:  MOVF   01,W
3B92:  SUBLW  FF
3B94:  BNZ   3B9C
....................          return EOF; 
3B96:  MOVLW  FF
3B98:  MOVWF  01
3B9A:  BRA    3C08
....................  
....................       // unlink the current cluster in the FAT 
....................       if(write_fat(cur_cluster, 0) == EOF) 
3B9C:  MOVFF  3E1,3FE
3BA0:  MOVFF  3E0,3FD
3BA4:  MOVFF  3DF,3FC
3BA8:  MOVFF  3DE,3FB
3BAC:  MOVLB  4
3BAE:  CLRF   x02
3BB0:  CLRF   x01
3BB2:  CLRF   x00
3BB4:  MOVLB  3
3BB6:  CLRF   xFF
3BB8:  MOVLB  0
3BBA:  RCALL  3AE6
3BBC:  MOVF   01,W
3BBE:  SUBLW  FF
3BC0:  BNZ   3BC8
....................          return EOF; 
3BC2:  MOVLW  FF
3BC4:  MOVWF  01
3BC6:  BRA    3C08
....................  
....................       cur_cluster = next_cluster; 
3BC8:  MOVFF  3E5,3E1
3BCC:  MOVFF  3E4,3E0
3BD0:  MOVFF  3E3,3DF
3BD4:  MOVFF  3E2,3DE
....................    } 
.................... #ifdef FAT32 
....................     while(cur_cluster != 0x0FFFFFFF); 
3BD8:  MOVLB  3
3BDA:  INCFSZ xDE,W
3BDC:  BRA    3BE0
3BDE:  BRA    3BE4
3BE0:  MOVLB  0
3BE2:  BRA    3B82
3BE4:  INCFSZ xDF,W
3BE6:  BRA    3BEA
3BE8:  BRA    3BEE
3BEA:  MOVLB  0
3BEC:  BRA    3B82
3BEE:  INCFSZ xE0,W
3BF0:  BRA    3BF4
3BF2:  BRA    3BF8
3BF4:  MOVLB  0
3BF6:  BRA    3B82
3BF8:  MOVF   xE1,W
3BFA:  SUBLW  0F
3BFC:  BTFSC  FD8.2
3BFE:  BRA    3C04
3C00:  MOVLB  0
3C02:  BRA    3B82
.................... #else // FAT16 
....................     while(cur_cluster != 0xFFFF); 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
3C04:  MOVLW  00
3C06:  MOVWF  01
3C08:  MOVLB  0
3C0A:  GOTO   4E70 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int clear_cluster(int16 cluster) 
.................... Summary: Clears out all of the data in a given cluster. 
.................... Param: The cluster to clear out. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int clear_cluster(int32 cluster) 
.................... #else 
.................... signed int clear_cluster(int16 cluster) 
.................... #endif 
.................... { 
....................    int 
....................       clear_entry[0x20], 
....................       j; 
....................  
....................    int16 i; 
....................  
....................    int32 start_addr; 
....................  
....................    start_addr = cluster_to_addr(cluster); 
*
3E1C:  MOVFF  3FE,429
3E20:  MOVFF  3FD,428
3E24:  MOVFF  3FC,427
3E28:  MOVFF  3FB,426
3E2C:  CALL   3480
3E30:  MOVFF  03,425
3E34:  MOVFF  02,424
3E38:  MOVFF  01,423
3E3C:  MOVFF  00,422
....................     
....................    for(j = 0; j < 0x20; j += 1) 
3E40:  MOVLB  4
3E42:  CLRF   x1F
3E44:  MOVF   x1F,W
3E46:  SUBLW  1F
3E48:  BNC   3E60
....................       clear_entry[j] = 0; 
3E4A:  CLRF   03
3E4C:  MOVF   x1F,W
3E4E:  ADDLW  FF
3E50:  MOVWF  FE9
3E52:  MOVLW  03
3E54:  ADDWFC 03,W
3E56:  MOVWF  FEA
3E58:  CLRF   FEF
3E5A:  MOVLW  01
3E5C:  ADDWF  x1F,F
3E5E:  BRA    3E44
....................  
....................    for(i = 0; i < Bytes_Per_Cluster; i += 0x20) 
3E60:  CLRF   x21
3E62:  CLRF   x20
3E64:  MOVF   x21,W
3E66:  MOVLB  2
3E68:  SUBWF  x0D,W
3E6A:  BNC   3ECE
3E6C:  BNZ   3E7E
3E6E:  MOVF   x0C,W
3E70:  MOVLB  4
3E72:  SUBWF  x20,W
3E74:  BTFSS  FD8.0
3E76:  BRA    3E7C
3E78:  MOVLB  2
3E7A:  BRA    3ECE
3E7C:  MOVLB  2
....................       if(mmcsd_write_data(start_addr + i, 0x20, clear_entry) != GOODEC) 
3E7E:  MOVLB  4
3E80:  MOVF   x20,W
3E82:  ADDWF  x22,W
3E84:  MOVWF  x26
3E86:  MOVF   x21,W
3E88:  ADDWFC x23,W
3E8A:  MOVWF  x27
3E8C:  MOVLW  00
3E8E:  ADDWFC x24,W
3E90:  MOVWF  x28
3E92:  MOVLW  00
3E94:  ADDWFC x25,W
3E96:  MOVWF  x29
3E98:  MOVWF  x2D
3E9A:  MOVFF  428,42C
3E9E:  MOVFF  427,42B
3EA2:  MOVFF  426,42A
3EA6:  CLRF   x2F
3EA8:  MOVLW  20
3EAA:  MOVWF  x2E
3EAC:  MOVLW  03
3EAE:  MOVWF  x31
3EB0:  SETF   x30
3EB2:  MOVLB  0
3EB4:  RCALL  3A60
3EB6:  MOVF   01,F
3EB8:  BZ    3EC0
....................          return EOF; 
3EBA:  MOVLW  FF
3EBC:  MOVWF  01
3EBE:  BRA    3ED4
3EC0:  MOVLW  20
3EC2:  MOVLB  4
3EC4:  ADDWF  x20,F
3EC6:  MOVLW  00
3EC8:  ADDWFC x21,F
3ECA:  BRA    3E64
3ECC:  MOVLB  2
....................  
....................    return GOODEC; 
3ECE:  MOVLW  00
3ED0:  MOVWF  01
3ED2:  MOVLB  0
3ED4:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... Summary: Writes specified data about a cluster to the FAT. 
.................... Param cluster: The cluster to modify the in the FAT. 
.................... Param data: The data about the cluster to put into the FAT. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 2) + FAT_Start, 4, &data) != GOODEC) 
*
3AE6:  MOVLB  3
3AE8:  RLCF   xFB,W
3AEA:  MOVLB  4
3AEC:  MOVWF  x04
3AEE:  MOVLB  3
3AF0:  RLCF   xFC,W
3AF2:  MOVLB  4
3AF4:  MOVWF  x05
3AF6:  MOVLB  3
3AF8:  RLCF   xFD,W
3AFA:  MOVLB  4
3AFC:  MOVWF  x06
3AFE:  MOVLB  3
3B00:  RLCF   xFE,W
3B02:  MOVLB  4
3B04:  MOVWF  x07
3B06:  RLCF   x04,F
3B08:  RLCF   x05,F
3B0A:  RLCF   x06,F
3B0C:  RLCF   x07,F
3B0E:  MOVLW  FC
3B10:  ANDWF  x04,F
3B12:  MOVLB  2
3B14:  MOVF   x0E,W
3B16:  MOVLB  4
3B18:  ADDWF  x04,F
3B1A:  MOVLB  2
3B1C:  MOVF   x0F,W
3B1E:  MOVLB  4
3B20:  ADDWFC x05,F
3B22:  MOVLB  2
3B24:  MOVF   x10,W
3B26:  MOVLB  4
3B28:  ADDWFC x06,F
3B2A:  MOVLB  2
3B2C:  MOVF   x11,W
3B2E:  MOVLB  4
3B30:  ADDWFC x07,F
3B32:  MOVFF  407,42D
3B36:  MOVFF  406,42C
3B3A:  MOVFF  405,42B
3B3E:  MOVFF  404,42A
3B42:  CLRF   x2F
3B44:  MOVLW  04
3B46:  MOVWF  x2E
3B48:  MOVLW  03
3B4A:  MOVWF  x31
3B4C:  SETF   x30
3B4E:  MOVLB  0
3B50:  RCALL  3A60
3B52:  MOVF   01,F
3B54:  BZ    3B5C
....................       return EOF; 
3B56:  MOVLW  FF
3B58:  MOVWF  01
3B5A:  BRA    3B60
....................  
....................    return GOODEC; 
3B5C:  MOVLW  00
3B5E:  MOVWF  01
3B60:  RETURN 0
.................... } 
.................... #else // FAT16 
.................... signed int write_fat(int16 cluster, int16 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 1) + FAT_Start, 2, &data) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
.................... #endif // #ifdef FAT32 
....................  
.................... /* 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... Summary: Reads from the buffer. 
.................... Param stream: The stream whose buffer to read from. 
.................... Param val: A pointer to a varaible to put the read data into. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... { 
....................    int i;    // counter for loops 
....................  
....................    // check to see if we need to populate the buffer 
....................    if((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................    { 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
....................       { 
....................          stream->Flags |= Read_Error; 
....................          return EOF; 
....................       } 
....................    } 
....................  
....................    // grab the value at the top of the buffer 
....................    *val = stream->Buf[0]; 
....................  
....................    // shift everything over 1 byte to put a new value at the top of the buffer 
....................    for(i = 0; i < 8; i += 1) 
....................       rotate_right(stream->Buf, STREAM_BUF_SIZE); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int write_buffer(FILE* stream, int val) 
.................... Summary: Writes to the buffer. 
.................... Param stream: The stream whose buffer to write to. 
.................... Param val: A variable to write to the buffer. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int write_buffer(FILE* stream, int val) 
.................... { 
....................    // check to see if we should dump the buffer to the card 
....................    if(((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................       && (stream->Cur_Char != stream->Start_Addr)) 
*
3ED6:  MOVLW  04
3ED8:  MOVLB  3
3EDA:  ADDWF  xE7,W
3EDC:  MOVWF  FE9
3EDE:  MOVLW  00
3EE0:  ADDWFC xE8,W
3EE2:  MOVWF  FEA
3EE4:  MOVFF  FEF,3EA
3EE8:  MOVFF  FEC,3EB
3EEC:  MOVFF  FEC,3EC
3EF0:  MOVFF  FEC,3ED
3EF4:  MOVLW  1F
3EF6:  ANDWF  xEA,F
3EF8:  CLRF   xEB
3EFA:  CLRF   xEC
3EFC:  CLRF   xED
3EFE:  MOVF   xEA,F
3F00:  BTFSS  FD8.2
3F02:  BRA    3FDC
3F04:  MOVF   xEB,F
3F06:  BNZ   3FDC
3F08:  MOVF   xEC,F
3F0A:  BNZ   3FDC
3F0C:  MOVF   xED,F
3F0E:  BNZ   3FDC
3F10:  MOVLW  04
3F12:  ADDWF  xE7,W
3F14:  MOVWF  FE9
3F16:  MOVLW  00
3F18:  ADDWFC xE8,W
3F1A:  MOVWF  FEA
3F1C:  MOVFF  FEF,3EA
3F20:  MOVFF  FEC,3EB
3F24:  MOVFF  FEC,3EC
3F28:  MOVFF  FEC,3ED
3F2C:  MOVLW  14
3F2E:  ADDWF  xE7,W
3F30:  MOVWF  FE9
3F32:  MOVLW  00
3F34:  ADDWFC xE8,W
3F36:  MOVWF  FEA
3F38:  MOVFF  FEF,00
3F3C:  MOVFF  FEC,01
3F40:  MOVFF  FEC,02
3F44:  MOVFF  FEC,03
3F48:  MOVF   00,W
3F4A:  SUBWF  xEA,W
3F4C:  BNZ   3F60
3F4E:  MOVF   01,W
3F50:  SUBWF  xEB,W
3F52:  BNZ   3F60
3F54:  MOVF   02,W
3F56:  SUBWF  xEC,W
3F58:  BNZ   3F60
3F5A:  MOVF   03,W
3F5C:  SUBWF  xED,W
3F5E:  BZ    3FDC
....................    { 
....................       // dump the buffer to the card 
....................       if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
3F60:  MOVLW  04
3F62:  ADDWF  xE7,W
3F64:  MOVWF  FE9
3F66:  MOVLW  00
3F68:  ADDWFC xE8,W
3F6A:  MOVWF  FEA
3F6C:  MOVFF  FEF,3EA
3F70:  MOVFF  FEC,3EB
3F74:  MOVFF  FEC,3EC
3F78:  MOVFF  FEC,3ED
3F7C:  MOVLW  20
3F7E:  SUBWF  xEA,F
3F80:  MOVLW  00
3F82:  SUBWFB xEB,F
3F84:  SUBWFB xEC,F
3F86:  SUBWFB xED,F
3F88:  MOVLW  1A
3F8A:  ADDWF  xE7,W
3F8C:  MOVWF  01
3F8E:  MOVLW  00
3F90:  ADDWFC xE8,W
3F92:  MOVWF  03
3F94:  MOVFF  01,3EE
3F98:  MOVWF  xEF
3F9A:  MOVFF  3ED,42D
3F9E:  MOVFF  3EC,42C
3FA2:  MOVFF  3EB,42B
3FA6:  MOVFF  3EA,42A
3FAA:  MOVLB  4
3FAC:  CLRF   x2F
3FAE:  MOVLW  20
3FB0:  MOVWF  x2E
3FB2:  MOVFF  03,431
3FB6:  MOVFF  01,430
3FBA:  MOVLB  0
3FBC:  RCALL  3A60
3FBE:  MOVF   01,F
3FC0:  BZ    3FDE
....................       { 
....................          stream->Flags |= Write_Error; 
3FC2:  MOVLW  19
3FC4:  MOVLB  3
3FC6:  ADDWF  xE7,W
3FC8:  MOVWF  FE9
3FCA:  MOVLW  00
3FCC:  ADDWFC xE8,W
3FCE:  MOVWF  FEA
3FD0:  MOVF   FEF,W
3FD2:  IORLW  40
3FD4:  MOVWF  FEF
....................          return EOF; 
3FD6:  MOVLW  FF
3FD8:  MOVWF  01
3FDA:  BRA    402E
3FDC:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // fill up a byte on the buffer 
....................    stream->Buf[stream->Cur_Char % STREAM_BUF_SIZE] = val; 
3FDE:  MOVLW  04
3FE0:  MOVLB  3
3FE2:  ADDWF  xE7,W
3FE4:  MOVWF  FE9
3FE6:  MOVLW  00
3FE8:  ADDWFC xE8,W
3FEA:  MOVWF  FEA
3FEC:  MOVFF  FEF,3EA
3FF0:  MOVFF  FEC,3EB
3FF4:  MOVFF  FEC,3EC
3FF8:  MOVFF  FEC,3ED
3FFC:  MOVLW  1F
3FFE:  ANDWF  xEA,F
4000:  CLRF   xEB
4002:  CLRF   xEC
4004:  CLRF   xED
4006:  MOVLW  1A
4008:  ADDWF  xEA,W
400A:  MOVWF  00
400C:  MOVLW  00
400E:  ADDWFC xEB,W
4010:  MOVWF  01
4012:  MOVLW  00
4014:  ADDWFC xEC,W
4016:  MOVLW  00
4018:  ADDWFC xED,W
401A:  MOVF   xE7,W
401C:  ADDWF  00,W
401E:  MOVWF  FE9
4020:  MOVF   xE8,W
4022:  ADDWFC 01,W
4024:  MOVWF  FEA
4026:  MOVFF  3E9,FEF
....................  
....................    return GOODEC; 
402A:  MOVLW  00
402C:  MOVWF  01
402E:  MOVLB  0
4030:  GOTO   449E (RETURN)
.................... } 
....................  
.................... /* 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... Summary: This will fill up the unused spots in a standard FAT entry with a value. 
.................... Param the_entry[]: The entry that will be modified. 
.................... Param val: The value to fill the entry with. 
.................... Param start_ind: The beginning index to start filling the_entry. 
.................... Returns: Nothing. 
.................... */ 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = start_ind; i < 13; i += 1) 
....................    { 
....................       if(i < 5) 
....................       { 
....................          the_entry[(i << 1) + 1] = val; 
....................          the_entry[(i << 1) + 2] = val; 
....................       } 
....................  
....................       else if(i < 11) 
....................       { 
....................          the_entry[(i << 1) + 4] = val; 
....................          the_entry[(i << 1) + 5] = val; 
....................       } 
....................  
....................       else 
....................       { 
....................          the_entry[(i << 1) + 6] = val; 
....................          the_entry[(i << 1) + 7] = val; 
....................       } 
....................    } 
.................... } 
....................  
.................... /* 
.................... void disp_timestamp(int16 timestamp) 
.................... Summary: Parses an timestamp from a file entry and displays it to the console 
.................... Param: The 16-bit timestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_timestamp(int16 timestamp) 
.................... { 
....................    // Hours:Minutes:Seconds 
....................    printf("%lu:%lu:%lu", 
....................       timestamp >> 11, 
....................       (timestamp & 0x07E0) >> 5, 
....................       (timestamp & 0x001F) << 1); 
.................... } 
....................  
.................... /* 
.................... void disp_datestamp(int16 datestamp) 
.................... Summary: Parses an datestamp from a file entry and displays it to the console 
.................... Param: The 16-bit datestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_datestamp(int16 datestamp) 
.................... { 
....................    // Month/Day/Year 
....................    printf("%lu/%lu/%lu", 
....................       (datestamp & 0x01F0) >> 5, 
....................       datestamp & 0x001F, 
....................       (1980 + (datestamp >> 9))); 
.................... } 
....................  
.................... /// Data Utility Functions /// 
....................  
.................... /* 
.................... signed int fat_init() 
.................... Summary: Initializes global variables that are essential for this library working 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: This must be called before any other function calls in this library. 
.................... */ 
.................... signed int fat_init() 
*
2CC0:  MOVLB  3
2CC2:  CLRF   x36
.................... { 
....................    int ec = 0; 
....................  
....................    int 
....................       FATs, 
....................       Sectors_Per_Cluster; 
....................  
....................    int16 
....................       Bytes_Per_Sector, 
....................       Reserved_Sectors, 
....................       Small_Sectors; 
....................  
....................    int32 
....................       Hidden_Sectors, 
....................       Large_Sectors; 
....................  
.................... #ifdef FAT32 
....................    int32 Sectors_Per_FAT; 
.................... #else // FAT16 
....................    int16 
....................       Root_Entries, 
....................       Sectors_Per_FAT; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize the media 
....................    if(mmcsd_init() != GOODEC) 
2CC4:  MOVLB  0
2CC6:  BRA    27FC
2CC8:  MOVF   01,F
2CCA:  BZ    2CD2
....................        return EOF; 
2CCC:  MOVLW  FF
2CCE:  MOVWF  01
2CD0:  BRA    30FC
....................  
....................    // assume first sector is MBR 
....................    uint8_t  boot; 
....................    uint32_t offset_, total_sectors, first_sector; 
....................    ec += mmcsd_read_data(0x1BE, 1, &boot); 
2CD2:  MOVLB  4
2CD4:  CLRF   x19
2CD6:  CLRF   x18
2CD8:  MOVLW  01
2CDA:  MOVWF  x17
2CDC:  MOVLW  BE
2CDE:  MOVWF  x16
2CE0:  CLRF   x1B
2CE2:  MOVLW  01
2CE4:  MOVWF  x1A
2CE6:  MOVLW  03
2CE8:  MOVWF  x1D
2CEA:  MOVLW  4B
2CEC:  MOVWF  x1C
2CEE:  MOVLB  0
2CF0:  RCALL  2BB8
2CF2:  MOVF   01,W
2CF4:  MOVLB  3
2CF6:  ADDWF  x36,F
....................    ec += mmcsd_read_data(0x1C6, 4, &first_sector); 
2CF8:  MOVLB  4
2CFA:  CLRF   x19
2CFC:  CLRF   x18
2CFE:  MOVLW  01
2D00:  MOVWF  x17
2D02:  MOVLW  C6
2D04:  MOVWF  x16
2D06:  CLRF   x1B
2D08:  MOVLW  04
2D0A:  MOVWF  x1A
2D0C:  MOVLW  03
2D0E:  MOVWF  x1D
2D10:  MOVLW  54
2D12:  MOVWF  x1C
2D14:  MOVLB  0
2D16:  RCALL  2BB8
2D18:  MOVF   01,W
2D1A:  MOVLB  3
2D1C:  ADDWF  x36,F
....................    ec += mmcsd_read_data(0x1CA, 4, &total_sectors); 
2D1E:  MOVLB  4
2D20:  CLRF   x19
2D22:  CLRF   x18
2D24:  MOVLW  01
2D26:  MOVWF  x17
2D28:  MOVLW  CA
2D2A:  MOVWF  x16
2D2C:  CLRF   x1B
2D2E:  MOVLW  04
2D30:  MOVWF  x1A
2D32:  MOVLW  03
2D34:  MOVWF  x1D
2D36:  MOVLW  50
2D38:  MOVWF  x1C
2D3A:  MOVLB  0
2D3C:  RCALL  2BB8
2D3E:  MOVF   01,W
2D40:  MOVLB  3
2D42:  ADDWF  x36,F
....................    if( (boot & 0X7F) !=0  || (total_sectors < 100) || (first_sector == 0) ) 
2D44:  MOVF   x4B,W
2D46:  ANDLW  7F
2D48:  BNZ   2D6C
2D4A:  MOVF   x53,F
2D4C:  BNZ   2D5C
2D4E:  MOVF   x52,F
2D50:  BNZ   2D5C
2D52:  MOVF   x51,F
2D54:  BNZ   2D5C
2D56:  MOVF   x50,W
2D58:  SUBLW  63
2D5A:  BC    2D6C
2D5C:  MOVF   x54,F
2D5E:  BNZ   2D76
2D60:  MOVF   x55,F
2D62:  BNZ   2D76
2D64:  MOVF   x56,F
2D66:  BNZ   2D76
2D68:  MOVF   x57,F
2D6A:  BNZ   2D76
....................      offset_ = 0; 
2D6C:  CLRF   x4F
2D6E:  CLRF   x4E
2D70:  CLRF   x4D
2D72:  CLRF   x4C
2D74:  BRA    2D86
....................    else 
....................      offset_ = first_sector * MMCSD_MAX_BLOCK_SIZE; 
2D76:  BCF    FD8.0
2D78:  CLRF   x4C
2D7A:  RLCF   x54,W
2D7C:  MOVWF  x4D
2D7E:  RLCF   x55,W
2D80:  MOVWF  x4E
2D82:  RLCF   x56,W
2D84:  MOVWF  x4F
....................  
....................    // start filling up variables 
....................    ec += mmcsd_read_data(offset_ + 11, 2, &Bytes_Per_Sector); 
2D86:  MOVLW  0B
2D88:  ADDWF  x4C,W
2D8A:  MOVWF  x58
2D8C:  MOVLW  00
2D8E:  ADDWFC x4D,W
2D90:  MOVWF  x59
2D92:  MOVLW  00
2D94:  ADDWFC x4E,W
2D96:  MOVWF  x5A
2D98:  MOVLW  00
2D9A:  ADDWFC x4F,W
2D9C:  MOVWF  x5B
2D9E:  MOVFF  FE8,419
2DA2:  MOVFF  35A,418
2DA6:  MOVFF  359,417
2DAA:  MOVFF  358,416
2DAE:  MOVLB  4
2DB0:  CLRF   x1B
2DB2:  MOVLW  02
2DB4:  MOVWF  x1A
2DB6:  MOVLW  03
2DB8:  MOVWF  x1D
2DBA:  MOVLW  39
2DBC:  MOVWF  x1C
2DBE:  MOVLB  0
2DC0:  RCALL  2BB8
2DC2:  MOVF   01,W
2DC4:  MOVLB  3
2DC6:  ADDWF  x36,F
....................    ec += mmcsd_read_data(offset_ + 13, 1, &Sectors_Per_Cluster); 
2DC8:  MOVLW  0D
2DCA:  ADDWF  x4C,W
2DCC:  MOVWF  x58
2DCE:  MOVLW  00
2DD0:  ADDWFC x4D,W
2DD2:  MOVWF  x59
2DD4:  MOVLW  00
2DD6:  ADDWFC x4E,W
2DD8:  MOVWF  x5A
2DDA:  MOVLW  00
2DDC:  ADDWFC x4F,W
2DDE:  MOVWF  x5B
2DE0:  MOVFF  FE8,419
2DE4:  MOVFF  35A,418
2DE8:  MOVFF  359,417
2DEC:  MOVFF  358,416
2DF0:  MOVLB  4
2DF2:  CLRF   x1B
2DF4:  MOVLW  01
2DF6:  MOVWF  x1A
2DF8:  MOVLW  03
2DFA:  MOVWF  x1D
2DFC:  MOVLW  38
2DFE:  MOVWF  x1C
2E00:  MOVLB  0
2E02:  RCALL  2BB8
2E04:  MOVF   01,W
2E06:  MOVLB  3
2E08:  ADDWF  x36,F
....................    ec += mmcsd_read_data(offset_ + 14, 2, &Reserved_Sectors); 
2E0A:  MOVLW  0E
2E0C:  ADDWF  x4C,W
2E0E:  MOVWF  x58
2E10:  MOVLW  00
2E12:  ADDWFC x4D,W
2E14:  MOVWF  x59
2E16:  MOVLW  00
2E18:  ADDWFC x4E,W
2E1A:  MOVWF  x5A
2E1C:  MOVLW  00
2E1E:  ADDWFC x4F,W
2E20:  MOVWF  x5B
2E22:  MOVFF  FE8,419
2E26:  MOVFF  35A,418
2E2A:  MOVFF  359,417
2E2E:  MOVFF  358,416
2E32:  MOVLB  4
2E34:  CLRF   x1B
2E36:  MOVLW  02
2E38:  MOVWF  x1A
2E3A:  MOVLW  03
2E3C:  MOVWF  x1D
2E3E:  MOVLW  3B
2E40:  MOVWF  x1C
2E42:  MOVLB  0
2E44:  RCALL  2BB8
2E46:  MOVF   01,W
2E48:  MOVLB  3
2E4A:  ADDWF  x36,F
....................    ec += mmcsd_read_data(offset_ + 16, 1, &FATs); 
2E4C:  MOVLW  10
2E4E:  ADDWF  x4C,W
2E50:  MOVWF  x58
2E52:  MOVLW  00
2E54:  ADDWFC x4D,W
2E56:  MOVWF  x59
2E58:  MOVLW  00
2E5A:  ADDWFC x4E,W
2E5C:  MOVWF  x5A
2E5E:  MOVLW  00
2E60:  ADDWFC x4F,W
2E62:  MOVWF  x5B
2E64:  MOVFF  FE8,419
2E68:  MOVFF  35A,418
2E6C:  MOVFF  359,417
2E70:  MOVFF  358,416
2E74:  MOVLB  4
2E76:  CLRF   x1B
2E78:  MOVLW  01
2E7A:  MOVWF  x1A
2E7C:  MOVLW  03
2E7E:  MOVWF  x1D
2E80:  MOVLW  37
2E82:  MOVWF  x1C
2E84:  MOVLB  0
2E86:  RCALL  2BB8
2E88:  MOVF   01,W
2E8A:  MOVLB  3
2E8C:  ADDWF  x36,F
.................... #ifdef FAT16 
....................    ec += mmcsd_read_data(offset_ + 17, 2, &Root_Entries); 
.................... #endif // #ifdef FAT16 
....................    ec += mmcsd_read_data(offset_ + 19, 2, &Small_Sectors); 
2E8E:  MOVLW  13
2E90:  ADDWF  x4C,W
2E92:  MOVWF  x58
2E94:  MOVLW  00
2E96:  ADDWFC x4D,W
2E98:  MOVWF  x59
2E9A:  MOVLW  00
2E9C:  ADDWFC x4E,W
2E9E:  MOVWF  x5A
2EA0:  MOVLW  00
2EA2:  ADDWFC x4F,W
2EA4:  MOVWF  x5B
2EA6:  MOVFF  FE8,419
2EAA:  MOVFF  35A,418
2EAE:  MOVFF  359,417
2EB2:  MOVFF  358,416
2EB6:  MOVLB  4
2EB8:  CLRF   x1B
2EBA:  MOVLW  02
2EBC:  MOVWF  x1A
2EBE:  MOVLW  03
2EC0:  MOVWF  x1D
2EC2:  MOVLW  3D
2EC4:  MOVWF  x1C
2EC6:  MOVLB  0
2EC8:  RCALL  2BB8
2ECA:  MOVF   01,W
2ECC:  MOVLB  3
2ECE:  ADDWF  x36,F
.................... #ifdef FAT32 
....................    ec += mmcsd_read_data(offset_ + 36, 4, &Sectors_Per_FAT); 
2ED0:  MOVLW  24
2ED2:  ADDWF  x4C,W
2ED4:  MOVWF  x58
2ED6:  MOVLW  00
2ED8:  ADDWFC x4D,W
2EDA:  MOVWF  x59
2EDC:  MOVLW  00
2EDE:  ADDWFC x4E,W
2EE0:  MOVWF  x5A
2EE2:  MOVLW  00
2EE4:  ADDWFC x4F,W
2EE6:  MOVWF  x5B
2EE8:  MOVFF  FE8,419
2EEC:  MOVFF  35A,418
2EF0:  MOVFF  359,417
2EF4:  MOVFF  358,416
2EF8:  MOVLB  4
2EFA:  CLRF   x1B
2EFC:  MOVLW  04
2EFE:  MOVWF  x1A
2F00:  MOVLW  03
2F02:  MOVWF  x1D
2F04:  MOVLW  47
2F06:  MOVWF  x1C
2F08:  MOVLB  0
2F0A:  RCALL  2BB8
2F0C:  MOVF   01,W
2F0E:  MOVLB  3
2F10:  ADDWF  x36,F
.................... #else // FAT16 
....................    ec += mmcsd_read_data(offset_ + 22, 2, &Sectors_Per_FAT); 
.................... #endif // #ifdef FAT32 
....................    ec += mmcsd_read_data(offset_ + 28, 4, &Hidden_Sectors); 
2F12:  MOVLW  1C
2F14:  ADDWF  x4C,W
2F16:  MOVWF  x58
2F18:  MOVLW  00
2F1A:  ADDWFC x4D,W
2F1C:  MOVWF  x59
2F1E:  MOVLW  00
2F20:  ADDWFC x4E,W
2F22:  MOVWF  x5A
2F24:  MOVLW  00
2F26:  ADDWFC x4F,W
2F28:  MOVWF  x5B
2F2A:  MOVFF  FE8,419
2F2E:  MOVFF  35A,418
2F32:  MOVFF  359,417
2F36:  MOVFF  358,416
2F3A:  MOVLB  4
2F3C:  CLRF   x1B
2F3E:  MOVLW  04
2F40:  MOVWF  x1A
2F42:  MOVLW  03
2F44:  MOVWF  x1D
2F46:  MOVLW  3F
2F48:  MOVWF  x1C
2F4A:  MOVLB  0
2F4C:  RCALL  2BB8
2F4E:  MOVF   01,W
2F50:  MOVLB  3
2F52:  ADDWF  x36,F
....................    ec += mmcsd_read_data(offset_ + 32, 4, &Large_Sectors); 
2F54:  MOVLW  20
2F56:  ADDWF  x4C,W
2F58:  MOVWF  x58
2F5A:  MOVLW  00
2F5C:  ADDWFC x4D,W
2F5E:  MOVWF  x59
2F60:  MOVLW  00
2F62:  ADDWFC x4E,W
2F64:  MOVWF  x5A
2F66:  MOVLW  00
2F68:  ADDWFC x4F,W
2F6A:  MOVWF  x5B
2F6C:  MOVFF  FE8,419
2F70:  MOVFF  35A,418
2F74:  MOVFF  359,417
2F78:  MOVFF  358,416
2F7C:  MOVLB  4
2F7E:  CLRF   x1B
2F80:  MOVLW  04
2F82:  MOVWF  x1A
2F84:  MOVLW  03
2F86:  MOVWF  x1D
2F88:  MOVLW  43
2F8A:  MOVWF  x1C
2F8C:  MOVLB  0
2F8E:  RCALL  2BB8
2F90:  MOVF   01,W
2F92:  MOVLB  3
2F94:  ADDWF  x36,F
.................... #ifdef FAT16 
....................    Next_Free_Clust = 2; 
.................... #else 
....................    ec += mmcsd_read_data(offset_ + 0x3EC, 4, &Next_Free_Clust); 
2F96:  MOVLW  EC
2F98:  ADDWF  x4C,W
2F9A:  MOVWF  x58
2F9C:  MOVLW  03
2F9E:  ADDWFC x4D,W
2FA0:  MOVWF  x59
2FA2:  MOVLW  00
2FA4:  ADDWFC x4E,W
2FA6:  MOVWF  x5A
2FA8:  MOVLW  00
2FAA:  ADDWFC x4F,W
2FAC:  MOVWF  x5B
2FAE:  MOVFF  FE8,419
2FB2:  MOVFF  35A,418
2FB6:  MOVFF  359,417
2FBA:  MOVFF  358,416
2FBE:  MOVLB  4
2FC0:  CLRF   x1B
2FC2:  MOVLW  04
2FC4:  MOVWF  x1A
2FC6:  MOVLW  02
2FC8:  MOVWF  x1D
2FCA:  MOVLW  1A
2FCC:  MOVWF  x1C
2FCE:  MOVLB  0
2FD0:  RCALL  2BB8
2FD2:  MOVF   01,W
2FD4:  MOVLB  3
2FD6:  ADDWF  x36,F
.................... #endif 
....................    if(ec != GOODEC) 
2FD8:  MOVF   x36,F
2FDA:  BZ    2FE6
....................       return EOF; 
2FDC:  MOVLW  FF
2FDE:  MOVWF  01
2FE0:  MOVLB  0
2FE2:  BRA    30FC
2FE4:  MOVLB  3
....................  
....................    // figure out the size of a cluster 
....................    Bytes_Per_Cluster = Sectors_Per_Cluster * Bytes_Per_Sector; 
2FE6:  CLRF   x59
2FE8:  MOVFF  338,358
2FEC:  MOVFF  33A,35B
2FF0:  MOVFF  339,35A
2FF4:  MOVLB  0
2FF6:  BRA    2C40
2FF8:  MOVFF  02,20D
2FFC:  MOVFF  01,20C
....................  
....................    // figure out how long one FAT is 
....................    FAT_Length = Sectors_Per_FAT * (int32)Bytes_Per_Sector; 
3000:  MOVFF  339,00
3004:  MOVFF  33A,01
3008:  CLRF   02
300A:  CLRF   03
300C:  MOVFF  03,35B
3010:  MOVFF  02,35A
3014:  MOVFF  33A,359
3018:  MOVFF  339,358
301C:  MOVFF  34A,431
3020:  MOVFF  349,430
3024:  MOVFF  348,42F
3028:  MOVFF  347,42E
302C:  MOVFF  03,435
3030:  MOVFF  02,434
3034:  MOVFF  33A,433
3038:  MOVFF  339,432
303C:  RCALL  2C64
303E:  MOVFF  03,219
3042:  MOVFF  02,218
3046:  MOVFF  01,217
304A:  MOVFF  00,216
....................  
....................    // figure out where the FAT starts 
....................    FAT_Start = offset_ + (int32)Reserved_Sectors * Bytes_Per_Sector; 
304E:  MOVLB  3
3050:  CLRF   x5B
3052:  CLRF   x5A
3054:  MOVFF  33C,359
3058:  MOVFF  33B,358
305C:  MOVFF  35B,431
3060:  MOVFF  35A,430
3064:  MOVFF  33C,42F
3068:  MOVFF  33B,42E
306C:  MOVLB  4
306E:  CLRF   x35
3070:  CLRF   x34
3072:  MOVFF  33A,433
3076:  MOVFF  339,432
307A:  MOVLB  0
307C:  RCALL  2C64
307E:  MOVF   00,W
3080:  MOVLB  3
3082:  ADDWF  x4C,W
3084:  MOVLB  2
3086:  MOVWF  x0E
3088:  MOVF   01,W
308A:  MOVLB  3
308C:  ADDWFC x4D,W
308E:  MOVLB  2
3090:  MOVWF  x0F
3092:  MOVF   02,W
3094:  MOVLB  3
3096:  ADDWFC x4E,W
3098:  MOVLB  2
309A:  MOVWF  x10
309C:  MOVF   03,W
309E:  MOVLB  3
30A0:  ADDWFC x4F,W
30A2:  MOVLB  2
30A4:  MOVWF  x11
....................  
....................    // figure out where the root directory starts 
....................    Root_Dir = FAT_Start + (FATs * FAT_Length); 
30A6:  MOVLB  4
30A8:  CLRF   x31
30AA:  CLRF   x30
30AC:  CLRF   x2F
30AE:  MOVFF  337,42E
30B2:  MOVFF  219,435
30B6:  MOVFF  218,434
30BA:  MOVFF  217,433
30BE:  MOVFF  216,432
30C2:  MOVLB  0
30C4:  RCALL  2C64
30C6:  MOVF   00,W
30C8:  MOVLB  2
30CA:  ADDWF  x0E,W
30CC:  MOVWF  x1E
30CE:  MOVF   01,W
30D0:  ADDWFC x0F,W
30D2:  MOVWF  x1F
30D4:  MOVF   02,W
30D6:  ADDWFC x10,W
30D8:  MOVWF  x20
30DA:  MOVF   03,W
30DC:  ADDWFC x11,W
30DE:  MOVWF  x21
....................  
....................    // figure out where data for files in the root directory starts 
.................... #ifdef FAT32 
....................    Data_Start = Bytes_Per_Cluster + Root_Dir; 
30E0:  MOVF   x0C,W
30E2:  ADDWF  x1E,W
30E4:  MOVWF  x12
30E6:  MOVF   x0D,W
30E8:  ADDWFC x1F,W
30EA:  MOVWF  x13
30EC:  MOVLW  00
30EE:  ADDWFC x20,W
30F0:  MOVWF  x14
30F2:  MOVLW  00
30F4:  ADDWFC x21,W
30F6:  MOVWF  x15
.................... #else // FAT16 
....................    Data_Start = offset_ + (Root_Entries * 0x20) + (Bytes_Per_Sector - 1); 
....................    Data_Start /= Bytes_Per_Sector; 
....................    Data_Start += Reserved_Sectors + (FATs * Sectors_Per_FAT); 
....................    Data_Start *= Bytes_Per_Sector; 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
30F8:  MOVLW  00
30FA:  MOVWF  01
30FC:  MOVLB  0
30FE:  GOTO   311C (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... Summary: Gets the next linked cluster from the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the next linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
....................    // convert the current cluster into the address of where information about 
....................    //  the cluster is stored in the FAT, and put this value into the current cluster 
.................... #ifdef FAT32 
....................    if(mmcsd_read_data((*my_cluster << 2) + FAT_Start, 4, my_cluster) != GOODEC) 
*
398A:  MOVFF  3F0,03
398E:  MOVLB  3
3990:  MOVFF  3EF,FE9
3994:  MOVFF  3F0,FEA
3998:  MOVFF  FEF,3F1
399C:  MOVFF  FEC,3F2
39A0:  MOVFF  FEC,3F3
39A4:  MOVFF  FEC,3F4
39A8:  RLCF   xF1,F
39AA:  RLCF   xF2,F
39AC:  RLCF   xF3,F
39AE:  RLCF   xF4,F
39B0:  RLCF   xF1,F
39B2:  RLCF   xF2,F
39B4:  RLCF   xF3,F
39B6:  RLCF   xF4,F
39B8:  MOVLW  FC
39BA:  ANDWF  xF1,F
39BC:  MOVLB  2
39BE:  MOVF   x0E,W
39C0:  MOVLB  3
39C2:  ADDWF  xF1,F
39C4:  MOVLB  2
39C6:  MOVF   x0F,W
39C8:  MOVLB  3
39CA:  ADDWFC xF2,F
39CC:  MOVLB  2
39CE:  MOVF   x10,W
39D0:  MOVLB  3
39D2:  ADDWFC xF3,F
39D4:  MOVLB  2
39D6:  MOVF   x11,W
39D8:  MOVLB  3
39DA:  ADDWFC xF4,F
39DC:  MOVFF  3F4,419
39E0:  MOVFF  3F3,418
39E4:  MOVFF  3F2,417
39E8:  MOVFF  3F1,416
39EC:  MOVLB  4
39EE:  CLRF   x1B
39F0:  MOVLW  04
39F2:  MOVWF  x1A
39F4:  MOVFF  3F0,41D
39F8:  MOVFF  3EF,41C
39FC:  MOVLB  0
39FE:  CALL   2BB8
3A02:  MOVF   01,F
3A04:  BZ    3A0C
....................       return EOF; 
3A06:  MOVLW  FF
3A08:  MOVWF  01
3A0A:  BRA    3A10
.................... #else // FAT16 
....................    if(mmcsd_read_data((*my_cluster << 1) + FAT_Start, 2, my_cluster) != GOODEC) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................    return GOODEC; 
3A0C:  MOVLW  00
3A0E:  MOVWF  01
3A10:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... Summary: Gets the previously linked cluster in the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the previous linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... #else 
*
339E:  MOVLB  3
33A0:  CLRF   xF5
33A2:  CLRF   xF4
33A4:  CLRF   xF3
33A6:  MOVLW  01
33A8:  MOVWF  xF2
33AA:  CLRF   xF9
33AC:  CLRF   xF8
33AE:  CLRF   xF7
33B0:  CLRF   xF6
.................... signed int get_prev_cluster(int16* my_cluster) 
.................... #endif // #ifdef FAT32 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #else 
....................    int16 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #endif // #ifdef FAT32 
....................     
....................    while(target_cluster != *my_cluster) 
33B2:  MOVFF  3F0,FE9
33B6:  MOVFF  3F1,FEA
33BA:  MOVFF  FEF,00
33BE:  MOVFF  FEC,01
33C2:  MOVFF  FEC,02
33C6:  MOVFF  FEC,03
33CA:  MOVF   00,W
33CC:  SUBWF  xF6,W
33CE:  BNZ   33E2
33D0:  MOVF   01,W
33D2:  SUBWF  xF7,W
33D4:  BNZ   33E2
33D6:  MOVF   02,W
33D8:  SUBWF  xF8,W
33DA:  BNZ   33E2
33DC:  MOVF   03,W
33DE:  SUBWF  xF9,W
33E0:  BZ    345E
....................    {    
....................       cur_cluster += 1; 
33E2:  MOVLW  01
33E4:  ADDWF  xF2,F
33E6:  MOVLW  00
33E8:  ADDWFC xF3,F
33EA:  ADDWFC xF4,F
33EC:  ADDWFC xF5,F
.................... #ifdef FAT32 
....................       if(mmcsd_read_data((cur_cluster << 2) + FAT_Start, 4, &target_cluster) != GOODEC) 
33EE:  RLCF   xF2,W
33F0:  MOVWF  xFB
33F2:  RLCF   xF3,W
33F4:  MOVWF  xFC
33F6:  RLCF   xF4,W
33F8:  MOVWF  xFD
33FA:  RLCF   xF5,W
33FC:  MOVWF  xFE
33FE:  RLCF   xFB,F
3400:  RLCF   xFC,F
3402:  RLCF   xFD,F
3404:  RLCF   xFE,F
3406:  MOVLW  FC
3408:  ANDWF  xFB,F
340A:  MOVLB  2
340C:  MOVF   x0E,W
340E:  MOVLB  3
3410:  ADDWF  xFB,F
3412:  MOVLB  2
3414:  MOVF   x0F,W
3416:  MOVLB  3
3418:  ADDWFC xFC,F
341A:  MOVLB  2
341C:  MOVF   x10,W
341E:  MOVLB  3
3420:  ADDWFC xFD,F
3422:  MOVLB  2
3424:  MOVF   x11,W
3426:  MOVLB  3
3428:  ADDWFC xFE,F
342A:  MOVFF  3FE,419
342E:  MOVFF  3FD,418
3432:  MOVFF  3FC,417
3436:  MOVFF  3FB,416
343A:  MOVLB  4
343C:  CLRF   x1B
343E:  MOVLW  04
3440:  MOVWF  x1A
3442:  MOVLW  03
3444:  MOVWF  x1D
3446:  MOVLW  F6
3448:  MOVWF  x1C
344A:  MOVLB  0
344C:  CALL   2BB8
3450:  MOVF   01,F
3452:  BZ    345A
....................          return EOF; 
3454:  MOVLW  FF
3456:  MOVWF  01
3458:  BRA    347A
.................... #else // FAT16 
345A:  MOVLB  3
345C:  BRA    33B2
....................       if(mmcsd_read_data((cur_cluster << 1) + FAT_Start, 2, &target_cluster) != GOODEC) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................    } 
....................     
.................... #ifdef FAT32 
....................    *my_cluster = cur_cluster;                         
345E:  MOVFF  3F0,FE9
3462:  MOVFF  3F1,FEA
3466:  MOVFF  3F2,FEF
346A:  MOVFF  3F3,FEC
346E:  MOVFF  3F4,FEC
3472:  MOVFF  3F5,FEC
.................... #else // FAT16 
....................    *my_cluster = cur_cluster; 
.................... #endif // #ifdef FAT32    
....................     
....................    return GOODEC; 
3476:  MOVLW  00
3478:  MOVWF  01
347A:  MOVLB  0
347C:  GOTO   366C (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... //#ifdef FAT32 
.................... //   if((*my_addr + 1) % Bytes_Per_Cluster == 0) 
.................... //#else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if((((*my_addr + 1) - Data_Start) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
*
4034:  MOVFF  3EA,03
4038:  MOVLB  3
403A:  MOVFF  3E9,FE9
403E:  MOVFF  3EA,FEA
4042:  MOVFF  FEF,3EF
4046:  MOVFF  FEC,3F0
404A:  MOVFF  FEC,3F1
404E:  MOVFF  FEC,3F2
4052:  MOVLW  01
4054:  ADDWF  xEF,F
4056:  MOVLW  00
4058:  ADDWFC xF0,F
405A:  ADDWFC xF1,F
405C:  ADDWFC xF2,F
405E:  MOVLB  2
4060:  MOVF   x12,W
4062:  MOVLB  3
4064:  SUBWF  xEF,F
4066:  MOVLB  2
4068:  MOVF   x13,W
406A:  MOVLB  3
406C:  SUBWFB xF0,F
406E:  MOVLB  2
4070:  MOVF   x14,W
4072:  MOVLB  3
4074:  SUBWFB xF1,F
4076:  MOVLB  2
4078:  MOVF   x15,W
407A:  MOVLB  3
407C:  SUBWFB xF2,F
407E:  MOVFF  FEA,3F4
4082:  MOVFF  FE9,3F3
4086:  BSF    FD8.1
4088:  MOVLW  03
408A:  MOVWF  FEA
408C:  MOVLW  F5
408E:  MOVWF  FE9
4090:  MOVFF  3F2,3FF
4094:  MOVFF  3F1,3FE
4098:  MOVFF  3F0,3FD
409C:  MOVFF  3EF,3FC
40A0:  MOVLB  4
40A2:  CLRF   x03
40A4:  CLRF   x02
40A6:  MOVFF  20D,401
40AA:  MOVFF  20C,400
40AE:  MOVLB  0
40B0:  CALL   0E8E
40B4:  MOVFF  3F5,00
40B8:  MOVFF  3F6,01
40BC:  MOVFF  3F7,02
40C0:  MOVFF  3F8,03
40C4:  MOVFF  3F4,FEA
40C8:  MOVFF  3F3,FE9
40CC:  MOVFF  3F8,3F2
40D0:  MOVFF  3F7,3F1
40D4:  MOVFF  3F6,3F0
40D8:  MOVFF  3F5,3EF
40DC:  MOVLB  3
40DE:  MOVF   xEF,F
40E0:  BTFSS  FD8.2
40E2:  BRA    41FE
40E4:  MOVF   xF0,F
40E6:  BTFSS  FD8.2
40E8:  BRA    41FE
40EA:  MOVF   xF1,F
40EC:  BTFSS  FD8.2
40EE:  BRA    41FE
40F0:  MOVF   xF2,F
40F2:  BTFSS  FD8.2
40F4:  BRA    41FE
40F6:  MOVFF  3EA,03
40FA:  MOVFF  3E9,FE9
40FE:  MOVFF  3EA,FEA
4102:  MOVFF  FEF,3EF
4106:  MOVFF  FEC,3F0
410A:  MOVFF  FEC,3F1
410E:  MOVFF  FEC,3F2
4112:  MOVLB  2
4114:  MOVF   x15,W
4116:  MOVLB  3
4118:  SUBWF  xF2,W
411A:  BTFSS  FD8.0
411C:  BRA    41FE
411E:  BNZ   4144
4120:  MOVLB  2
4122:  MOVF   x14,W
4124:  MOVLB  3
4126:  SUBWF  xF1,W
4128:  BTFSS  FD8.0
412A:  BRA    41FE
412C:  BNZ   4144
412E:  MOVLB  2
4130:  MOVF   x13,W
4132:  MOVLB  3
4134:  SUBWF  xF0,W
4136:  BNC   41FE
4138:  BNZ   4144
413A:  MOVLB  2
413C:  MOVF   x12,W
413E:  MOVLB  3
4140:  SUBWF  xEF,W
4142:  BNC   41FE
.................... //#endif // #ifdef FAT32 
....................    { 
....................       // convert the current address into the address of where information about 
....................       //  the address is stored in the FAT, and put this value into the current address 
....................       temp = addr_to_cluster(*my_addr); 
4144:  MOVFF  3EA,03
4148:  MOVFF  3E9,FE9
414C:  MOVFF  3EA,FEA
4150:  MOVFF  FEF,3F4
4154:  MOVFF  FEC,3F5
4158:  MOVFF  FEC,3F6
415C:  MOVFF  FEC,3F7
4160:  MOVLB  0
4162:  CALL   3324
4166:  MOVFF  03,3EE
416A:  MOVFF  02,3ED
416E:  MOVFF  01,3EC
4172:  MOVFF  00,3EB
....................       if(get_next_cluster(&temp) == EOF) 
4176:  MOVLW  03
4178:  MOVLB  3
417A:  MOVWF  xF0
417C:  MOVLW  EB
417E:  MOVWF  xEF
4180:  MOVLB  0
4182:  RCALL  398A
4184:  MOVF   01,W
4186:  SUBLW  FF
4188:  BNZ   4190
....................          return EOF; 
418A:  MOVLW  FF
418C:  MOVWF  01
418E:  BRA    4238
.................... #ifdef FAT32 
....................       if((temp == 0xFFFFFFFF) 
....................          || (temp == 0x0FFFFFFF)) // WinXP will format the root directory's FAT entry to 0x0FFFFFFF. 
4190:  MOVLB  3
4192:  INCFSZ xEB,W
4194:  BRA    41A4
4196:  INCFSZ xEC,W
4198:  BRA    41A4
419A:  INCFSZ xED,W
419C:  BRA    41A4
419E:  INCFSZ xEE,W
41A0:  BRA    41A4
41A2:  BRA    41B6
41A4:  INCFSZ xEB,W
41A6:  BRA    41C0
41A8:  INCFSZ xEC,W
41AA:  BRA    41C0
41AC:  INCFSZ xED,W
41AE:  BRA    41C0
41B0:  MOVF   xEE,W
41B2:  SUBLW  0F
41B4:  BNZ   41C0
....................          return EOF; 
41B6:  MOVLW  FF
41B8:  MOVWF  01
41BA:  MOVLB  0
41BC:  BRA    4238
41BE:  MOVLB  3
.................... #else // FAT16 
....................       if(temp == 0xFFFF) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................       *my_addr = cluster_to_addr(temp); 
41C0:  MOVFF  3EA,03
41C4:  MOVFF  3E9,3EF
41C8:  MOVFF  3EA,3F0
41CC:  MOVFF  3EE,429
41D0:  MOVFF  3ED,428
41D4:  MOVFF  3EC,427
41D8:  MOVFF  3EB,426
41DC:  MOVLB  0
41DE:  CALL   3480
41E2:  MOVFF  3F0,FEA
41E6:  MOVFF  3EF,FE9
41EA:  MOVFF  00,FEF
41EE:  MOVFF  01,FEC
41F2:  MOVFF  02,FEC
41F6:  MOVFF  03,FEC
....................    } 
41FA:  BRA    4234
41FC:  MOVLB  3
....................    else 
....................       *my_addr += 1; 
41FE:  MOVFF  3E9,FE9
4202:  MOVFF  3EA,FEA
4206:  MOVLW  01
4208:  ADDWF  FEF,W
420A:  MOVWF  00
420C:  MOVLW  00
420E:  ADDWFC FEC,W
4210:  MOVWF  01
4212:  MOVLW  00
4214:  ADDWFC FEC,W
4216:  MOVWF  02
4218:  MOVLW  00
421A:  ADDWFC FEC,W
421C:  MOVWF  03
421E:  MOVF   FED,F
4220:  MOVF   FED,F
4222:  MOVF   FED,F
4224:  MOVFF  00,FEF
4228:  MOVFF  01,FEC
422C:  MOVFF  02,FEC
4230:  MOVWF  FEC
4232:  MOVLB  0
....................  
....................    return GOODEC; 
4234:  MOVLW  00
4236:  MOVWF  01
4238:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're trying to go backwards one entry from the beginning of the root, 
....................    //  we won't be able to... 
....................    if(*my_addr <= Root_Dir) 
*
34DE:  MOVFF  3EB,03
34E2:  MOVLB  3
34E4:  MOVFF  3EA,FE9
34E8:  MOVFF  3EB,FEA
34EC:  MOVFF  FEF,3F0
34F0:  MOVFF  FEC,3F1
34F4:  MOVFF  FEC,3F2
34F8:  MOVFF  FEC,3F3
34FC:  MOVF   xF3,W
34FE:  MOVLB  2
3500:  SUBWF  x21,W
3502:  BNC   352E
3504:  BNZ   3528
3506:  MOVLB  3
3508:  MOVF   xF2,W
350A:  MOVLB  2
350C:  SUBWF  x20,W
350E:  BNC   352E
3510:  BNZ   3528
3512:  MOVLB  3
3514:  MOVF   xF1,W
3516:  MOVLB  2
3518:  SUBWF  x1F,W
351A:  BNC   352E
351C:  BNZ   3528
351E:  MOVLB  3
3520:  MOVF   xF0,W
3522:  MOVLB  2
3524:  SUBWF  x1E,W
3526:  BNC   352E
....................       return GOODEC; 
3528:  MOVLW  00
352A:  MOVWF  01
352C:  BRA    3722
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... //#ifdef FAT32 
.................... //   if(*my_addr % Bytes_Per_Cluster == 0) 
.................... //#else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if(( ( *my_addr - Data_Start ) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
352E:  MOVFF  3EB,03
3532:  MOVFF  3EA,FE9
3536:  MOVFF  3EB,FEA
353A:  MOVFF  FEF,3F0
353E:  MOVFF  FEC,3F1
3542:  MOVFF  FEC,3F2
3546:  MOVFF  FEC,3F3
354A:  MOVLB  2
354C:  MOVF   x12,W
354E:  MOVLB  3
3550:  SUBWF  xF0,F
3552:  MOVLB  2
3554:  MOVF   x13,W
3556:  MOVLB  3
3558:  SUBWFB xF1,F
355A:  MOVLB  2
355C:  MOVF   x14,W
355E:  MOVLB  3
3560:  SUBWFB xF2,F
3562:  MOVLB  2
3564:  MOVF   x15,W
3566:  MOVLB  3
3568:  SUBWFB xF3,F
356A:  MOVFF  FEA,3F5
356E:  MOVFF  FE9,3F4
3572:  BSF    FD8.1
3574:  MOVLW  03
3576:  MOVWF  FEA
3578:  MOVLW  F6
357A:  MOVWF  FE9
357C:  MOVFF  3F3,3FF
3580:  MOVFF  3F2,3FE
3584:  MOVFF  3F1,3FD
3588:  MOVFF  3F0,3FC
358C:  MOVLB  4
358E:  CLRF   x03
3590:  CLRF   x02
3592:  MOVFF  20D,401
3596:  MOVFF  20C,400
359A:  MOVLB  0
359C:  CALL   0E8E
35A0:  MOVFF  3F6,00
35A4:  MOVFF  3F7,01
35A8:  MOVFF  3F8,02
35AC:  MOVFF  3F9,03
35B0:  MOVFF  3F5,FEA
35B4:  MOVFF  3F4,FE9
35B8:  MOVFF  3F9,3F3
35BC:  MOVFF  3F8,3F2
35C0:  MOVFF  3F7,3F1
35C4:  MOVFF  3F6,3F0
35C8:  MOVLB  3
35CA:  MOVF   xF0,F
35CC:  BTFSS  FD8.2
35CE:  BRA    36EA
35D0:  MOVF   xF1,F
35D2:  BTFSS  FD8.2
35D4:  BRA    36EA
35D6:  MOVF   xF2,F
35D8:  BTFSS  FD8.2
35DA:  BRA    36EA
35DC:  MOVF   xF3,F
35DE:  BTFSS  FD8.2
35E0:  BRA    36EA
35E2:  MOVFF  3EB,03
35E6:  MOVFF  3EA,FE9
35EA:  MOVFF  3EB,FEA
35EE:  MOVFF  FEF,3F0
35F2:  MOVFF  FEC,3F1
35F6:  MOVFF  FEC,3F2
35FA:  MOVFF  FEC,3F3
35FE:  MOVLB  2
3600:  MOVF   x15,W
3602:  MOVLB  3
3604:  SUBWF  xF3,W
3606:  BTFSS  FD8.0
3608:  BRA    36EA
360A:  BNZ   362E
360C:  MOVLB  2
360E:  MOVF   x14,W
3610:  MOVLB  3
3612:  SUBWF  xF2,W
3614:  BNC   36EA
3616:  BNZ   362E
3618:  MOVLB  2
361A:  MOVF   x13,W
361C:  MOVLB  3
361E:  SUBWF  xF1,W
3620:  BNC   36EA
3622:  BNZ   362E
3624:  MOVLB  2
3626:  MOVF   x12,W
3628:  MOVLB  3
362A:  SUBWF  xF0,W
362C:  BNC   36EA
.................... //#endif // #ifdef FAT32 
....................    { 
....................       temp = addr_to_cluster(*my_addr); 
362E:  MOVFF  3EB,03
3632:  MOVFF  3EA,FE9
3636:  MOVFF  3EB,FEA
363A:  MOVFF  FEF,3F4
363E:  MOVFF  FEC,3F5
3642:  MOVFF  FEC,3F6
3646:  MOVFF  FEC,3F7
364A:  MOVLB  0
364C:  RCALL  3324
364E:  MOVFF  03,3EF
3652:  MOVFF  02,3EE
3656:  MOVFF  01,3ED
365A:  MOVFF  00,3EC
....................       if(get_prev_cluster(&temp) == EOF) 
365E:  MOVLW  03
3660:  MOVLB  3
3662:  MOVWF  xF1
3664:  MOVLW  EC
3666:  MOVWF  xF0
3668:  MOVLB  0
366A:  BRA    339E
366C:  MOVF   01,W
366E:  SUBLW  FF
3670:  BNZ   367C
....................          return EOF; 
3672:  MOVLW  FF
3674:  MOVWF  01
3676:  MOVLB  2
3678:  BRA    3722
367A:  MOVLB  0
....................  
....................       *my_addr = cluster_to_addr(temp) + (Bytes_Per_Cluster - 1); 
367C:  MOVFF  3EB,03
3680:  MOVFF  3EA,3F0
3684:  MOVFF  3EB,3F1
3688:  MOVFF  3EF,429
368C:  MOVFF  3EE,428
3690:  MOVFF  3ED,427
3694:  MOVFF  3EC,426
3698:  MOVLB  0
369A:  RCALL  3480
369C:  MOVFF  03,3F5
36A0:  MOVFF  02,3F4
36A4:  MOVFF  01,3F3
36A8:  MOVFF  00,3F2
36AC:  MOVLW  01
36AE:  MOVLB  2
36B0:  SUBWF  x0C,W
36B2:  MOVWF  00
36B4:  MOVLW  00
36B6:  SUBWFB x0D,W
36B8:  MOVWF  03
36BA:  MOVF   00,W
36BC:  MOVLB  3
36BE:  ADDWF  xF2,W
36C0:  MOVWF  00
36C2:  MOVF   03,W
36C4:  ADDWFC 01,W
36C6:  MOVWF  01
36C8:  MOVLW  00
36CA:  ADDWFC 02,W
36CC:  MOVWF  02
36CE:  MOVLW  00
36D0:  ADDWFC xF5,W
36D2:  MOVFF  3F1,FEA
36D6:  MOVFF  3F0,FE9
36DA:  MOVFF  00,FEF
36DE:  MOVFF  01,FEC
36E2:  MOVFF  02,FEC
36E6:  MOVWF  FEC
....................    } 
36E8:  BRA    371C
....................    else 
....................       *my_addr -= 1; 
36EA:  MOVFF  3EA,FE9
36EE:  MOVFF  3EB,FEA
36F2:  MOVLW  01
36F4:  SUBWF  FEF,W
36F6:  MOVWF  00
36F8:  MOVLW  00
36FA:  SUBWFB FEC,W
36FC:  MOVWF  01
36FE:  MOVLW  00
3700:  SUBWFB FEC,W
3702:  MOVWF  02
3704:  MOVLW  00
3706:  SUBWFB FEC,W
3708:  MOVF   FED,F
370A:  MOVF   FED,F
370C:  MOVF   FED,F
370E:  MOVFF  00,FEF
3712:  MOVFF  01,FEC
3716:  MOVFF  02,FEC
371A:  MOVWF  FEC
....................  
....................    return GOODEC; 
371C:  MOVLW  00
371E:  MOVWF  01
3720:  MOVLB  2
3722:  MOVLB  0
3724:  GOTO   375A (RETURN)
.................... } 
....................  
.................... /* 
.................... int32 cluster_to_addr(int32 cluster) 
.................... Summary: Converts a cluster number to an address. 
.................... Param: The cluster to convert. 
.................... Returns: The cluster's address. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 cluster_to_addr(int32 cluster) 
.................... { 
....................    // in unit math: 
....................    //  return  Bytes+(Bytes  /  Cluster * (Clusters - Clusters)) 
....................    return Root_Dir + (Bytes_Per_Cluster * (cluster - 2)); 
*
3480:  MOVLW  02
3482:  MOVLB  4
3484:  SUBWF  x26,W
3486:  MOVWF  00
3488:  MOVLW  00
348A:  SUBWFB x27,W
348C:  MOVWF  01
348E:  MOVLW  00
3490:  SUBWFB x28,W
3492:  MOVWF  02
3494:  MOVLW  00
3496:  SUBWFB x29,W
3498:  MOVWF  03
349A:  MOVWF  x2D
349C:  MOVFF  02,42C
34A0:  MOVFF  01,42B
34A4:  MOVFF  00,42A
34A8:  CLRF   x31
34AA:  CLRF   x30
34AC:  MOVFF  20D,42F
34B0:  MOVFF  20C,42E
34B4:  MOVWF  x35
34B6:  MOVFF  02,434
34BA:  MOVFF  01,433
34BE:  MOVFF  00,432
34C2:  MOVLB  0
34C4:  CALL   2C64
34C8:  MOVLB  2
34CA:  MOVF   x1E,W
34CC:  ADDWF  00,F
34CE:  MOVF   x1F,W
34D0:  ADDWFC 01,F
34D2:  MOVF   x20,W
34D4:  ADDWFC 02,F
34D6:  MOVF   x21,W
34D8:  ADDWFC 03,F
34DA:  MOVLB  0
34DC:  RETURN 0
.................... } 
.................... #else 
.................... int32 cluster_to_addr(int16 cluster) 
.................... { 
....................    if(cluster < 2) 
....................       return 0; 
....................    // in unit math: 
....................    //  return  Bytes + (       Bytes  /  Cluster * (Clusters- Clusters)) 
....................    return Data_Start + ((int32)Bytes_Per_Cluster * (cluster - 2)); 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... int32 addr_to_cluster(int32 addr) 
.................... Summary: Converts an address to a cluster number. 
.................... Param: The address to convert. 
.................... Returns: The address's cluster. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 addr_to_cluster(int32 addr) 
.................... { 
....................    // in unit math: 
....................    //  return (Bytes -Bytes) / Bytes  /  Cluster) + Clusters 
....................    return ((addr - Root_Dir) / Bytes_Per_Cluster) + 2; 
*
3324:  MOVLB  2
3326:  MOVF   x1E,W
3328:  MOVLB  3
332A:  SUBWF  xF4,W
332C:  MOVWF  xF8
332E:  MOVLB  2
3330:  MOVF   x1F,W
3332:  MOVLB  3
3334:  SUBWFB xF5,W
3336:  MOVWF  xF9
3338:  MOVLB  2
333A:  MOVF   x20,W
333C:  MOVLB  3
333E:  SUBWFB xF6,W
3340:  MOVWF  xFA
3342:  MOVLB  2
3344:  MOVF   x21,W
3346:  MOVLB  3
3348:  SUBWFB xF7,W
334A:  MOVWF  xFB
334C:  BCF    FD8.1
334E:  MOVWF  xFF
3350:  MOVFF  3FA,3FE
3354:  MOVFF  3F9,3FD
3358:  MOVFF  3F8,3FC
335C:  MOVLB  4
335E:  CLRF   x03
3360:  CLRF   x02
3362:  MOVFF  20D,401
3366:  MOVFF  20C,400
336A:  MOVLB  0
336C:  CALL   0E8E
3370:  MOVFF  03,3FB
3374:  MOVFF  02,3FA
3378:  MOVFF  01,3F9
337C:  MOVFF  00,3F8
3380:  MOVLW  02
3382:  MOVLB  3
3384:  ADDWF  00,W
3386:  MOVWF  00
3388:  MOVLW  00
338A:  ADDWFC 01,W
338C:  MOVWF  01
338E:  MOVLW  00
3390:  ADDWFC 02,W
3392:  MOVWF  02
3394:  MOVLW  00
3396:  ADDWFC 03,W
3398:  MOVWF  03
339A:  MOVLB  0
339C:  RETURN 0
.................... } 
.................... #else 
.................... int16 addr_to_cluster(int32 addr) 
.................... { 
....................    if(addr < Data_Start) 
....................       return 0; 
....................    // in unit math: 
....................    //  return (Bytes -Bytes)   /(Bytes  /  Cluster) + Clusters 
....................    return ((addr - Data_Start) / Bytes_Per_Cluster) + 2; 
.................... } 
.................... #endif 
.................... /* 
.................... signed int format(int32 DskSize) 
.................... Summary: Formats media with a FAT filesystem. 
.................... Param: The size of the filesystem to create in kB. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: There are certain minimum and maximum size restrictions on the card and type of file system. The restrictions are as follows: 
....................        FAT16: DskSize < 2GB 
....................        FAT32: 33MB < DskSize < 32GB 
....................        In order to change the way that the drive is formatted, select the proper #define(FAT16 or FAT32) way up at the top of this file. 
.................... Note: In this context, 1kB = 1024B = 2^10B. Please don't confuse this with 10^3B, we don't want to be wasting thousands of bytes of information now, do we? 
.................... Note: DskSize has a lower limit of 64, anything lower becomes highly inefficient and runs the risk of very quick corruption. 
.................... Note: If this is called on an MMC/SD card, Windows will recognize it as a RAW filesystem. 
.................... */ 
.................... signed int format(int32 DskSize) 
.................... { 
....................    int 
....................       BPB_Media = 0xF8, 
....................       BPB_NumFATs = 1, 
....................       BPB_NumHeads = 2, 
....................       BPB_SecPerClus, 
....................       BPB_SecPerTrk = 0x20; 
....................  
....................    int16 
....................       BPB_BytsPerSec = 0x200, 
....................       i; 
....................  
....................    int32 
....................       BPB_TotSec, 
....................       BS_VolID = 0, 
....................       RootDirSectors, 
....................       TmpVal1, 
....................       TmpVal2; 
....................  
....................    char                
....................       BS_OEMName[] = "MSDOS5.0", 
....................       BS_VolLab[] = "NO NAME    "; 
....................  
.................... #ifdef FAT32 
....................    int 
....................       BPB_BkBootSec = 6, 
....................       BPB_FSInfo = 1, 
....................       BPB_RootClus = 2, 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x58, 
....................       data[0x5A]; 
....................  
....................    int16 
....................       BPB_RootEntCnt = 0, 
....................       BPB_RsvdSecCnt = 32; 
....................     
....................    int32 BPB_FATSz; 
....................     
....................    char BS_FilSysType[] = "FAT32   "; 
.................... #else 
....................    int 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x3C, 
....................       data[0x3E]; 
....................        
....................    int16 
....................       BPB_FATSz, 
....................       BPB_RootEntCnt = 512, 
....................       BPB_RsvdSecCnt = 1; 
....................        
....................    char BS_FilSysType[] = "FAT12   "; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize variables 
....................    // figure out total sectors 
....................    BPB_TotSec = (DskSize * 0x400) / BPB_BytsPerSec; 
....................     
....................    // use the magical table on page 20 of fatgen103.pdf to determine sectors per cluster 
.................... #ifdef FAT32 
....................    if(DskSize < 0x8400) // < 33 MB; this is too small 
....................       return EOF; 
....................    else if(DskSize < 0x41000) // 260 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0X800000) // 8 GB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x1000000) // 16 GB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x2000000) // 32 GB 
....................       BPB_SecPerClus = 32; 
....................    else // > 32 GB; this is too big 
....................       return EOF; 
.................... #else 
....................    if(DskSize < 0x1400) // < 5 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0x4000) // 16 MB 
....................       BPB_SecPerClus = 2; 
....................    else if(DskSize < 0X20000) // 128 MB 
....................       BPB_SecPerClus = 4; 
....................    else if(DskSize < 0x40000) // 256 MB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x80000) // 512 MB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x100000) // 1 GB 
....................       BPB_SecPerClus = 32; 
....................    else if(DskSize < 0x200000) // 2 GB 
....................       BPB_SecPerClus = 64; 
....................    else // > 2 GB; this is too big 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // figure out how many sectors one FAT takes up 
....................    RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;  
....................    TmpVal1 = DskSize - (BPB_RsvdSecCnt + RootDirSectors);  
....................    TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;  
.................... #ifdef FAT32 
....................    TmpVal2 = TmpVal2 / 2; 
.................... #endif // #ifdef FAT32  
....................    BPB_FATSz = (TmpVal1 + (TmpVal2 - 1)) / TmpVal2; 
....................  
....................    // zero data 
....................    for(i = 0; i < sizeof(data); i += 1) 
....................       data[i] = 0; 
....................  
....................    // start filling up data 
....................    data[0] = 0xEB; 
....................    data[1] = BS_jmpBoot; 
....................    data[2] = 0x90;    
....................    sprintf(data + 3, "%s", BS_OEMName); 
....................    data[11] = make8(BPB_BytsPerSec, 0); 
....................    data[12] = make8(BPB_BytsPerSec, 1); 
....................    data[13] = BPB_SecPerClus; 
....................    data[14] = BPB_RsvdSecCnt; 
....................    data[16] = BPB_NumFATs; 
....................    data[21] = BPB_Media; 
....................    data[24] = BPB_SecPerTrk;  
....................    data[26] = BPB_NumHeads; 
.................... #ifdef FAT32 
....................    data[32] = make8(BPB_TotSec, 0); 
....................    data[33] = make8(BPB_TotSec, 1); 
....................    data[34] = make8(BPB_TotSec, 2); 
....................    data[35] = make8(BPB_TotSec, 3); 
....................    data[36] = make8(BPB_FATSz, 0); 
....................    data[37] = make8(BPB_FATSz, 1); 
....................    data[38] = make8(BPB_FATSz, 2); 
....................    data[39] = make8(BPB_FATSz, 3); 
....................    data[44] = BPB_RootClus; 
....................    data[48] = BPB_FSInfo; 
....................    data[50] = BPB_BkBootSec; 
....................    data[66] = BS_BootSig; 
....................    data[67] = make8(BS_VolID, 0); 
....................    data[68] = make8(BS_VolID, 1); 
....................    data[69] = make8(BS_VolID, 2); 
....................    data[70] = make8(BS_VolID, 3); 
....................    sprintf(data + 71, "%s", BS_VolLab); 
....................    sprintf(data + 82, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    clear_cluster(2); 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 12 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    data[3] = 0x0F; 
....................    data[4] = 0xFF; 
....................    data[5] = 0xFF; 
....................    data[6] = 0xFF; 
....................    data[7] = 0x0F; 
....................    data[8] = 0xFF; 
....................    data[9] = 0xFF; 
....................    data[10] = 0xFF; 
....................    data[11] = 0x0F; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
....................    // reset the last cluster 
....................    i = 2; 
....................    if(mmcsd_write_data(0x3EC, 4, &i) != GOODEC) 
....................       return EOF; 
.................... #else 
....................    data[17] = make8(BPB_RootEntCnt, 0); 
....................    data[18] = make8(BPB_RootEntCnt, 1); 
....................    data[19] = make8(BPB_TotSec, 0); 
....................    data[20] = make8(BPB_TotSec, 1); 
....................    data[22] = make8(BPB_FATSz, 0); 
....................    data[23] = make8(BPB_FATSz, 1); 
....................    data[38] = BS_BootSig; 
....................    data[39] = make8(BS_VolID, 0); 
....................    data[40] = make8(BS_VolID, 1); 
....................    data[41] = make8(BS_VolID, 2); 
....................    data[42] = make8(BS_VolID, 3); 
....................    sprintf(data + 43, "%s", BS_VolLab); 
....................    sprintf(data + 54, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    for(i = 0; i < (0x20 * BPB_RootEntCnt); i += 0x20) 
....................       if(mmcsd_write_data(TmpVal2 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 3 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
.................... #endif // #ifdef FAT32 
....................  
....................    i = 0xAA55; 
....................  
....................    if(mmcsd_write_data(0x1FE, 2, &i) != GOODEC) 
....................       return EOF;    
....................  
....................    // we're going to have to re-initialize the FAT, a bunch of parameters probably just changed 
....................    fat_init(); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Debugging Utility Functions /// 
....................  
.................... /* 
.................... signed int disp_folder_contents(char foldername[]) 
.................... Summary: Displays the contents of a folder. 
.................... Param: The folder to display the contents of. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int disp_folder_contents(char foldername[]) 
.................... { 
....................    char filename[MAX_FILE_NAME_LENGTH]; // a place to hold a file name 
....................     
....................    FILE stream; // the stream that we're going to be working with 
....................     
....................    char mode[] = "r"; 
....................     
....................    if(fatopen(foldername, mode, &stream) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf off a header 
....................    printf("\r\n--%s--", foldername); 
....................  
....................    // start off at the root directory 
....................    stream.Entry_Addr = stream.Start_Addr; 
....................  
....................    while(get_next_file(&stream) != EOF) 
....................    { 
....................       // get the name of the file that we are at 
....................       if(get_file_name(stream.Entry_Addr, filename) != GOODEC) 
....................          return EOF; 
....................       
....................       // make cool little "tree" branches 
....................       printf("\r\n%s", filename); 
....................       if (stream.File_Type == Directory) 
....................          putc('/'); 
....................    } 
....................  
....................    fatclose(&stream); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_addr(int32 from, int32 to) 
.................... Summary: Display a series of addresses in a hex editor type fashion. 
.................... Param from: The beginning address to display. 
.................... Param to: The end address to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_addr(int32 from, int32 to) 
.................... { 
....................    int 
....................       j,          // counter for loops 
....................       val[0x10];  // buffer to hold values 
....................  
....................    int32 i;       // pointer to memory 
....................  
....................    // print off header 
....................    printf("\r\n\r\n         "); 
....................    for(i = 0; i < 0x10; i += 1) 
....................       printf("%2X ", i); 
....................  
....................    // note that the to and from values are being rounded up and down 
....................    //  this makes a nice "block" map in case someone inputs a number that 
....................    //  isn't evenly divisible by 0x10 
....................    for(i = (from - (from % 0x10)); i <= (to + (to % 0x10)); i += 0x10) 
....................    { 
....................       // printf memory block 
....................       printf("\r\n%lX ", i); 
....................  
....................       // fill up buffer 
....................       if(mmcsd_read_data(i, 0x10, val) != GOODEC)   
....................          return EOF; 
....................  
....................       // printf RAM in hex 
....................       for(j = 0; j < 0X10; j += 1) 
....................          printf("%X ", val[j]); 
....................  
....................       // printf spacer 
....................       printf("; "); 
....................  
....................       // printf RAM in char 
....................       for(j = 0; j < 0X10; j += 1) 
....................       { 
....................          // check for characters that will mess up the nice-looking map 
....................          if(val[j] < ' ') 
....................             val[j] = '.'; 
....................  
....................          printf("%c", val[j]); 
....................       } 
....................    } 
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... Summary: Display a series of clusters in a memory map. 
.................... Param from: The beginning clusters to display. 
.................... Param to: The end clusters to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... { 
....................    // convert the clusters to addresses and dump 
....................    if(dump_addr(cluster_to_addr(from), cluster_to_addr(to)) != GOODEC) 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... void disp_fat_stats() 
.................... Summary: Display essential statistics about the FAT to the console. 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_fat_stats() 
.................... { 
....................    printf("\r\n\r\n--FAT Stats--\r\n"); 
....................    printf("First FAT starts at: 0x%lX\r\n", FAT_Start); 
....................    printf("Data Starts At: 0x%lX\r\n", Data_Start); 
....................    printf("Root Directory Is At: 0x%lX\r\n", Root_Dir); 
....................    printf("Bytes Per Cluster: 0x%lX\r\n", Bytes_Per_Cluster); 
.................... } 
....................  
.................... /* 
.................... signed int fatprintfinfo(FILE* stream) 
.................... Summary: Display essential statistics about the file that a stream is pointing to. 
.................... Param: The stream to print off information about. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatprintfinfo(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 val = 0; // buffer to hold values 
....................  
....................    char name[MAX_FILE_NAME_LENGTH]; 
....................  
....................    // get name 
....................    if(get_file_name(stream->Entry_Addr, name) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf header 
....................    printf("\r\n\r\n--"); 
....................    printf(name); 
....................    printf(" Info--"); 
....................  
....................    // printf attributes 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0B, 1, &val); 
....................    printf("\r\nAttributes: 0x%X", val); 
....................  
....................    // printf creation date 
....................    printf("\r\nCreated: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x10, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf creation time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0E, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf modification date 
....................    printf("\r\nModified: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x18, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf modification time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x16, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf starting cluster 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&val + 1); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &val); 
....................  
....................    printf("\r\nStarting cluster: %lX", val); 
....................  
....................    // printf starting address 
....................    printf("\r\nStarting address: %lX", cluster_to_addr(val)); 
....................  
....................    // printf size 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1C, 4, &val); 
....................    printf("\r\nSize: %lu Bytes\r\n", val); 
....................  
....................    if(ec != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... #endif // #ifndef FAT_PIC_C 
....................  
....................  
....................  
....................  int8 i, dato; 
....................  FILE myfile; 
....................   
.................... void initialize(){  
....................    printf("\r\n\nInitialize FAT library ... "); 
*
3102:  MOVLW  3E
3104:  MOVWF  FF6
3106:  MOVLW  01
3108:  MOVWF  FF7
310A:  CALL   0994
....................    delay_ms(100); 
310E:  MOVLW  64
3110:  MOVLB  3
3112:  MOVWF  x5E
3114:  MOVLB  0
3116:  CALL   0882
....................    // Initializing the FAT library as well as the SD card ---> returns 0 if OK 
....................    i = fat_init(); 
311A:  BRA    2CC0
311C:  MOVFF  01,224
....................    if(i != 0){ 
3120:  MOVLB  2
3122:  MOVF   x24,F
3124:  BZ    313A
....................       printf("Error initializing FAT library!\r\n"); 
3126:  MOVLW  5E
3128:  MOVWF  FF6
312A:  MOVLW  01
312C:  MOVWF  FF7
312E:  MOVLB  0
3130:  CALL   0994
....................       while(1){ 
3134:  BRA    3134
....................       } 
....................    } 
3136:  BRA    31A8
3138:  MOVLB  2
....................    else{ 
....................       printf("FAT Library initialized ... "); 
313A:  MOVLW  80
313C:  MOVWF  FF6
313E:  MOVLW  01
3140:  MOVWF  FF7
3142:  MOVLB  0
3144:  CALL   0994
....................       delay_ms(100);  
3148:  MOVLW  64
314A:  MOVLB  3
314C:  MOVWF  x5E
314E:  MOVLB  0
3150:  CALL   0882
....................       // Display SD card type ---> MMC, SDSC or SDHC 
....................       printf("Card Type: "); 
3154:  MOVLW  9E
3156:  MOVWF  FF6
3158:  MOVLW  01
315A:  MOVWF  FF7
315C:  CALL   0994
....................     switch(g_card_type) { 
3160:  MOVLB  2
3162:  MOVF   x09,W
3164:  XORLW  00
3166:  MOVLB  0
3168:  BZ    3174
316A:  XORLW  01
316C:  BZ    3182
316E:  XORLW  03
3170:  BZ    3190
3172:  BRA    31A8
....................       case MMC: printf("MMC \r\n"); break; 
3174:  MOVLW  AA
3176:  MOVWF  FF6
3178:  MOVLW  01
317A:  MOVWF  FF7
317C:  CALL   0994
3180:  BRA    31A8
....................       case SDSC: printf("SDSC \r\n"); break; 
3182:  MOVLW  B2
3184:  MOVWF  FF6
3186:  MOVLW  01
3188:  MOVWF  FF7
318A:  CALL   0994
318E:  BRA    31A8
....................       case SDHC: printf("SDHC \r\n"); 
3190:  MOVLW  BA
3192:  MOVWF  FF6
3194:  MOVLW  01
3196:  MOVWF  FF7
3198:  CALL   0994
....................       delay_ms(100); 
319C:  MOVLW  64
319E:  MOVLB  3
31A0:  MOVWF  x5E
31A2:  MOVLB  0
31A4:  CALL   0882
....................     } 
....................   } 
31A8:  GOTO   5FF0 (RETURN)
.................... } 
....................  
.................... //!void create_folder(){ 
.................... //!    // Create folder 'Test Dir' 
.................... //!    printf("Create 'Test Dir' folder ... "); 
.................... //!    if(mk_dir("/Test Dir/") == 0) 
.................... //!      printf("OK \r\n"); 
.................... //!    else 
.................... //!      printf("error creating folder \r\n"); 
.................... //!    delay_ms(1); 
.................... //!} 
....................  
.................... void create_doc(){ 
....................     // Create a text file 'log.txt' 
....................     printf("Create 'Datos.txt' file ---> "); 
....................     if(mk_file("/Datos.txt") == 0) 
....................       printf("OK \r\n"); 
....................     else 
....................       printf("error creating file \r\n"); 
....................     delay_ms(1); 
.................... } 
....................  
.................... void eliminate_doc(){ 
....................     // Create a text file 'log.txt' 
....................     printf("eliminating 'Datos.txt' file ---> "); 
....................     if(rm_file("/Datos.txt") == 0) 
....................       printf("OK \r\n"); 
....................     else 
....................       printf("error eliminating file \r\n"); 
....................     delay_ms(1); 
.................... } 
....................  
.................... void open_doc(){ 
....................     // Open the last created file 'log.txt' with write permission ('w') "r" = read "w" = write "a" = append "rb" = read binarily          
.................... //    printf("Open 'Datos.txt' file ---> ");                                               
....................     if(fatopen("/Datos.txt", "a", &myfile) != 0)                                       
*
53C0:  MOVLW  03
53C2:  MOVWF  FEA
53C4:  MOVLW  36
53C6:  MOVWF  FE9
53C8:  MOVLW  0B
53CA:  MOVWF  01
53CC:  CLRF   FF7
53CE:  MOVLW  00
53D0:  CALL   0004
53D4:  TBLRD*-
53D6:  TBLRD*+
53D8:  MOVFF  FF5,FEE
53DC:  DECFSZ 01,F
53DE:  BRA    53D6
53E0:  MOVLW  61
53E2:  MOVLB  3
53E4:  MOVWF  x41
53E6:  CLRF   x42
53E8:  MOVLW  03
53EA:  MOVWF  x48
53EC:  MOVLW  36
53EE:  MOVWF  x47
53F0:  MOVLW  03
53F2:  MOVWF  x4A
53F4:  MOVLW  41
53F6:  MOVWF  x49
53F8:  MOVLW  02
53FA:  MOVWF  x4C
53FC:  MOVLW  26
53FE:  MOVWF  x4B
5400:  MOVLB  0
5402:  BRA    5150
5404:  MOVF   01,F
5406:  BZ    5414
....................       printf("  error opening file \r\n");                                     
5408:  MOVLW  42
540A:  MOVWF  FF6
540C:  MOVLW  02
540E:  MOVWF  FF7
5410:  CALL   0994
....................     else { 
.................... //      printf("OK \r\n"); 
....................     } 
5414:  RETURN 0
.................... } 
....................  
.................... void write_docu(int dato){ 
....................       // Write some thing to the text file 
....................       char txt[50]; 
.................... //      printf("Writing to the text file 'Datos.txt' ---> "); 
....................       sprintf(txt, "%02u", dato); 
....................       if(fatputs(txt, &myfile) == 0){ 
....................         printf(txt); 
.................... //        printf(" ---> OK \r\n"); 
....................       } 
....................       else{ 
....................         printf("  writing error \r\n"); 
....................       } 
.................... } 
....................  
.................... void write_docf(float dato){ 
....................       // Write some thing to the text file 
....................       char txt[50]; 
.................... //      printf("Writing to the text file 'Datos.txt' ---> "); 
....................       sprintf(txt, "%05f", dato); 
....................       if(fatputs(txt, &myfile) == 0){ 
....................         printf(txt); 
.................... //        printf(" ---> OK \r\n"); 
....................       } 
....................       else{ 
....................         printf(" ---> writing error \r\n"); 
....................       } 
.................... } 
....................  
.................... void enter(){ 
....................    fatputs("\r\n", &myfile); 
*
5704:  MOVLW  0D
5706:  MOVLB  3
5708:  MOVWF  x36
570A:  MOVLW  0A
570C:  MOVWF  x37
570E:  CLRF   x38
5710:  MOVLW  03
5712:  MOVWF  x3C
5714:  MOVLW  36
5716:  MOVWF  x3B
5718:  MOVLW  02
571A:  MOVWF  x3E
571C:  MOVLW  26
571E:  MOVWF  x3D
5720:  MOVLB  0
5722:  RCALL  5690
5724:  RETURN 0
.................... } 
....................  
.................... void close_doc(){ 
....................       // Now close the file 
.................... //      printf("Closing the file 'Datos.txt' ---> "); 
....................       if(fatclose(&myfile) == 0){ 
*
5BEA:  MOVLW  02
5BEC:  MOVLB  3
5BEE:  MOVWF  x37
5BF0:  MOVLW  26
5BF2:  MOVWF  x36
5BF4:  MOVLB  0
5BF6:  BRA    58C2
5BF8:  MOVF   01,F
5BFA:  BNZ   5BFE
.................... //        printf("OK \r\n"); 
....................       } 
5BFC:  BRA    5C0A
....................       else{ 
....................         printf("  closing error \r\n");} 
5BFE:  MOVLW  86
5C00:  MOVWF  FF6
5C02:  MOVLW  02
5C04:  MOVWF  FF7
5C06:  CALL   0994
5C0A:  RETURN 0
.................... } 
....................  
.................... void read_doc(){ 
....................     // Reading 'log.txt' file 
....................     printf("Reading 'Datos.txt' file: \r\n"); 
....................     // Open 'log.txt' file with read permission ('r') 
.................... //!    printf("Open 'log.txt' file ... "); 
.................... //!    if(fatopen("/log.txt", "r", &myfile) != 0) 
.................... //!      printf("error opening file"); 
.................... //!    else { 
.................... //!      printf("OK"); 
.................... //!      // Print the whole file 
.................... //!      printf("\r\nPrint 'log.txt' file:\r\n\r"); 
....................       fatopen("/Datos.txt", "r", &myfile); 
....................       fatprintf(&myfile); 
....................       // Now close the file 
.................... //      if(fatclose(&myfile) == 0) 
....................         printf("\r\n\n"); 
.................... //      else 
.................... //        printf("closing error \r\n\n"); 
....................      
.................... } 
....................  
....................  
....................  
.................... #include <DS1307.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             DS1307.c                              //// 
.................... ////                                                                   //// 
.................... ////                      Driver for CCS C compiler                    //// 
.................... ////                                                                   //// 
.................... ////     Driver for Maxim DS1307 serial I2C real-time clock (RTC).     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     https://simple-circuit.com/                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #if defined DS1307_I2C_NO_STREAM 
....................   #define RTC_I2C_START()   i2c_start() 
....................   #define RTC_I2C_STOP()    i2c_stop() 
....................   #define RTC_I2C_WRITE(x)  i2c_write(x) 
....................   #define RTC_I2C_READ(x)   i2c_read(x) 
.................... #elif defined DS1307_I2C_STREAM 
....................   #define RTC_I2C_START()   i2c_start(DS1307_I2C_STREAM) 
....................   #define RTC_I2C_STOP()    i2c_stop(DS1307_I2C_STREAM) 
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS1307_I2C_STREAM, x) 
....................   #define RTC_I2C_READ(x)   i2c_read(DS1307_I2C_STREAM, x) 
.................... #else 
....................   #define RTC_I2C_START()   i2c_start(DS1307_STREAM) 
....................   #define RTC_I2C_STOP()    i2c_stop(DS1307_STREAM) 
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS1307_STREAM, x) 
....................   #define RTC_I2C_READ(x)   i2c_read(DS1307_STREAM, x) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define DS1307_ADDRESS      0xD0 
.................... #define DS1307_REG_SECONDS  0x00 
.................... #define DS1307_REG_CONTROL  0x07 
....................  
....................  
.................... enum SQWE 
.................... { 
....................   OUT_OFF = 0x00, 
....................   OUT_ON  = 0x80, 
....................   OUT_1Hz = 0x10, 
....................   OUT_4096Hz  = 0x11, 
....................   OUT_8192Hz  = 0x12, 
....................   OUT_32768Hz = 0x13 
.................... }; 
....................  
.................... typedef enum 
.................... { 
....................   SUNDAY = 1, 
....................   MONDAY, 
....................   TUESDAY, 
....................   WEDNESDAY, 
....................   THURSDAY, 
....................   FRIDAY, 
....................   SATURDAY 
.................... } RTC_DOW; 
....................  
.................... typedef enum 
.................... { 
....................   JANUARY = 1, 
....................   FEBRUARY, 
....................   MARCH, 
....................   APRIL, 
....................   MAY, 
....................   JUNE, 
....................   JULY, 
....................   AUGUST, 
....................   SEPTEMBER, 
....................   OCTOBER, 
....................   NOVEMBER, 
....................   DECEMBER 
.................... } RTC_Month; 
....................  
.................... typedef struct rtc_tm 
.................... { 
....................   uint8_t seconds; 
....................   uint8_t minutes; 
....................   uint8_t hours; 
....................   RTC_DOW dow; 
....................   uint8_t day; 
....................   RTC_Month month; 
....................   uint8_t year; 
.................... } RTC_Time; 
....................  
.................... ///////////////////////// All Functions ///////////////////////// 
....................                                                                // 
.................... uint8_t bcd_to_decimal(uint8_t number);                        // 
.................... uint8_t decimal_to_bcd(uint8_t number);                        // 
.................... void RTC_Set(RTC_Time *time_t);                                // 
.................... RTC_Time *RTC_Get();                                           // 
.................... void OSC_Enable();                                             // 
.................... void OSC_Disable();                                            // 
.................... uint8_t RTC_Read_Reg(uint8_t reg_address);                     // 
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value);    // 
.................... void SQWE_Set(SQWE pin_out);                                   // 
....................                                                                // 
.................... ///////////////////////////////////////////////////////////////// 
....................  
.................... // converts BCD to decimal 
.................... uint8_t bcd_to_decimal(uint8_t number) 
.................... { 
....................   return ( (number >> 4) * 10 + (number & 0x0F) ); 
*
054A:  MOVLB  3
054C:  SWAPF  x36,W
054E:  MOVWF  00
0550:  MOVLW  0F
0552:  ANDWF  00,F
0554:  MOVF   00,W
0556:  MULLW  0A
0558:  MOVFF  FF3,337
055C:  MOVF   x36,W
055E:  ANDLW  0F
0560:  ADDWF  x37,W
0562:  MOVWF  01
0564:  MOVLB  0
0566:  RETURN 0
.................... } 
....................  
.................... // converts decimal to BCD 
.................... uint8_t decimal_to_bcd(uint8_t number) 
.................... { 
....................   return ( ((number / 10) << 4) + (number % 10) ); 
.................... } 
....................  
.................... // sets time and date 
.................... void RTC_Set(RTC_Time *time_t) 
.................... { 
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS); 
....................  
....................   // convert decimal to BCD 
....................   time_t->day     = decimal_to_bcd(time_t->day); 
....................   time_t->month   = decimal_to_bcd(time_t->month); 
....................   time_t->year    = decimal_to_bcd(time_t->year); 
....................   time_t->hours   = decimal_to_bcd(time_t->hours); 
....................   time_t->minutes = decimal_to_bcd(time_t->minutes); 
....................   time_t->seconds = decimal_to_bcd(time_t->seconds); 
....................   // end conversion 
....................    
....................   // test if oscillator is disabled (CH bit = 1) 
....................   if(sec_reg & 0x80) 
....................     time_t->seconds |= 0x80; 
....................  
....................   // write data to the RTC chip 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(DS1307_REG_SECONDS); 
....................   RTC_I2C_WRITE(time_t->seconds); 
....................   RTC_I2C_WRITE(time_t->minutes); 
....................   RTC_I2C_WRITE(time_t->hours); 
....................   RTC_I2C_WRITE(time_t->dow); 
....................   RTC_I2C_WRITE(time_t->day); 
....................   RTC_I2C_WRITE(time_t->month); 
....................   RTC_I2C_WRITE(time_t->year); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... RTC_Time c_time; 
....................  
.................... // reads time and date 
.................... RTC_Time *RTC_Get() 
.................... { 
....................   RTC_I2C_START(); 
0568:  BSF    F92.1
056A:  NOP   
056C:  BSF    F92.0
056E:  NOP   
0570:  BCF    F89.1
0572:  BCF    F92.1
0574:  NOP   
0576:  BCF    F89.0
0578:  BCF    F92.0
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
057A:  MOVLW  D0
057C:  MOVLB  3
057E:  MOVWF  x3F
0580:  MOVLB  0
0582:  RCALL  04AC
....................   RTC_I2C_WRITE(DS1307_REG_SECONDS); 
0584:  MOVLB  3
0586:  CLRF   x3F
0588:  MOVLB  0
058A:  RCALL  04AC
....................   RTC_I2C_START(); 
058C:  BSF    F92.1
058E:  NOP   
0590:  BSF    F92.0
0592:  NOP   
0594:  BTFSS  F80.0
0596:  BRA    0594
0598:  BCF    F89.1
059A:  BCF    F92.1
059C:  NOP   
059E:  BCF    F89.0
05A0:  BCF    F92.0
....................   RTC_I2C_WRITE(DS1307_ADDRESS | 0x01); 
05A2:  MOVLW  D1
05A4:  MOVLB  3
05A6:  MOVWF  x3F
05A8:  MOVLB  0
05AA:  RCALL  04AC
....................   c_time.seconds = RTC_I2C_READ(1) & 0x7F; 
05AC:  MOVLW  01
05AE:  MOVWF  00
05B0:  RCALL  04FE
05B2:  MOVF   01,W
05B4:  ANDLW  7F
05B6:  MOVLB  2
05B8:  MOVWF  x60
....................   c_time.minutes = RTC_I2C_READ(1); 
05BA:  MOVLW  01
05BC:  MOVWF  00
05BE:  MOVLB  0
05C0:  RCALL  04FE
05C2:  MOVFF  01,261
....................   c_time.hours   = RTC_I2C_READ(1); 
05C6:  MOVLW  01
05C8:  MOVWF  00
05CA:  RCALL  04FE
05CC:  MOVFF  01,262
....................   c_time.dow   = RTC_I2C_READ(1); 
05D0:  MOVLW  01
05D2:  MOVWF  00
05D4:  RCALL  04FE
05D6:  MOVFF  01,263
....................   c_time.day   = RTC_I2C_READ(1); 
05DA:  MOVLW  01
05DC:  MOVWF  00
05DE:  RCALL  04FE
05E0:  MOVFF  01,264
....................   c_time.month = RTC_I2C_READ(1); 
05E4:  MOVLW  01
05E6:  MOVWF  00
05E8:  RCALL  04FE
05EA:  MOVFF  01,265
....................   c_time.year  = RTC_I2C_READ(0); 
05EE:  CLRF   00
05F0:  RCALL  04FE
05F2:  MOVFF  01,266
....................   RTC_I2C_STOP(); 
05F6:  BCF    F92.1
05F8:  NOP   
05FA:  BSF    F92.0
05FC:  BTFSS  F80.0
05FE:  BRA    05FC
0600:  NOP   
0602:  BRA    0604
0604:  NOP   
0606:  BSF    F92.1
0608:  NOP   
....................  
....................   // convert BCD to decimal 
....................   c_time.seconds = bcd_to_decimal(c_time.seconds); 
060A:  MOVFF  260,336
060E:  RCALL  054A
0610:  MOVFF  01,260
....................   c_time.minutes = bcd_to_decimal(c_time.minutes); 
0614:  MOVFF  261,336
0618:  RCALL  054A
061A:  MOVFF  01,261
....................   c_time.hours   = bcd_to_decimal(c_time.hours); 
061E:  MOVFF  262,336
0622:  RCALL  054A
0624:  MOVFF  01,262
....................   c_time.day     = bcd_to_decimal(c_time.day); 
0628:  MOVFF  264,336
062C:  RCALL  054A
062E:  MOVFF  01,264
....................   c_time.month   = bcd_to_decimal(c_time.month); 
0632:  MOVFF  265,336
0636:  RCALL  054A
0638:  MOVFF  01,265
....................   c_time.year    = bcd_to_decimal(c_time.year); 
063C:  MOVFF  266,336
0640:  RCALL  054A
0642:  MOVFF  01,266
....................   // end conversion 
....................  
....................   return &c_time; 
0646:  MOVLW  60
0648:  MOVWF  01
064A:  MOVLW  02
064C:  MOVWF  02
064E:  RETURN 0
.................... } 
....................  
.................... // writes 'reg_value' to register of address 'reg_address' 
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value) 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(reg_address); 
....................   RTC_I2C_WRITE(reg_value); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // returns the value stored in register of address 'reg_address' 
.................... uint8_t RTC_Read_Reg(uint8_t reg_address) 
.................... { 
....................   uint8_t reg_data; 
....................  
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(reg_address); 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS | 0x01); 
....................   reg_data = RTC_I2C_READ(0); 
....................   RTC_I2C_STOP(); 
....................  
....................   return reg_data; 
.................... } 
....................  
.................... // sets SQWE pin output 
.................... void SQWE_Set(SQWE pin_out) 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(DS1307_REG_CONTROL); 
....................   RTC_I2C_WRITE(pin_out); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // enables RTC oscillator 
.................... void OSC_Enable() 
.................... { 
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS); 
....................   sec_reg &= 0x7F; 
....................   RTC_Write_Reg(DS1307_REG_SECONDS, sec_reg); 
.................... } 
....................  
.................... // disables RTC oscillator 
.................... void OSC_Disable() 
.................... { 
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS); 
....................   sec_reg |= 0x80; 
....................   RTC_Write_Reg(DS1307_REG_SECONDS, sec_reg); 
.................... } 
....................  
....................  
....................  
.................... #include <DHT22.c> 
.................... #use fast_io(B) 
.................... #define DHT11_PIN PIN_B5   
....................  
.................... short Time_out ; 
.................... unsigned int8 T_byte1, T_byte2, RH_byte1, RH_byte2, CheckSum ; 
.................... unsigned int16 Temp, RH; 
.................... float Temp2, RH2; 
....................  
.................... void start_signal(){ 
....................    output_drive(DHT11_PIN);  
*
08AA:  BCF    F93.5
....................    output_low(DHT11_PIN);    
08AC:  BCF    F8A.5
....................    delay_ms(25); 
08AE:  MOVLW  19
08B0:  MOVLB  3
08B2:  MOVWF  x5E
08B4:  MOVLB  0
08B6:  RCALL  0882
....................    output_high(DHT11_PIN);   
08B8:  BSF    F8A.5
....................    delay_us(30); 
08BA:  MOVLW  13
08BC:  MOVWF  00
08BE:  DECFSZ 00,F
08C0:  BRA    08BE
08C2:  BRA    08C4
....................    output_float(DHT11_PIN);  
08C4:  BSF    F93.5
08C6:  GOTO   0BBA (RETURN)
.................... } 
....................  
.................... short check_response(){ 
....................   delay_us(40); 
08CA:  MOVLW  1A
08CC:  MOVWF  00
08CE:  DECFSZ 00,F
08D0:  BRA    08CE
08D2:  NOP   
....................   if(!input(DHT11_PIN)){  
08D4:  BTFSC  F81.5
08D6:  BRA    08F0
....................     delay_us(80); 
08D8:  MOVLW  35
08DA:  MOVWF  00
08DC:  DECFSZ 00,F
08DE:  BRA    08DC
....................     if(input(DHT11_PIN)){ 
08E0:  BTFSS  F81.5
08E2:  BRA    08F0
....................       delay_us(50); 
08E4:  MOVLW  21
08E6:  MOVWF  00
08E8:  DECFSZ 00,F
08EA:  BRA    08E8
....................       return 1; 
08EC:  MOVLW  01
08EE:  MOVWF  01
....................     } 
....................   } 
08F0:  GOTO   0BBC (RETURN)
.................... } 
....................  
.................... unsigned int8 Read_Data(){ 
08F4:  MOVLB  3
08F6:  CLRF   x39
....................   unsigned int8 i, k, _data = 0;               // k is used to count 1 bit reading duration 
....................   if(Time_out) 
08F8:  MOVLB  2
08FA:  BTFSS  x04.2
08FC:  BRA    08FE
....................     break; 
....................   for(i = 0; i < 8; i++){ 
08FE:  MOVLB  3
0900:  CLRF   x37
0902:  MOVF   x37,W
0904:  SUBLW  07
0906:  BNC   098C
....................     k = 0; 
0908:  CLRF   x38
....................     while(!input(DHT11_PIN)){                          // Wait until pin goes high 
090A:  BTFSC  F81.5
090C:  BRA    0922
....................       k++; 
090E:  INCF   x38,F
....................       if (k > 100) {Time_out = 1; break;} 
0910:  MOVF   x38,W
0912:  SUBLW  64
0914:  BC    091E
0916:  MOVLB  2
0918:  BSF    x04.2
091A:  MOVLB  3
091C:  BRA    0922
....................       delay_us(1);} 
091E:  BRA    0920
0920:  BRA    090A
....................     delay_us(30); 
0922:  MOVLW  13
0924:  MOVWF  00
0926:  DECFSZ 00,F
0928:  BRA    0926
092A:  BRA    092C
....................     if(!input(DHT11_PIN)) 
092C:  BTFSC  F81.5
092E:  BRA    0952
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
0930:  MOVLW  07
0932:  BSF    FD8.0
0934:  SUBFWB x37,W
0936:  MOVWF  x3A
0938:  MOVLW  01
093A:  MOVWF  00
093C:  MOVF   x3A,W
093E:  MOVWF  01
0940:  BZ    094A
0942:  BCF    FD8.0
0944:  RLCF   00,F
0946:  DECFSZ 01,F
0948:  BRA    0942
094A:  MOVF   00,W
094C:  XORLW  FF
094E:  ANDWF  x39,F
0950:  BRA    0988
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
0952:  MOVLW  07
0954:  BSF    FD8.0
0956:  SUBFWB x37,W
0958:  MOVWF  x3A
095A:  MOVLW  01
095C:  MOVWF  00
095E:  MOVF   x3A,W
0960:  MOVWF  01
0962:  BZ    096C
0964:  BCF    FD8.0
0966:  RLCF   00,F
0968:  DECFSZ 01,F
096A:  BRA    0964
096C:  MOVF   00,W
096E:  IORWF  x39,F
....................       while(input(DHT11_PIN)){                         // Wait until pin goes low 
0970:  BTFSS  F81.5
0972:  BRA    0988
....................       k++; 
0974:  INCF   x38,F
....................       if (k > 100) {Time_out = 1; break;} 
0976:  MOVF   x38,W
0978:  SUBLW  64
097A:  BC    0984
097C:  MOVLB  2
097E:  BSF    x04.2
0980:  MOVLB  3
0982:  BRA    0988
....................       delay_us(1);} 
0984:  BRA    0986
0986:  BRA    0970
....................     } 
0988:  INCF   x37,F
098A:  BRA    0902
....................   } 
....................   return _data; 
098C:  MOVFF  339,01
0990:  MOVLB  0
0992:  RETURN 0
.................... } 
....................  
.................... float dat_DHT22(char selector){ 
....................    delay_ms(500); 
*
0B9E:  MOVLW  02
0BA0:  MOVLB  3
0BA2:  MOVWF  x37
0BA4:  MOVLW  FA
0BA6:  MOVWF  x5E
0BA8:  MOVLB  0
0BAA:  RCALL  0882
0BAC:  MOVLB  3
0BAE:  DECFSZ x37,F
0BB0:  BRA    0BA4
....................    Time_out = 0; 
0BB2:  MOVLB  2
0BB4:  BCF    x04.2
....................    start_signal(); 
0BB6:  MOVLB  0
0BB8:  BRA    08AA
....................    if(check_response()){                     // If there is response from sensor 
0BBA:  BRA    08CA
0BBC:  MOVF   01,F
0BBE:  BTFSC  FD8.2
0BC0:  BRA    0D44
....................          RH_byte1 = Read_Data();                 // read RH byte1 
0BC2:  RCALL  08F4
0BC4:  MOVFF  01,269
....................          RH_byte2 = Read_Data();                 // read RH byte2 
0BC8:  RCALL  08F4
0BCA:  MOVFF  01,26A
....................          T_byte1 = Read_Data();                  // read T byte1 
0BCE:  RCALL  08F4
0BD0:  MOVFF  01,267
....................          T_byte2 = Read_Data();                  // read T byte2 
0BD4:  RCALL  08F4
0BD6:  MOVFF  01,268
....................          CheckSum = Read_Data();                 // read checksum 
0BDA:  RCALL  08F4
0BDC:  MOVFF  01,26B
....................          if(Time_out){                           // If reading takes long time 
0BE0:  MOVLB  2
0BE2:  BTFSS  x04.2
0BE4:  BRA    0BF6
....................            printf("Time out!\r\n"); 
0BE6:  MOVLW  BC
0BE8:  MOVWF  FF6
0BEA:  MOVLW  02
0BEC:  MOVWF  FF7
0BEE:  MOVLB  0
0BF0:  RCALL  0994
....................          } 
0BF2:  BRA    0D3E
0BF4:  MOVLB  2
....................          else{ 
....................           if(CheckSum == ((RH_byte1 + RH_byte2 + T_byte1 + T_byte2) & 0xFF)){ 
0BF6:  MOVF   x6A,W
0BF8:  ADDWF  x69,W
0BFA:  ADDWF  x67,W
0BFC:  ADDWF  x68,W
0BFE:  SUBWF  x6B,W
0C00:  BTFSS  FD8.2
0C02:  BRA    0D32
....................            RH = RH_byte1; 
0C04:  CLRF   x6F
0C06:  MOVFF  269,26E
....................            RH = (RH << 8) | RH_byte2; 
0C0A:  MOVFF  26E,26F
0C0E:  MOVLB  3
0C10:  CLRF   x37
0C12:  MOVF   x37,W
0C14:  MOVLB  2
0C16:  IORWF  x6A,W
0C18:  MOVWF  x6E
0C1A:  MOVLB  2
....................            Temp = T_byte1; 
0C1C:  CLRF   x6D
0C1E:  MOVFF  267,26C
....................            Temp = (Temp << 8) | T_byte2; 
0C22:  MOVFF  26C,26D
0C26:  MOVLB  3
0C28:  CLRF   x37
0C2A:  MOVF   x37,W
0C2C:  MOVLB  2
0C2E:  IORWF  x68,W
0C30:  MOVWF  x6C
0C32:  MOVLB  2
....................            if (Temp > 0X8000){ 
0C34:  MOVF   x6D,W
0C36:  SUBLW  7F
0C38:  BC    0C64
0C3A:  XORLW  FF
0C3C:  BNZ   0C44
0C3E:  MOVF   x6C,W
0C40:  SUBLW  00
0C42:  BC    0C64
....................             Temp = Temp & 0X7FFF; 
0C44:  BCF    x6D.7
....................             Temp = Temp*(-1);} 
0C46:  MOVFF  26D,338
0C4A:  MOVFF  26C,337
0C4E:  MOVLB  3
0C50:  SETF   x3A
0C52:  SETF   x39
0C54:  MOVLB  0
0C56:  BRA    09B4
0C58:  MOVFF  02,26D
0C5C:  MOVLB  2
0C5E:  MOVFF  01,26C
0C62:  BRA    0C82
....................            else 
....................            Temp2 = Temp; 
0C64:  MOVFF  26D,33E
0C68:  MOVFF  26C,33D
0C6C:  MOVLB  0
0C6E:  RCALL  0A0A
0C70:  MOVFF  03,273
0C74:  MOVFF  02,272
0C78:  MOVFF  01,271
0C7C:  MOVFF  00,270
0C80:  MOVLB  2
....................            Temp2 = Temp2/10; 
0C82:  MOVFF  273,355
0C86:  MOVFF  272,354
0C8A:  MOVFF  271,353
0C8E:  MOVFF  270,352
0C92:  MOVLB  3
0C94:  CLRF   x59
0C96:  CLRF   x58
0C98:  MOVLW  20
0C9A:  MOVWF  x57
0C9C:  MOVLW  82
0C9E:  MOVWF  x56
0CA0:  MOVLB  0
0CA2:  RCALL  0A40
0CA4:  MOVFF  03,273
0CA8:  MOVFF  02,272
0CAC:  MOVFF  01,271
0CB0:  MOVFF  00,270
....................            RH2 = RH; 
0CB4:  MOVFF  26F,33E
0CB8:  MOVFF  26E,33D
0CBC:  RCALL  0A0A
0CBE:  MOVFF  03,277
0CC2:  MOVFF  02,276
0CC6:  MOVFF  01,275
0CCA:  MOVFF  00,274
....................            RH2 = RH2/10; 
0CCE:  MOVFF  277,355
0CD2:  MOVFF  276,354
0CD6:  MOVFF  275,353
0CDA:  MOVFF  274,352
0CDE:  MOVLB  3
0CE0:  CLRF   x59
0CE2:  CLRF   x58
0CE4:  MOVLW  20
0CE6:  MOVWF  x57
0CE8:  MOVLW  82
0CEA:  MOVWF  x56
0CEC:  MOVLB  0
0CEE:  RCALL  0A40
0CF0:  MOVFF  03,277
0CF4:  MOVFF  02,276
0CF8:  MOVFF  01,275
0CFC:  MOVFF  00,274
....................            if(selector==0){ 
0D00:  MOVLB  3
0D02:  MOVF   x36,F
0D04:  BNZ   0D18
....................             return Temp2; 
0D06:  MOVFF  270,00
0D0A:  MOVFF  271,01
0D0E:  MOVFF  272,02
0D12:  MOVFF  273,03
0D16:  BRA    0D50
....................            } 
....................            if(selector==1){ 
0D18:  DECFSZ x36,W
0D1A:  BRA    0D2E
....................             return RH2; 
0D1C:  MOVFF  274,00
0D20:  MOVFF  275,01
0D24:  MOVFF  276,02
0D28:  MOVFF  277,03
0D2C:  BRA    0D50
....................            } 
....................            } 
0D2E:  BRA    0D40
0D30:  MOVLB  2
....................            else { 
....................              printf("Checksum Error!\r\n"); 
0D32:  MOVLW  C8
0D34:  MOVWF  FF6
0D36:  MOVLW  02
0D38:  MOVWF  FF7
0D3A:  MOVLB  0
0D3C:  RCALL  0994
0D3E:  MOVLB  3
....................            } 
....................          } 
....................        } 
0D40:  BRA    0D50
0D42:  MOVLB  0
....................        else { 
....................          printf("No response from the sensor\r\n"); 
0D44:  MOVLW  DA
0D46:  MOVWF  FF6
0D48:  MOVLW  02
0D4A:  MOVWF  FF7
0D4C:  RCALL  0994
0D4E:  MOVLB  3
....................        } 
0D50:  MOVLB  0
0D52:  GOTO   5D92 (RETURN)
.................... } 
....................  
.................... #include <BMP085.c> 
....................  
.................... //************************************************  
.................... //  BMP085 Barometric Pressure Sensor  
.................... //  
.................... //  - Datasheet: http://www.bosch-sensortec.com/content/language1/downloads/BST-BMP085-DS000-05.pdf  
.................... //  
.................... //  - Written in CCS PCH C using floating point math  
.................... //  - Several integer math versions of this driver exist but the speed improvement is  
.................... //    not warranted in typical weather station type applications  
.................... //   
.................... //  - Based on a paper posted to thebackshed.com by DuinoMiteMegaAn  
.................... //    http://www.thebackshed.com/forum/forum_posts.asp?TID=4768&PN=9   
.................... //  
.................... //  - Usage:  
.................... //     Call once: bmp085Calibration();  
.................... //     P_mBar_float = BMP085Pressure(true);  //  calls for temperature first  
.................... //     P_mBar_float = BMP085Pressure(false);  // skips temperature reading, assumes done previously  
.................... //     T_Cent_float = BMP085Temperature();  
.................... //     t_reading = _Temp;  _Temp set on every temperature reading  
.................... //        Note:   pressure reading is temp compensated so call for temp reading prior to pressure reading periodically or on each reading  
.................... //  
.................... //  Al Testani  
.................... //  08/17/12  
.................... //************************************************  
....................  
.................... // place a #use i2c statement in the main program and comment this out if not applicable  
.................... //#use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST, FORCE_HW)  
....................  
.................... #include <math.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... const int8 OVS_S = 3; // Oversampling Setting (0,1,2,3 from ultra low power, to ultra hi-resolution)  
....................  
.................... #define BMP085_ADDRESS 0xEE          // I2C address of BMP085  
.................... #define P_CORRECTION   1.5           // in mBars - factor to adjust for elevation to match local weather station pressure  
....................                                      // this value for 14' above sea level (in Boca Raton, Florida)  
....................  
....................  
.................... // Calibration values  
.................... signed int16 ac1;  
.................... signed int16 ac2;  
.................... signed int16 ac3;  
.................... int16 ac4;  
.................... int16 ac5;  
.................... int16 ac6;  
.................... signed int16 b1;  
.................... signed int16 b2;  
.................... signed int16 mb;  
.................... signed int16 mc;  
.................... signed int16 md;  
....................  
.................... // floating point cal factors  
.................... float _c3;  
.................... float _c4;  
.................... float _b1;  
.................... float _c5;  
.................... float _c6;  
.................... float _mc;  
.................... float _md;  
....................  
.................... // polynomomial constants  
.................... float _x0;  
.................... float _x1;  
.................... float _x2;  
.................... float _y0;  
.................... float _y1;  
.................... float _y2;  
.................... float _p0;  
.................... float _p1;  
.................... float _p2;  
....................  
.................... float _s;     // T-25, used in pressure calculation - must run temperature reading before pressure reading  
.................... float _Temp;  // set after every temperature or temperature/pressure reading  
....................  
....................  
.................... //----------------------------------------------  
.................... int8 BMP085ReadByte(int8 address)  
.................... //----------------------------------------------  
.................... {  
.................... int8 data;  
....................  
....................    i2c_start();  
*
1A28:  BSF    F92.1
1A2A:  NOP   
1A2C:  BSF    F92.0
1A2E:  NOP   
1A30:  BCF    F89.1
1A32:  BCF    F92.1
1A34:  NOP   
1A36:  BCF    F89.0
1A38:  BCF    F92.0
....................    i2c_write(BMP085_ADDRESS);  
1A3A:  MOVLW  EE
1A3C:  MOVLB  3
1A3E:  MOVWF  x3F
1A40:  MOVLB  0
1A42:  CALL   04AC
....................    i2c_write(address);  
1A46:  MOVFF  33D,33F
1A4A:  CALL   04AC
....................    i2c_start();  
1A4E:  BSF    F92.1
1A50:  NOP   
1A52:  BSF    F92.0
1A54:  NOP   
1A56:  BTFSS  F80.0
1A58:  BRA    1A56
1A5A:  BCF    F89.1
1A5C:  BCF    F92.1
1A5E:  NOP   
1A60:  BCF    F89.0
1A62:  BCF    F92.0
....................    i2c_write(BMP085_ADDRESS | 0x01 );  
1A64:  MOVLW  EF
1A66:  MOVLB  3
1A68:  MOVWF  x3F
1A6A:  MOVLB  0
1A6C:  CALL   04AC
....................    data=i2c_read(0);  
1A70:  CLRF   00
1A72:  CALL   04FE
1A76:  MOVFF  01,33E
....................    i2c_stop();  
1A7A:  BCF    F92.1
1A7C:  NOP   
1A7E:  BSF    F92.0
1A80:  BTFSS  F80.0
1A82:  BRA    1A80
1A84:  NOP   
1A86:  BRA    1A88
1A88:  NOP   
1A8A:  BSF    F92.1
1A8C:  NOP   
....................    return(data);  
1A8E:  MOVLB  3
1A90:  MOVFF  33E,01
1A94:  MOVLB  0
1A96:  RETURN 0
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... int16 BMP085ReadInt(int8 address)  
.................... //----------------------------------------------  
.................... {  
.................... int8 msb, lsb;  
.................... int16 temp;  
....................  
....................    i2c_start();  
*
10D4:  BSF    F92.1
10D6:  NOP   
10D8:  BSF    F92.0
10DA:  NOP   
10DC:  BCF    F89.1
10DE:  BCF    F92.1
10E0:  NOP   
10E2:  BCF    F89.0
10E4:  BCF    F92.0
....................    i2c_write(BMP085_ADDRESS);  
10E6:  MOVLW  EE
10E8:  MOVLB  3
10EA:  MOVWF  x3F
10EC:  MOVLB  0
10EE:  CALL   04AC
....................    i2c_write(address);  
10F2:  MOVFF  338,33F
10F6:  CALL   04AC
....................    i2c_start();  
10FA:  BSF    F92.1
10FC:  NOP   
10FE:  BSF    F92.0
1100:  NOP   
1102:  BTFSS  F80.0
1104:  BRA    1102
1106:  BCF    F89.1
1108:  BCF    F92.1
110A:  NOP   
110C:  BCF    F89.0
110E:  BCF    F92.0
....................    i2c_write(BMP085_ADDRESS | 0x01 );  
1110:  MOVLW  EF
1112:  MOVLB  3
1114:  MOVWF  x3F
1116:  MOVLB  0
1118:  CALL   04AC
....................    msb = i2c_read();  
111C:  MOVLW  01
111E:  MOVWF  00
1120:  CALL   04FE
1124:  MOVFF  01,339
....................    lsb = i2c_read(0);  
1128:  CLRF   00
112A:  CALL   04FE
112E:  MOVFF  01,33A
....................    i2c_stop();  
1132:  BCF    F92.1
1134:  NOP   
1136:  BSF    F92.0
1138:  BTFSS  F80.0
113A:  BRA    1138
113C:  NOP   
113E:  BRA    1140
1140:  NOP   
1142:  BSF    F92.1
1144:  NOP   
....................    temp = make16(msb, lsb);  
1146:  MOVFF  339,33C
114A:  MOVFF  33A,33B
....................    return ( temp );  
114E:  MOVLB  3
1150:  MOVFF  33B,01
1154:  MOVFF  33C,02
1158:  MOVLB  0
115A:  RETURN 0
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... void BMP085WriteByte(int8 address, int8 data)  
.................... //----------------------------------------------  
.................... {  
....................    i2c_start();  
*
1574:  BSF    F92.1
1576:  NOP   
1578:  BSF    F92.0
157A:  NOP   
157C:  BCF    F89.1
157E:  BCF    F92.1
1580:  NOP   
1582:  BCF    F89.0
1584:  BCF    F92.0
....................    i2c_write(BMP085_ADDRESS);  
1586:  MOVLW  EE
1588:  MOVLB  3
158A:  MOVWF  x3F
158C:  MOVLB  0
158E:  CALL   04AC
....................    i2c_write(address);  
1592:  MOVFF  33D,33F
1596:  CALL   04AC
....................    i2c_write(data);  
159A:  MOVFF  33E,33F
159E:  CALL   04AC
....................    i2c_stop();  
15A2:  BCF    F92.1
15A4:  NOP   
15A6:  BSF    F92.0
15A8:  BTFSS  F80.0
15AA:  BRA    15A8
15AC:  NOP   
15AE:  BRA    15B0
15B0:  NOP   
15B2:  BSF    F92.1
15B4:  NOP   
15B6:  RETURN 0
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... void bmp085Calibration()  
.................... //----------------------------------------------  
.................... {  
....................    // read BMP085 EEPROM cal factors  
....................    ac1 = BMP085ReadInt(0xAA);  
*
11AC:  MOVLW  AA
11AE:  MOVLB  3
11B0:  MOVWF  x38
11B2:  MOVLB  0
11B4:  RCALL  10D4
11B6:  MOVFF  02,279
11BA:  MOVFF  01,278
....................    ac2 = BMP085ReadInt(0xAC);  
11BE:  MOVLW  AC
11C0:  MOVLB  3
11C2:  MOVWF  x38
11C4:  MOVLB  0
11C6:  RCALL  10D4
11C8:  MOVFF  02,27B
11CC:  MOVFF  01,27A
....................    ac3 = BMP085ReadInt(0xAE);  
11D0:  MOVLW  AE
11D2:  MOVLB  3
11D4:  MOVWF  x38
11D6:  MOVLB  0
11D8:  RCALL  10D4
11DA:  MOVFF  02,27D
11DE:  MOVFF  01,27C
....................    ac4 = BMP085ReadInt(0xB0);  
11E2:  MOVLW  B0
11E4:  MOVLB  3
11E6:  MOVWF  x38
11E8:  MOVLB  0
11EA:  RCALL  10D4
11EC:  MOVFF  02,27F
11F0:  MOVFF  01,27E
....................    ac5 = BMP085ReadInt(0xB2);  
11F4:  MOVLW  B2
11F6:  MOVLB  3
11F8:  MOVWF  x38
11FA:  MOVLB  0
11FC:  RCALL  10D4
11FE:  MOVFF  02,281
1202:  MOVFF  01,280
....................    ac6 = BMP085ReadInt(0xB4);  
1206:  MOVLW  B4
1208:  MOVLB  3
120A:  MOVWF  x38
120C:  MOVLB  0
120E:  RCALL  10D4
1210:  MOVFF  02,283
1214:  MOVFF  01,282
....................    b1  = BMP085ReadInt(0xB6);  
1218:  MOVLW  B6
121A:  MOVLB  3
121C:  MOVWF  x38
121E:  MOVLB  0
1220:  RCALL  10D4
1222:  MOVFF  02,285
1226:  MOVFF  01,284
....................    b2  = BMP085ReadInt(0xB8);  
122A:  MOVLW  B8
122C:  MOVLB  3
122E:  MOVWF  x38
1230:  MOVLB  0
1232:  RCALL  10D4
1234:  MOVFF  02,287
1238:  MOVFF  01,286
....................    mb  = BMP085ReadInt(0xBA);  
123C:  MOVLW  BA
123E:  MOVLB  3
1240:  MOVWF  x38
1242:  MOVLB  0
1244:  RCALL  10D4
1246:  MOVFF  02,289
124A:  MOVFF  01,288
....................    mc  = BMP085ReadInt(0xBC);  
124E:  MOVLW  BC
1250:  MOVLB  3
1252:  MOVWF  x38
1254:  MOVLB  0
1256:  RCALL  10D4
1258:  MOVFF  02,28B
125C:  MOVFF  01,28A
....................    md  = BMP085ReadInt(0xBE);  
1260:  MOVLW  BE
1262:  MOVLB  3
1264:  MOVWF  x38
1266:  MOVLB  0
1268:  RCALL  10D4
126A:  MOVFF  02,28D
126E:  MOVFF  01,28C
....................  
....................     // calculate floating point cal factors  
....................    _c3 = 0.0048828125 * ac3;            // 160 * pow2(-15) * ac3;  
1272:  MOVFF  27D,337
1276:  MOVFF  27C,336
127A:  RCALL  115C
127C:  MOVLB  3
127E:  CLRF   x55
1280:  CLRF   x54
1282:  MOVLW  20
1284:  MOVWF  x53
1286:  MOVLW  77
1288:  MOVWF  x52
128A:  MOVFF  03,359
128E:  MOVFF  02,358
1292:  MOVFF  01,357
1296:  MOVFF  00,356
129A:  MOVLB  0
129C:  RCALL  0D56
129E:  MOVFF  03,291
12A2:  MOVFF  02,290
12A6:  MOVFF  01,28F
12AA:  MOVFF  00,28E
....................    _c4 = 0.000000030517578125 * ac4;    // 1E-3 * pow2(-15) * ac4;  
12AE:  MOVFF  27F,33E
12B2:  MOVFF  27E,33D
12B6:  CALL   0A0A
12BA:  MOVLW  6F
12BC:  MOVLB  3
12BE:  MOVWF  x55
12C0:  MOVLW  12
12C2:  MOVWF  x54
12C4:  MOVLW  03
12C6:  MOVWF  x53
12C8:  MOVLW  66
12CA:  MOVWF  x52
12CC:  MOVFF  03,359
12D0:  MOVFF  02,358
12D4:  MOVFF  01,357
12D8:  MOVFF  00,356
12DC:  MOVLB  0
12DE:  RCALL  0D56
12E0:  MOVFF  03,295
12E4:  MOVFF  02,294
12E8:  MOVFF  01,293
12EC:  MOVFF  00,292
....................    _c5 = 0.00000019073486328125 * ac5;  // (pow2(-15)/160) * ac5;  
12F0:  MOVFF  281,33E
12F4:  MOVFF  280,33D
12F8:  CALL   0A0A
12FC:  MOVLW  CD
12FE:  MOVLB  3
1300:  MOVWF  x55
1302:  MOVLW  CC
1304:  MOVWF  x54
1306:  MOVLW  4C
1308:  MOVWF  x53
130A:  MOVLW  68
130C:  MOVWF  x52
130E:  MOVFF  03,359
1312:  MOVFF  02,358
1316:  MOVFF  01,357
131A:  MOVFF  00,356
131E:  MOVLB  0
1320:  RCALL  0D56
1322:  MOVFF  03,29D
1326:  MOVFF  02,29C
132A:  MOVFF  01,29B
132E:  MOVFF  00,29A
....................    _c6 = (float)ac6;  
1332:  MOVFF  283,33E
1336:  MOVFF  282,33D
133A:  CALL   0A0A
133E:  MOVFF  03,2A1
1342:  MOVFF  02,2A0
1346:  MOVFF  01,29F
134A:  MOVFF  00,29E
....................    _b1 = 0.00002384185791015625 * b1;   // 25600 * pow2(-30) * b1;  
134E:  MOVFF  285,337
1352:  MOVFF  284,336
1356:  RCALL  115C
1358:  MOVLB  3
135A:  CLRF   x55
135C:  CLRF   x54
135E:  MOVLW  48
1360:  MOVWF  x53
1362:  MOVLW  6F
1364:  MOVWF  x52
1366:  MOVFF  03,359
136A:  MOVFF  02,358
136E:  MOVFF  01,357
1372:  MOVFF  00,356
1376:  MOVLB  0
1378:  RCALL  0D56
137A:  MOVFF  03,299
137E:  MOVFF  02,298
1382:  MOVFF  01,297
1386:  MOVFF  00,296
....................    _mc = 0.08 * mc;                     // (pow2(11) / 25600) * mc;  
138A:  MOVFF  28B,337
138E:  MOVFF  28A,336
1392:  RCALL  115C
1394:  MOVLW  0A
1396:  MOVLB  3
1398:  MOVWF  x55
139A:  MOVLW  D7
139C:  MOVWF  x54
139E:  MOVLW  23
13A0:  MOVWF  x53
13A2:  MOVLW  7B
13A4:  MOVWF  x52
13A6:  MOVFF  03,359
13AA:  MOVFF  02,358
13AE:  MOVFF  01,357
13B2:  MOVFF  00,356
13B6:  MOVLB  0
13B8:  RCALL  0D56
13BA:  MOVFF  03,2A5
13BE:  MOVFF  02,2A4
13C2:  MOVFF  01,2A3
13C6:  MOVFF  00,2A2
....................    _md = (float)md / 160;  
13CA:  MOVFF  28D,337
13CE:  MOVFF  28C,336
13D2:  RCALL  115C
13D4:  MOVFF  03,339
13D8:  MOVFF  02,338
13DC:  MOVFF  01,337
13E0:  MOVFF  00,336
13E4:  MOVFF  03,355
13E8:  MOVFF  02,354
13EC:  MOVFF  01,353
13F0:  MOVFF  00,352
13F4:  MOVLB  3
13F6:  CLRF   x59
13F8:  CLRF   x58
13FA:  MOVLW  20
13FC:  MOVWF  x57
13FE:  MOVLW  86
1400:  MOVWF  x56
1402:  MOVLB  0
1404:  CALL   0A40
1408:  MOVFF  03,2A9
140C:  MOVFF  02,2A8
1410:  MOVFF  01,2A7
1414:  MOVFF  00,2A6
....................      
....................    // calculate polynomial constants  
....................    _x0 = (float)ac1;  
1418:  MOVFF  279,337
141C:  MOVFF  278,336
1420:  RCALL  115C
1422:  MOVFF  03,2AD
1426:  MOVFF  02,2AC
142A:  MOVFF  01,2AB
142E:  MOVFF  00,2AA
....................    _x1 = 0.01953125 * ac2;             // 160 * pow2(-13) * ac2;  
1432:  MOVFF  27B,337
1436:  MOVFF  27A,336
143A:  RCALL  115C
143C:  MOVLB  3
143E:  CLRF   x55
1440:  CLRF   x54
1442:  MOVLW  20
1444:  MOVWF  x53
1446:  MOVLW  79
1448:  MOVWF  x52
144A:  MOVFF  03,359
144E:  MOVFF  02,358
1452:  MOVFF  01,357
1456:  MOVFF  00,356
145A:  MOVLB  0
145C:  RCALL  0D56
145E:  MOVFF  03,2B1
1462:  MOVFF  02,2B0
1466:  MOVFF  01,2AF
146A:  MOVFF  00,2AE
....................    _x2 = 0.000762939453125 * b2;       // 25600 * pow2(-25) * b2;  
146E:  MOVFF  287,337
1472:  MOVFF  286,336
1476:  RCALL  115C
1478:  MOVLB  3
147A:  CLRF   x55
147C:  CLRF   x54
147E:  MOVLW  48
1480:  MOVWF  x53
1482:  MOVLW  74
1484:  MOVWF  x52
1486:  MOVFF  03,359
148A:  MOVFF  02,358
148E:  MOVFF  01,357
1492:  MOVFF  00,356
1496:  MOVLB  0
1498:  RCALL  0D56
149A:  MOVFF  03,2B5
149E:  MOVFF  02,2B4
14A2:  MOVFF  01,2B3
14A6:  MOVFF  00,2B2
....................    _y0 = _c4 * 32768;                  //_c4 * pow2(15);  
14AA:  MOVFF  295,355
14AE:  MOVFF  294,354
14B2:  MOVFF  293,353
14B6:  MOVFF  292,352
14BA:  MOVLB  3
14BC:  CLRF   x59
14BE:  CLRF   x58
14C0:  CLRF   x57
14C2:  MOVLW  8E
14C4:  MOVWF  x56
14C6:  MOVLB  0
14C8:  RCALL  0D56
14CA:  MOVFF  03,2B9
14CE:  MOVFF  02,2B8
14D2:  MOVFF  01,2B7
14D6:  MOVFF  00,2B6
....................    _y1 = _c4 * _c3;  
14DA:  MOVFF  295,355
14DE:  MOVFF  294,354
14E2:  MOVFF  293,353
14E6:  MOVFF  292,352
14EA:  MOVFF  291,359
14EE:  MOVFF  290,358
14F2:  MOVFF  28F,357
14F6:  MOVFF  28E,356
14FA:  RCALL  0D56
14FC:  MOVFF  03,2BD
1500:  MOVFF  02,2BC
1504:  MOVFF  01,2BB
1508:  MOVFF  00,2BA
....................    _y2 = _c4 * _b1;  
150C:  MOVFF  295,355
1510:  MOVFF  294,354
1514:  MOVFF  293,353
1518:  MOVFF  292,352
151C:  MOVFF  299,359
1520:  MOVFF  298,358
1524:  MOVFF  297,357
1528:  MOVFF  296,356
152C:  RCALL  0D56
152E:  MOVFF  03,2C1
1532:  MOVFF  02,2C0
1536:  MOVFF  01,2BF
153A:  MOVFF  00,2BE
....................    _p0 = 2.364375;   
153E:  MOVLW  EC
1540:  MOVLB  2
1542:  MOVWF  xC5
1544:  MOVLW  51
1546:  MOVWF  xC4
1548:  MOVLW  17
154A:  MOVWF  xC3
154C:  MOVLW  80
154E:  MOVWF  xC2
....................    _p1 = 0.992984;  
1550:  MOVLW  33
1552:  MOVWF  xC9
1554:  MOVLW  34
1556:  MOVWF  xC8
1558:  MOVLW  7E
155A:  MOVWF  xC7
155C:  MOVWF  xC6
....................    _p2 = 0.000004421;     
155E:  MOVLW  1A
1560:  MOVWF  xCD
1562:  MOVLW  58
1564:  MOVWF  xCC
1566:  MOVLW  14
1568:  MOVWF  xCB
156A:  MOVLW  6D
156C:  MOVWF  xCA
156E:  MOVLB  0
1570:  GOTO   5E0A (RETURN)
.................... }  
....................  
....................  
.................... // Read the uncompensated temperature value  
.................... //----------------------------------------------  
.................... int16 BMP085ReadUT()  
.................... //----------------------------------------------  
.................... {  
.................... int16 ut;  
....................    
....................   // Write 0x2E into Register 0xF4  
....................   BMP085WriteByte(0xF4, 0x2E);  
*
15F4:  MOVLW  F4
15F6:  MOVLB  3
15F8:  MOVWF  x3D
15FA:  MOVLW  2E
15FC:  MOVWF  x3E
15FE:  MOVLB  0
1600:  RCALL  1574
....................   delay_ms(5); // Wait at least 4.5ms  
1602:  MOVLW  05
1604:  MOVLB  3
1606:  MOVWF  x5E
1608:  MOVLB  0
160A:  CALL   0882
....................   // Read two bytes from registers 0xF6 and 0xF7  
....................   ut = BMP085ReadInt(0xF6);  
160E:  MOVLW  F6
1610:  MOVLB  3
1612:  MOVWF  x38
1614:  MOVLB  0
1616:  RCALL  10D4
1618:  MOVFF  02,337
161C:  MOVFF  01,336
....................   return((float)ut);  
1620:  MOVFF  337,33E
1624:  MOVFF  336,33D
1628:  CALL   0A0A
162C:  MOVFF  03,33B
1630:  MOVFF  02,33A
1634:  MOVFF  01,339
1638:  MOVFF  00,338
163C:  RCALL  15B8
163E:  MOVF   02,W
1640:  RETURN 0
.................... }  
....................  
....................  
.................... // Read the uncompensated pressure value  
.................... //----------------------------------------------  
.................... int32 bmp085ReadUP()  
.................... //----------------------------------------------  
.................... {  
.................... int8 msb, lsb, xlsb;  
.................... float p;  
....................    
....................   // Write 0x34+(OSS<<6) into register 0xF4  
....................   // Request a pressure reading w/ oversampling setting  
....................   BMP085WriteByte(0xF4, (0x34 + (OVS_S<<6)) );  
*
1A98:  MOVLW  F4
1A9A:  MOVLB  3
1A9C:  MOVWF  x3D
1A9E:  MOVWF  x3E
1AA0:  MOVLB  0
1AA2:  RCALL  1574
....................    
....................   // Wait for conversion, delay time dependent on OSS  
....................   switch (OVS_S)  
....................   {  
....................      case 0: delay_ms(5);  break;  
....................      case 1: delay_ms(8);  break;  
....................      case 2: delay_ms(14); break;  
....................      case 3: delay_ms(26); break;  
1AA4:  MOVLW  1A
1AA6:  MOVLB  3
1AA8:  MOVWF  x5E
1AAA:  MOVLB  0
1AAC:  CALL   0882
....................   }     
....................    
....................   // Read register 0xF6 (MSB), 0xF7 (LSB), and 0xF8 (XLSB)  
....................    msb  = BMP085ReadByte(0xF6);  
1AB0:  MOVLW  F6
1AB2:  MOVLB  3
1AB4:  MOVWF  x3D
1AB6:  MOVLB  0
1AB8:  RCALL  1A28
1ABA:  MOVFF  01,336
....................    lsb  = BMP085ReadByte(0xF7);  
1ABE:  MOVLW  F7
1AC0:  MOVLB  3
1AC2:  MOVWF  x3D
1AC4:  MOVLB  0
1AC6:  RCALL  1A28
1AC8:  MOVFF  01,337
....................    xlsb = BMP085ReadByte(0xF8);  
1ACC:  MOVLW  F8
1ACE:  MOVLB  3
1AD0:  MOVWF  x3D
1AD2:  MOVLB  0
1AD4:  RCALL  1A28
1AD6:  MOVFF  01,338
....................    p = (256*msb) + lsb + (xlsb/256);  
1ADA:  CLRF   03
1ADC:  MOVLB  3
1ADE:  MOVFF  336,33E
1AE2:  CLRF   x3D
1AE4:  MOVF   x37,W
1AE6:  ADDWF  x3D,F
1AE8:  MOVLW  00
1AEA:  ADDWFC x3E,F
1AEC:  CLRF   03
1AEE:  ADDWF  x3D,W
1AF0:  MOVWF  01
1AF2:  MOVF   x3E,W
1AF4:  ADDWFC 03,F
1AF6:  MOVFF  01,33D
1AFA:  MOVFF  03,33E
1AFE:  MOVLB  0
1B00:  CALL   0A0A
1B04:  MOVFF  03,33C
1B08:  MOVFF  02,33B
1B0C:  MOVFF  01,33A
1B10:  MOVFF  00,339
....................    return(p);  
1B14:  MOVFF  33C,34B
1B18:  MOVFF  33B,34A
1B1C:  MOVFF  33A,349
1B20:  MOVFF  339,348
1B24:  CALL   0E4C
1B28:  GOTO   1F3C (RETURN)
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085GetTemp(float _tu)  
.................... //----------------------------------------------  
.................... {  
.................... float alpha, T;  
....................  
....................    alpha = _c5 * (_tu - _c6);  
*
18BA:  BSF    FD8.1
18BC:  MOVFF  33D,355
18C0:  MOVFF  33C,354
18C4:  MOVFF  33B,353
18C8:  MOVFF  33A,352
18CC:  MOVFF  2A1,359
18D0:  MOVFF  2A0,358
18D4:  MOVFF  29F,357
18D8:  MOVFF  29E,356
18DC:  RCALL  1642
18DE:  MOVFF  29D,355
18E2:  MOVFF  29C,354
18E6:  MOVFF  29B,353
18EA:  MOVFF  29A,352
18EE:  MOVFF  03,359
18F2:  MOVFF  02,358
18F6:  MOVFF  01,357
18FA:  MOVFF  00,356
18FE:  CALL   0D56
1902:  MOVFF  03,341
1906:  MOVFF  02,340
190A:  MOVFF  01,33F
190E:  MOVFF  00,33E
....................    T = alpha + (_mc/(alpha + _md));  
1912:  BCF    FD8.1
1914:  MOVFF  341,355
1918:  MOVFF  340,354
191C:  MOVFF  33F,353
1920:  MOVFF  33E,352
1924:  MOVFF  2A9,359
1928:  MOVFF  2A8,358
192C:  MOVFF  2A7,357
1930:  MOVFF  2A6,356
1934:  RCALL  1642
1936:  MOVFF  2A5,355
193A:  MOVFF  2A4,354
193E:  MOVFF  2A3,353
1942:  MOVFF  2A2,352
1946:  MOVFF  03,359
194A:  MOVFF  02,358
194E:  MOVFF  01,357
1952:  MOVFF  00,356
1956:  CALL   0A40
195A:  BCF    FD8.1
195C:  MOVFF  341,355
1960:  MOVFF  340,354
1964:  MOVFF  33F,353
1968:  MOVFF  33E,352
196C:  MOVFF  03,359
1970:  MOVFF  02,358
1974:  MOVFF  01,357
1978:  MOVFF  00,356
197C:  RCALL  1642
197E:  MOVFF  03,345
1982:  MOVFF  02,344
1986:  MOVFF  01,343
198A:  MOVFF  00,342
....................    _s = T - 25;  
198E:  BSF    FD8.1
1990:  MOVFF  345,355
1994:  MOVFF  344,354
1998:  MOVFF  343,353
199C:  MOVFF  342,352
19A0:  MOVLB  3
19A2:  CLRF   x59
19A4:  CLRF   x58
19A6:  MOVLW  48
19A8:  MOVWF  x57
19AA:  MOVLW  83
19AC:  MOVWF  x56
19AE:  MOVLB  0
19B0:  RCALL  1642
19B2:  MOVFF  03,2D1
19B6:  MOVFF  02,2D0
19BA:  MOVFF  01,2CF
19BE:  MOVFF  00,2CE
....................    return(T);  
19C2:  MOVFF  342,00
19C6:  MOVFF  343,01
19CA:  MOVFF  344,02
19CE:  MOVFF  345,03
19D2:  RETURN 0
.................... }     
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085GetPressure(float _pu)  
.................... //----------------------------------------------  
.................... {  
.................... float x, y, z;  
.................... float P;  
....................  
....................    x = _x2*_s*_s + _x1*_s + _x0;  
*
1B66:  MOVFF  2B5,355
1B6A:  MOVFF  2B4,354
1B6E:  MOVFF  2B3,353
1B72:  MOVFF  2B2,352
1B76:  MOVFF  2D1,359
1B7A:  MOVFF  2D0,358
1B7E:  MOVFF  2CF,357
1B82:  MOVFF  2CE,356
1B86:  CALL   0D56
1B8A:  MOVFF  03,351
1B8E:  MOVFF  02,350
1B92:  MOVFF  01,34F
1B96:  MOVFF  00,34E
1B9A:  MOVFF  03,355
1B9E:  MOVFF  02,354
1BA2:  MOVFF  01,353
1BA6:  MOVFF  00,352
1BAA:  MOVFF  2D1,359
1BAE:  MOVFF  2D0,358
1BB2:  MOVFF  2CF,357
1BB6:  MOVFF  2CE,356
1BBA:  CALL   0D56
1BBE:  MOVFF  03,351
1BC2:  MOVFF  02,350
1BC6:  MOVFF  01,34F
1BCA:  MOVFF  00,34E
1BCE:  MOVFF  2B1,355
1BD2:  MOVFF  2B0,354
1BD6:  MOVFF  2AF,353
1BDA:  MOVFF  2AE,352
1BDE:  MOVFF  2D1,359
1BE2:  MOVFF  2D0,358
1BE6:  MOVFF  2CF,357
1BEA:  MOVFF  2CE,356
1BEE:  CALL   0D56
1BF2:  BCF    FD8.1
1BF4:  MOVFF  351,355
1BF8:  MOVFF  350,354
1BFC:  MOVFF  34F,353
1C00:  MOVFF  34E,352
1C04:  MOVFF  03,359
1C08:  MOVFF  02,358
1C0C:  MOVFF  01,357
1C10:  MOVFF  00,356
1C14:  RCALL  1642
1C16:  MOVFF  03,351
1C1A:  MOVFF  02,350
1C1E:  MOVFF  01,34F
1C22:  MOVFF  00,34E
1C26:  BCF    FD8.1
1C28:  MOVFF  03,355
1C2C:  MOVFF  02,354
1C30:  MOVFF  01,353
1C34:  MOVFF  00,352
1C38:  MOVFF  2AD,359
1C3C:  MOVFF  2AC,358
1C40:  MOVFF  2AB,357
1C44:  MOVFF  2AA,356
1C48:  RCALL  1642
1C4A:  MOVFF  03,341
1C4E:  MOVFF  02,340
1C52:  MOVFF  01,33F
1C56:  MOVFF  00,33E
....................    y = _y2*_s*_s + _y1*_s + _y0;  
1C5A:  MOVFF  2C1,355
1C5E:  MOVFF  2C0,354
1C62:  MOVFF  2BF,353
1C66:  MOVFF  2BE,352
1C6A:  MOVFF  2D1,359
1C6E:  MOVFF  2D0,358
1C72:  MOVFF  2CF,357
1C76:  MOVFF  2CE,356
1C7A:  CALL   0D56
1C7E:  MOVFF  03,351
1C82:  MOVFF  02,350
1C86:  MOVFF  01,34F
1C8A:  MOVFF  00,34E
1C8E:  MOVFF  03,355
1C92:  MOVFF  02,354
1C96:  MOVFF  01,353
1C9A:  MOVFF  00,352
1C9E:  MOVFF  2D1,359
1CA2:  MOVFF  2D0,358
1CA6:  MOVFF  2CF,357
1CAA:  MOVFF  2CE,356
1CAE:  CALL   0D56
1CB2:  MOVFF  03,351
1CB6:  MOVFF  02,350
1CBA:  MOVFF  01,34F
1CBE:  MOVFF  00,34E
1CC2:  MOVFF  2BD,355
1CC6:  MOVFF  2BC,354
1CCA:  MOVFF  2BB,353
1CCE:  MOVFF  2BA,352
1CD2:  MOVFF  2D1,359
1CD6:  MOVFF  2D0,358
1CDA:  MOVFF  2CF,357
1CDE:  MOVFF  2CE,356
1CE2:  CALL   0D56
1CE6:  BCF    FD8.1
1CE8:  MOVFF  351,355
1CEC:  MOVFF  350,354
1CF0:  MOVFF  34F,353
1CF4:  MOVFF  34E,352
1CF8:  MOVFF  03,359
1CFC:  MOVFF  02,358
1D00:  MOVFF  01,357
1D04:  MOVFF  00,356
1D08:  RCALL  1642
1D0A:  MOVFF  03,351
1D0E:  MOVFF  02,350
1D12:  MOVFF  01,34F
1D16:  MOVFF  00,34E
1D1A:  BCF    FD8.1
1D1C:  MOVFF  03,355
1D20:  MOVFF  02,354
1D24:  MOVFF  01,353
1D28:  MOVFF  00,352
1D2C:  MOVFF  2B9,359
1D30:  MOVFF  2B8,358
1D34:  MOVFF  2B7,357
1D38:  MOVFF  2B6,356
1D3C:  RCALL  1642
1D3E:  MOVFF  03,345
1D42:  MOVFF  02,344
1D46:  MOVFF  01,343
1D4A:  MOVFF  00,342
....................    z = ((float)_pu - x) / y;  
1D4E:  BSF    FD8.1
1D50:  MOVFF  33D,355
1D54:  MOVFF  33C,354
1D58:  MOVFF  33B,353
1D5C:  MOVFF  33A,352
1D60:  MOVFF  341,359
1D64:  MOVFF  340,358
1D68:  MOVFF  33F,357
1D6C:  MOVFF  33E,356
1D70:  RCALL  1642
1D72:  MOVFF  03,351
1D76:  MOVFF  02,350
1D7A:  MOVFF  01,34F
1D7E:  MOVFF  00,34E
1D82:  MOVFF  03,355
1D86:  MOVFF  02,354
1D8A:  MOVFF  01,353
1D8E:  MOVFF  00,352
1D92:  MOVFF  345,359
1D96:  MOVFF  344,358
1D9A:  MOVFF  343,357
1D9E:  MOVFF  342,356
1DA2:  CALL   0A40
1DA6:  MOVFF  03,349
1DAA:  MOVFF  02,348
1DAE:  MOVFF  01,347
1DB2:  MOVFF  00,346
....................    P = _p2*z*z + _p1*z + _p0;  
1DB6:  MOVFF  2CD,355
1DBA:  MOVFF  2CC,354
1DBE:  MOVFF  2CB,353
1DC2:  MOVFF  2CA,352
1DC6:  MOVFF  349,359
1DCA:  MOVFF  348,358
1DCE:  MOVFF  347,357
1DD2:  MOVFF  346,356
1DD6:  CALL   0D56
1DDA:  MOVFF  03,351
1DDE:  MOVFF  02,350
1DE2:  MOVFF  01,34F
1DE6:  MOVFF  00,34E
1DEA:  MOVFF  03,355
1DEE:  MOVFF  02,354
1DF2:  MOVFF  01,353
1DF6:  MOVFF  00,352
1DFA:  MOVFF  349,359
1DFE:  MOVFF  348,358
1E02:  MOVFF  347,357
1E06:  MOVFF  346,356
1E0A:  CALL   0D56
1E0E:  MOVFF  03,351
1E12:  MOVFF  02,350
1E16:  MOVFF  01,34F
1E1A:  MOVFF  00,34E
1E1E:  MOVFF  2C9,355
1E22:  MOVFF  2C8,354
1E26:  MOVFF  2C7,353
1E2A:  MOVFF  2C6,352
1E2E:  MOVFF  349,359
1E32:  MOVFF  348,358
1E36:  MOVFF  347,357
1E3A:  MOVFF  346,356
1E3E:  CALL   0D56
1E42:  BCF    FD8.1
1E44:  MOVFF  351,355
1E48:  MOVFF  350,354
1E4C:  MOVFF  34F,353
1E50:  MOVFF  34E,352
1E54:  MOVFF  03,359
1E58:  MOVFF  02,358
1E5C:  MOVFF  01,357
1E60:  MOVFF  00,356
1E64:  CALL   1642
1E68:  MOVFF  03,351
1E6C:  MOVFF  02,350
1E70:  MOVFF  01,34F
1E74:  MOVFF  00,34E
1E78:  BCF    FD8.1
1E7A:  MOVFF  03,355
1E7E:  MOVFF  02,354
1E82:  MOVFF  01,353
1E86:  MOVFF  00,352
1E8A:  MOVFF  2C5,359
1E8E:  MOVFF  2C4,358
1E92:  MOVFF  2C3,357
1E96:  MOVFF  2C2,356
1E9A:  CALL   1642
1E9E:  MOVFF  03,34D
1EA2:  MOVFF  02,34C
1EA6:  MOVFF  01,34B
1EAA:  MOVFF  00,34A
....................    P += P_CORRECTION;  
1EAE:  BCF    FD8.1
1EB0:  MOVFF  34D,355
1EB4:  MOVFF  34C,354
1EB8:  MOVFF  34B,353
1EBC:  MOVFF  34A,352
1EC0:  MOVLB  3
1EC2:  CLRF   x59
1EC4:  CLRF   x58
1EC6:  MOVLW  40
1EC8:  MOVWF  x57
1ECA:  MOVLW  7F
1ECC:  MOVWF  x56
1ECE:  MOVLB  0
1ED0:  CALL   1642
1ED4:  MOVFF  03,34D
1ED8:  MOVFF  02,34C
1EDC:  MOVFF  01,34B
1EE0:  MOVFF  00,34A
....................    return(P);  
1EE4:  MOVFF  34A,00
1EE8:  MOVFF  34B,01
1EEC:  MOVFF  34C,02
1EF0:  MOVFF  34D,03
1EF4:  GOTO   1F70 (RETURN)
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... int BMP085GetPressure_m(float _pu)  
.................... //----------------------------------------------  
.................... {  
.................... float x, y, z;  
.................... int P;  
....................  
....................    x = _x2*_s*_s + _x1*_s + _x0;  
....................    y = _y2*_s*_s + _y1*_s + _y0;  
....................    z = ((float)_pu - x) / y;  
....................    P = _p2*z*z + _p1*z + _p0;  
....................    P += P_CORRECTION;  
....................    return(P);  
.................... } 
....................  
....................  
.................... //!//----------------------------------------------  
.................... //!float BMP085Pressure(boolean getTemp)  
.................... //!//----------------------------------------------  
.................... //!{  
.................... //!   if (getTemp)  
.................... //!      _Temp = BMP085GetTemp(BMP085ReadUT());  // creates _s required for pressure calculation  
.................... //!   return(BMP085GetPressure(BMP085ReadUP()));  
.................... //!}  
.................... //! 
....................  
.................... //----------------------------------------------  
.................... float BMP085Pressure(void)  
.................... //----------------------------------------------  
.................... {  
....................     _Temp = BMP085GetTemp(BMP085ReadUT());  // creates _s required for pressure calculation  
1EF8:  CALL   15F4
1EFC:  MOVFF  02,33E
1F00:  MOVFF  01,33D
1F04:  CALL   0A0A
1F08:  MOVFF  03,339
1F0C:  MOVFF  02,338
1F10:  MOVFF  01,337
1F14:  MOVFF  00,336
1F18:  MOVFF  03,33D
1F1C:  MOVFF  02,33C
1F20:  MOVFF  01,33B
1F24:  MOVFF  00,33A
1F28:  RCALL  18BA
1F2A:  MOVFF  03,2D5
1F2E:  MOVFF  02,2D4
1F32:  MOVFF  01,2D3
1F36:  MOVFF  00,2D2
....................    return(BMP085GetPressure(bmp085ReadUP()));  
1F3A:  BRA    1A98
1F3C:  MOVFF  03,339
1F40:  MOVFF  02,338
1F44:  MOVFF  01,337
1F48:  MOVFF  00,336
1F4C:  BRA    1B2C
1F4E:  MOVFF  03,339
1F52:  MOVFF  02,338
1F56:  MOVFF  01,337
1F5A:  MOVFF  00,336
1F5E:  MOVFF  03,33D
1F62:  MOVFF  02,33C
1F66:  MOVFF  01,33B
1F6A:  MOVFF  00,33A
1F6E:  BRA    1B66
1F70:  GOTO   5E3A (RETURN)
.................... }  
....................  
.................... //----------------------------------------------  
.................... int BMP085Pressure_m(void)  
.................... //----------------------------------------------  
.................... {  
....................     _Temp = BMP085GetTemp(BMP085ReadUT());  // creates _s required for pressure calculation  
....................    return(BMP085GetPressure_m(bmp085ReadUP()));  
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085Temperature(void)  
.................... //----------------------------------------------  
.................... {  
....................    _Temp = BMP085GetTemp(BMP085ReadUT());  
*
19D4:  RCALL  15F4
19D6:  MOVFF  02,33E
19DA:  MOVFF  01,33D
19DE:  CALL   0A0A
19E2:  MOVFF  03,339
19E6:  MOVFF  02,338
19EA:  MOVFF  01,337
19EE:  MOVFF  00,336
19F2:  MOVFF  03,33D
19F6:  MOVFF  02,33C
19FA:  MOVFF  01,33B
19FE:  MOVFF  00,33A
1A02:  RCALL  18BA
1A04:  MOVFF  03,2D5
1A08:  MOVFF  02,2D4
1A0C:  MOVFF  01,2D3
1A10:  MOVFF  00,2D2
....................    return(_Temp);  
1A14:  MOVFF  2D2,00
1A18:  MOVFF  2D3,01
1A1C:  MOVFF  2D4,02
1A20:  MOVFF  2D5,03
1A24:  GOTO   5E26 (RETURN)
.................... }  
....................  
.................... #include <ads1115.c> 
.................... BYTE ld,hd; //21845 
.................... int16 d; 
.................... float v1,v2,v3; 
....................  
.................... float datov0(){ 
....................    d = 0; 
*
216E:  MOVLB  2
2170:  CLRF   xD9
2172:  CLRF   xD8
....................    v1 = 0; 
2174:  CLRF   xDD
2176:  CLRF   xDC
2178:  CLRF   xDB
217A:  CLRF   xDA
....................    i2c_start(); 
217C:  BSF    F92.1
217E:  NOP   
2180:  BSF    F92.0
2182:  NOP   
2184:  BCF    F89.1
2186:  BCF    F92.1
2188:  NOP   
218A:  BCF    F89.0
218C:  BCF    F92.0
....................    i2c_write(0b10010000);  //llamado por direccion 
218E:  MOVLW  90
2190:  MOVLB  3
2192:  MOVWF  x3F
2194:  MOVLB  0
2196:  CALL   04AC
....................    i2c_write(0b00000001);  //llamado de configuracion de registro 
219A:  MOVLW  01
219C:  MOVLB  3
219E:  MOVWF  x3F
21A0:  MOVLB  0
21A2:  CALL   04AC
....................    i2c_write(0b11010000);  // 101 
21A6:  MOVLW  D0
21A8:  MOVLB  3
21AA:  MOVWF  x3F
21AC:  MOVLB  0
21AE:  CALL   04AC
....................    i2c_write(0b11000011);  //10000011 // 11100011 
21B2:  MOVLW  C3
21B4:  MOVLB  3
21B6:  MOVWF  x3F
21B8:  MOVLB  0
21BA:  CALL   04AC
....................    i2c_stop(); 
21BE:  BCF    F92.1
21C0:  NOP   
21C2:  BSF    F92.0
21C4:  BTFSS  F80.0
21C6:  BRA    21C4
21C8:  NOP   
21CA:  BRA    21CC
21CC:  NOP   
21CE:  BSF    F92.1
21D0:  NOP   
....................     
....................    i2c_start(); 
21D2:  BSF    F92.1
21D4:  NOP   
21D6:  BSF    F92.0
21D8:  NOP   
21DA:  BCF    F89.1
21DC:  BCF    F92.1
21DE:  NOP   
21E0:  BCF    F89.0
21E2:  BCF    F92.0
....................    i2c_write(0b10010000);  //frame 1 
21E4:  MOVLW  90
21E6:  MOVLB  3
21E8:  MOVWF  x3F
21EA:  MOVLB  0
21EC:  CALL   04AC
....................    i2c_write(0b00000000);  //frame 2 
21F0:  MOVLB  3
21F2:  CLRF   x3F
21F4:  MOVLB  0
21F6:  CALL   04AC
....................    i2c_stop(); 
21FA:  BCF    F92.1
21FC:  NOP   
21FE:  BSF    F92.0
2200:  BTFSS  F80.0
2202:  BRA    2200
2204:  NOP   
2206:  BRA    2208
2208:  NOP   
220A:  BSF    F92.1
220C:  NOP   
....................     
....................    i2c_start(); 
220E:  BSF    F92.1
2210:  NOP   
2212:  BSF    F92.0
2214:  NOP   
2216:  BCF    F89.1
2218:  BCF    F92.1
221A:  NOP   
221C:  BCF    F89.0
221E:  BCF    F92.0
....................    i2c_write(0b10010001);  //frame 3 
2220:  MOVLW  91
2222:  MOVLB  3
2224:  MOVWF  x3F
2226:  MOVLB  0
2228:  CALL   04AC
....................    hd = i2c_read(1); 
222C:  MOVLW  01
222E:  MOVWF  00
2230:  CALL   04FE
2234:  MOVFF  01,2D7
....................    ld = i2c_read(1); 
2238:  MOVLW  01
223A:  MOVWF  00
223C:  CALL   04FE
2240:  MOVFF  01,2D6
....................    i2c_stop(); 
2244:  BCF    F92.1
2246:  NOP   
2248:  BSF    F92.0
224A:  BTFSS  F80.0
224C:  BRA    224A
224E:  NOP   
2250:  BRA    2252
2252:  NOP   
2254:  BSF    F92.1
2256:  NOP   
....................     
....................    d=hd<<8; 
2258:  MOVFF  2D7,2D9
225C:  MOVLB  2
225E:  CLRF   xD8
....................    d|=ld; 
2260:  MOVF   xD6,W
2262:  IORWF  xD8,F
....................    if(d<30000){ 
2264:  MOVF   xD9,W
2266:  SUBLW  75
2268:  BNC   22CE
226A:  BNZ   2272
226C:  MOVF   xD8,W
226E:  SUBLW  2F
2270:  BNC   22CE
....................       return v1 = (0.000187371)*d; //000305175 
2272:  MOVFF  2D9,33E
2276:  MOVFF  2D8,33D
227A:  MOVLB  0
227C:  CALL   0A0A
2280:  MOVLW  05
2282:  MOVLB  3
2284:  MOVWF  x55
2286:  MOVLW  79
2288:  MOVWF  x54
228A:  MOVLW  44
228C:  MOVWF  x53
228E:  MOVLW  72
2290:  MOVWF  x52
2292:  MOVFF  03,359
2296:  MOVFF  02,358
229A:  MOVFF  01,357
229E:  MOVFF  00,356
22A2:  MOVLB  0
22A4:  CALL   0D56
22A8:  MOVFF  03,2DD
22AC:  MOVFF  02,2DC
22B0:  MOVFF  01,2DB
22B4:  MOVFF  00,2DA
22B8:  MOVFF  2DA,00
22BC:  MOVFF  2DB,01
22C0:  MOVFF  2DC,02
22C4:  MOVFF  2DD,03
22C8:  BRA    22E8
....................    } 
22CA:  BRA    22E8
22CC:  MOVLB  2
....................    else{ 
....................       return v1 = 0.00000; 
22CE:  CLRF   xDD
22D0:  CLRF   xDC
22D2:  CLRF   xDB
22D4:  CLRF   xDA
22D6:  MOVFF  2DA,00
22DA:  MOVFF  2DB,01
22DE:  MOVFF  2DC,02
22E2:  MOVFF  2DD,03
22E6:  MOVLB  0
....................    } 
22E8:  GOTO   5EFA (RETURN)
.................... } 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... float datov1(){ 
....................    d = 0; 
22EC:  MOVLB  2
22EE:  CLRF   xD9
22F0:  CLRF   xD8
....................    v2 = 0; 
22F2:  CLRF   xE1
22F4:  CLRF   xE0
22F6:  CLRF   xDF
22F8:  CLRF   xDE
....................    i2c_start(); 
22FA:  BSF    F92.1
22FC:  NOP   
22FE:  BSF    F92.0
2300:  NOP   
2302:  BCF    F89.1
2304:  BCF    F92.1
2306:  NOP   
2308:  BCF    F89.0
230A:  BCF    F92.0
....................    i2c_write(0b10010000);  //llamado por direccion 
230C:  MOVLW  90
230E:  MOVLB  3
2310:  MOVWF  x3F
2312:  MOVLB  0
2314:  CALL   04AC
....................    i2c_write(0b00000001);  //llamado de configuracion de registro 
2318:  MOVLW  01
231A:  MOVLB  3
231C:  MOVWF  x3F
231E:  MOVLB  0
2320:  CALL   04AC
....................    i2c_write(0b11100000);  //100 
2324:  MOVLW  E0
2326:  MOVLB  3
2328:  MOVWF  x3F
232A:  MOVLB  0
232C:  CALL   04AC
....................    i2c_write(0b11000011);  // 
2330:  MOVLW  C3
2332:  MOVLB  3
2334:  MOVWF  x3F
2336:  MOVLB  0
2338:  CALL   04AC
....................    i2c_stop(); 
233C:  BCF    F92.1
233E:  NOP   
2340:  BSF    F92.0
2342:  BTFSS  F80.0
2344:  BRA    2342
2346:  NOP   
2348:  BRA    234A
234A:  NOP   
234C:  BSF    F92.1
234E:  NOP   
....................     
....................    i2c_start(); 
2350:  BSF    F92.1
2352:  NOP   
2354:  BSF    F92.0
2356:  NOP   
2358:  BCF    F89.1
235A:  BCF    F92.1
235C:  NOP   
235E:  BCF    F89.0
2360:  BCF    F92.0
....................    i2c_write(0b10010000);  //frame 1 
2362:  MOVLW  90
2364:  MOVLB  3
2366:  MOVWF  x3F
2368:  MOVLB  0
236A:  CALL   04AC
....................    i2c_write(0b00000000);  //frame 2 
236E:  MOVLB  3
2370:  CLRF   x3F
2372:  MOVLB  0
2374:  CALL   04AC
....................    i2c_stop(); 
2378:  BCF    F92.1
237A:  NOP   
237C:  BSF    F92.0
237E:  BTFSS  F80.0
2380:  BRA    237E
2382:  NOP   
2384:  BRA    2386
2386:  NOP   
2388:  BSF    F92.1
238A:  NOP   
....................     
....................    i2c_start(); 
238C:  BSF    F92.1
238E:  NOP   
2390:  BSF    F92.0
2392:  NOP   
2394:  BCF    F89.1
2396:  BCF    F92.1
2398:  NOP   
239A:  BCF    F89.0
239C:  BCF    F92.0
....................    i2c_write(0b10010001);  //frame 3 
239E:  MOVLW  91
23A0:  MOVLB  3
23A2:  MOVWF  x3F
23A4:  MOVLB  0
23A6:  CALL   04AC
....................    hd = i2c_read(1); 
23AA:  MOVLW  01
23AC:  MOVWF  00
23AE:  CALL   04FE
23B2:  MOVFF  01,2D7
....................    ld = i2c_read(1); 
23B6:  MOVLW  01
23B8:  MOVWF  00
23BA:  CALL   04FE
23BE:  MOVFF  01,2D6
....................    i2c_stop(); 
23C2:  BCF    F92.1
23C4:  NOP   
23C6:  BSF    F92.0
23C8:  BTFSS  F80.0
23CA:  BRA    23C8
23CC:  NOP   
23CE:  BRA    23D0
23D0:  NOP   
23D2:  BSF    F92.1
23D4:  NOP   
....................     
....................    d=hd<<8; 
23D6:  MOVFF  2D7,2D9
23DA:  MOVLB  2
23DC:  CLRF   xD8
....................    d|=ld; 
23DE:  MOVF   xD6,W
23E0:  IORWF  xD8,F
....................    if(d<30000){ 
23E2:  MOVF   xD9,W
23E4:  SUBLW  75
23E6:  BNC   244C
23E8:  BNZ   23F0
23EA:  MOVF   xD8,W
23EC:  SUBLW  2F
23EE:  BNC   244C
....................       return v2 = (0.000187371)*d; 
23F0:  MOVFF  2D9,33E
23F4:  MOVFF  2D8,33D
23F8:  MOVLB  0
23FA:  CALL   0A0A
23FE:  MOVLW  05
2400:  MOVLB  3
2402:  MOVWF  x55
2404:  MOVLW  79
2406:  MOVWF  x54
2408:  MOVLW  44
240A:  MOVWF  x53
240C:  MOVLW  72
240E:  MOVWF  x52
2410:  MOVFF  03,359
2414:  MOVFF  02,358
2418:  MOVFF  01,357
241C:  MOVFF  00,356
2420:  MOVLB  0
2422:  CALL   0D56
2426:  MOVFF  03,2E1
242A:  MOVFF  02,2E0
242E:  MOVFF  01,2DF
2432:  MOVFF  00,2DE
2436:  MOVFF  2DE,00
243A:  MOVFF  2DF,01
243E:  MOVFF  2E0,02
2442:  MOVFF  2E1,03
2446:  BRA    2466
....................    } 
2448:  BRA    2466
244A:  MOVLB  2
....................    else{ 
....................       return v2 = 0.00000; 
244C:  CLRF   xE1
244E:  CLRF   xE0
2450:  CLRF   xDF
2452:  CLRF   xDE
2454:  MOVFF  2DE,00
2458:  MOVFF  2DF,01
245C:  MOVFF  2E0,02
2460:  MOVFF  2E1,03
2464:  MOVLB  0
....................    } 
2466:  GOTO   5F0A (RETURN)
.................... } 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... float datov2(){ 
....................    d = 0; 
....................    v2 = 0; 
....................    i2c_start(); 
....................    i2c_write(0b10010000);  //llamado por direccion 
....................    i2c_write(0b00000001);  //llamado de configuracion de registro 
....................    i2c_write(0b11000000);  // 
....................    i2c_write(0b11000011);  // 
....................    i2c_stop(); 
....................     
....................    i2c_start(); 
....................    i2c_write(0b10010000);  //frame 1 
....................    i2c_write(0b00000000);  //frame 2 
....................    i2c_stop(); 
....................     
....................    i2c_start(); 
....................    i2c_write(0b10010001);  //frame 3 
....................    hd = i2c_read(1); 
....................    ld = i2c_read(1); 
....................    i2c_stop(); 
....................     
....................    d=hd<<8; 
....................    d|=ld; 
....................    if(d<30000){ 
....................       return v3 = (0.000187371)*d; 
....................    } 
....................    else{ 
....................       return v3 = 0.00000; 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////// 
.................... RTC_Time *mytime; 
.................... int Humss,Tempss; 
.................... unsigned int Luz; 
.................... float Temperatura,Humedad,Temps,Presions,vbat; 
.................... char txt[50],a1=0,a2=0,a3=0; 
.................... const int8 comillas = '"'; 
.................... long Press=0; 
....................  
.................... void rtc_print(){ 
....................   printf("TIME: %02u:%02u:%02u", mytime->hours, mytime->minutes, mytime->seconds); 
*
0764:  MOVLW  02
0766:  MOVLB  2
0768:  ADDWF  xE6,W
076A:  MOVWF  FE9
076C:  MOVLW  00
076E:  ADDWFC xE7,W
0770:  MOVWF  FEA
0772:  MOVFF  FEF,336
0776:  MOVLW  01
0778:  ADDWF  xE6,W
077A:  MOVWF  FE9
077C:  MOVLW  00
077E:  ADDWFC xE7,W
0780:  MOVWF  FEA
0782:  MOVFF  FEF,337
0786:  MOVFF  2E6,FE9
078A:  MOVFF  2E7,FEA
078E:  MOVFF  FEF,338
0792:  MOVLW  F8
0794:  MOVWF  FF6
0796:  MOVLW  02
0798:  MOVWF  FF7
079A:  MOVLW  06
079C:  MOVLB  3
079E:  MOVWF  x39
07A0:  MOVLB  0
07A2:  RCALL  0694
07A4:  MOVFF  336,339
07A8:  MOVLW  01
07AA:  MOVLB  3
07AC:  MOVWF  x3A
07AE:  MOVLB  0
07B0:  RCALL  06E8
07B2:  MOVLW  3A
07B4:  MOVLB  3
07B6:  MOVWF  x45
07B8:  MOVLB  0
07BA:  RCALL  0650
07BC:  MOVFF  337,339
07C0:  MOVLW  01
07C2:  MOVLB  3
07C4:  MOVWF  x3A
07C6:  MOVLB  0
07C8:  RCALL  06E8
07CA:  MOVLW  3A
07CC:  MOVLB  3
07CE:  MOVWF  x45
07D0:  MOVLB  0
07D2:  RCALL  0650
07D4:  MOVFF  338,339
07D8:  MOVLW  01
07DA:  MOVLB  3
07DC:  MOVWF  x3A
07DE:  MOVLB  0
07E0:  RCALL  06E8
....................   printf(" DATE: %02u/%02u/20%02u\r\n", mytime->day, mytime->month, mytime->year); 
07E2:  MOVLW  04
07E4:  MOVLB  2
07E6:  ADDWF  xE6,W
07E8:  MOVWF  FE9
07EA:  MOVLW  00
07EC:  ADDWFC xE7,W
07EE:  MOVWF  FEA
07F0:  MOVFF  FEF,336
07F4:  MOVLW  05
07F6:  ADDWF  xE6,W
07F8:  MOVWF  FE9
07FA:  MOVLW  00
07FC:  ADDWFC xE7,W
07FE:  MOVWF  FEA
0800:  MOVFF  FEF,337
0804:  MOVLW  06
0806:  ADDWF  xE6,W
0808:  MOVWF  FE9
080A:  MOVLW  00
080C:  ADDWFC xE7,W
080E:  MOVWF  FEA
0810:  MOVFF  FEF,338
0814:  MOVLW  0E
0816:  MOVWF  FF6
0818:  MOVLW  03
081A:  MOVWF  FF7
081C:  MOVLW  07
081E:  MOVLB  3
0820:  MOVWF  x39
0822:  MOVLB  0
0824:  RCALL  0694
0826:  MOVFF  336,339
082A:  MOVLW  01
082C:  MOVLB  3
082E:  MOVWF  x3A
0830:  MOVLB  0
0832:  RCALL  06E8
0834:  MOVLW  2F
0836:  MOVLB  3
0838:  MOVWF  x45
083A:  MOVLB  0
083C:  RCALL  0650
083E:  MOVFF  337,339
0842:  MOVLW  01
0844:  MOVLB  3
0846:  MOVWF  x3A
0848:  MOVLB  0
084A:  RCALL  06E8
084C:  MOVLW  1E
084E:  MOVWF  FF6
0850:  MOVLW  03
0852:  MOVWF  FF7
0854:  MOVLW  03
0856:  MOVLB  3
0858:  MOVWF  x39
085A:  MOVLB  0
085C:  RCALL  0694
085E:  MOVFF  338,339
0862:  MOVLW  01
0864:  MOVLB  3
0866:  MOVWF  x3A
0868:  MOVLB  0
086A:  RCALL  06E8
086C:  MOVLW  0D
086E:  MOVLB  3
0870:  MOVWF  x45
0872:  MOVLB  0
0874:  RCALL  0650
0876:  MOVLW  0A
0878:  MOVLB  3
087A:  MOVWF  x45
087C:  MOVLB  0
087E:  RCALL  0650
0880:  RETURN 0
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////////////// 
.................... void main(){ 
*
5CD6:  CLRF   FF8
5CD8:  BCF    FD0.7
5CDA:  MOVLW  70
5CDC:  MOVWF  FD3
5CDE:  MOVF   FD3,W
5CE0:  BCF    F92.3
5CE2:  BSF    F89.3
5CE4:  MOVLB  2
5CE6:  CLRF   x23
5CE8:  CLRF   x22
5CEA:  MOVLB  3
5CEC:  CLRF   x31
5CEE:  CLRF   x32
5CF0:  CLRF   x33
5CF2:  CLRF   x35
5CF4:  CLRF   x34
5CF6:  MOVF   FC1,W
5CF8:  ANDLW  C0
5CFA:  IORLW  0F
5CFC:  MOVWF  FC1
5CFE:  MOVLW  07
5D00:  MOVWF  FB4
5D02:  MOVLB  2
5D04:  CLRF   x0A
5D06:  CLRF   x0B
....................    set_tris_c(0x00); 
5D08:  MOVLW  00
5D0A:  MOVWF  F94
....................    mytime = RTC_Get(); 
5D0C:  MOVLB  0
5D0E:  CALL   0568
5D12:  MOVFF  02,2E7
5D16:  MOVFF  01,2E6
....................    rtc_print(); 
5D1A:  CALL   0764
....................    delay_ms(1000);  // wait a second 
5D1E:  MOVLW  04
5D20:  MOVLB  3
5D22:  MOVWF  x36
5D24:  MOVLW  FA
5D26:  MOVWF  x5E
5D28:  MOVLB  0
5D2A:  CALL   0882
5D2E:  MOVLB  3
5D30:  DECFSZ x36,F
5D32:  BRA    5D24
....................    while(1){ 
....................       output_low(PIN_C6); 
5D34:  BCF    F94.6
5D36:  BCF    F8B.6
....................       delay_ms(100); 
5D38:  MOVLW  64
5D3A:  MOVWF  x5E
5D3C:  MOVLB  0
5D3E:  CALL   0882
....................       output_high(PIN_C6); 
5D42:  BCF    F94.6
5D44:  BSF    F8B.6
....................       delay_ms(20000);  // wait a second 
5D46:  MOVLW  50
5D48:  MOVLB  3
5D4A:  MOVWF  x36
5D4C:  MOVLW  FA
5D4E:  MOVWF  x5E
5D50:  MOVLB  0
5D52:  CALL   0882
5D56:  MOVLB  3
5D58:  DECFSZ x36,F
5D5A:  BRA    5D4C
....................       delay_ms(20000);  // wait a second 
5D5C:  MOVLW  50
5D5E:  MOVWF  x36
5D60:  MOVLW  FA
5D62:  MOVWF  x5E
5D64:  MOVLB  0
5D66:  CALL   0882
5D6A:  MOVLB  3
5D6C:  DECFSZ x36,F
5D6E:  BRA    5D60
....................       a1=0; 
5D70:  CLRF   x31
....................       a3=0; 
5D72:  CLRF   x33
....................       mytime = RTC_Get(); 
5D74:  MOVLB  0
5D76:  CALL   0568
5D7A:  MOVFF  02,2E7
5D7E:  MOVFF  01,2E6
....................       rtc_print(); 
5D82:  CALL   0764
.................... ////////////////////////////////////////////////////////////////////////////////////////   
....................       Humedad=dat_DHT22(1);              
5D86:  MOVLW  01
5D88:  MOVLB  3
5D8A:  MOVWF  x36
5D8C:  MOVLB  0
5D8E:  GOTO   0B9E
5D92:  MOVFF  03,2F2
5D96:  MOVFF  02,2F1
5D9A:  MOVFF  01,2F0
5D9E:  MOVFF  00,2EF
....................       printf("Humedad: %0.1f\r\n",Humedad); 
5DA2:  MOVLW  28
5DA4:  MOVWF  FF6
5DA6:  MOVLW  03
5DA8:  MOVWF  FF7
5DAA:  MOVLW  09
5DAC:  MOVLB  3
5DAE:  MOVWF  x39
5DB0:  MOVLB  0
5DB2:  CALL   0694
5DB6:  MOVLW  C9
5DB8:  MOVWF  FE9
5DBA:  MOVFF  2F2,339
5DBE:  MOVFF  2F1,338
5DC2:  MOVFF  2F0,337
5DC6:  MOVFF  2EF,336
5DCA:  MOVLW  01
5DCC:  MOVLB  3
5DCE:  MOVWF  x3A
5DD0:  MOVLB  0
5DD2:  CALL   0F24
5DD6:  MOVLW  0D
5DD8:  MOVLB  3
5DDA:  MOVWF  x45
5DDC:  MOVLB  0
5DDE:  CALL   0650
5DE2:  MOVLW  0A
5DE4:  MOVLB  3
5DE6:  MOVWF  x45
5DE8:  MOVLB  0
5DEA:  CALL   0650
....................       delay_ms(500); 
5DEE:  MOVLW  02
5DF0:  MOVLB  3
5DF2:  MOVWF  x36
5DF4:  MOVLW  FA
5DF6:  MOVWF  x5E
5DF8:  MOVLB  0
5DFA:  CALL   0882
5DFE:  MOVLB  3
5E00:  DECFSZ x36,F
5E02:  BRA    5DF4
....................  ////////////////////////////////////////////////////////////////////////////////////////     
....................       bmp085Calibration(); 
5E04:  MOVLB  0
5E06:  GOTO   11AC
....................       delay_ms(500); 
5E0A:  MOVLW  02
5E0C:  MOVLB  3
5E0E:  MOVWF  x36
5E10:  MOVLW  FA
5E12:  MOVWF  x5E
5E14:  MOVLB  0
5E16:  CALL   0882
5E1A:  MOVLB  3
5E1C:  DECFSZ x36,F
5E1E:  BRA    5E10
....................       Temps = BMP085Temperature();  
5E20:  MOVLB  0
5E22:  GOTO   19D4
5E26:  MOVFF  03,2F6
5E2A:  MOVFF  02,2F5
5E2E:  MOVFF  01,2F4
5E32:  MOVFF  00,2F3
....................       Presions = BMP085Pressure();  //  calls for temperature first 
5E36:  GOTO   1EF8
5E3A:  MOVFF  03,2FA
5E3E:  MOVFF  02,2F9
5E42:  MOVFF  01,2F8
5E46:  MOVFF  00,2F7
....................       delay_ms(100); 
5E4A:  MOVLW  64
5E4C:  MOVLB  3
5E4E:  MOVWF  x5E
5E50:  MOVLB  0
5E52:  CALL   0882
....................       printf("Temperatura: %.3g\r\nPresion: %.3g\r\n",Temps,Presions); 
5E56:  MOVLW  3A
5E58:  MOVWF  FF6
5E5A:  MOVLW  03
5E5C:  MOVWF  FF7
5E5E:  MOVLW  0D
5E60:  MOVLB  3
5E62:  MOVWF  x39
5E64:  MOVLB  0
5E66:  CALL   0694
5E6A:  MOVLW  89
5E6C:  MOVWF  FE9
5E6E:  MOVFF  2F6,339
5E72:  MOVFF  2F5,338
5E76:  MOVFF  2F4,337
5E7A:  MOVFF  2F3,336
5E7E:  MOVLW  03
5E80:  MOVLB  3
5E82:  MOVWF  x3A
5E84:  MOVLB  0
5E86:  CALL   1F74
5E8A:  MOVLW  4B
5E8C:  MOVWF  FF6
5E8E:  MOVLW  03
5E90:  MOVWF  FF7
5E92:  MOVLW  0B
5E94:  MOVLB  3
5E96:  MOVWF  x39
5E98:  MOVLB  0
5E9A:  CALL   0694
5E9E:  MOVLW  89
5EA0:  MOVWF  FE9
5EA2:  MOVFF  2FA,339
5EA6:  MOVFF  2F9,338
5EAA:  MOVFF  2F8,337
5EAE:  MOVFF  2F7,336
5EB2:  MOVLW  03
5EB4:  MOVLB  3
5EB6:  MOVWF  x3A
5EB8:  MOVLB  0
5EBA:  CALL   1F74
5EBE:  MOVLW  0D
5EC0:  MOVLB  3
5EC2:  MOVWF  x45
5EC4:  MOVLB  0
5EC6:  CALL   0650
5ECA:  MOVLW  0A
5ECC:  MOVLB  3
5ECE:  MOVWF  x45
5ED0:  MOVLB  0
5ED2:  CALL   0650
....................       delay_ms(1000); 
5ED6:  MOVLW  04
5ED8:  MOVLB  3
5EDA:  MOVWF  x36
5EDC:  MOVLW  FA
5EDE:  MOVWF  x5E
5EE0:  MOVLB  0
5EE2:  CALL   0882
5EE6:  MOVLB  3
5EE8:  DECFSZ x36,F
5EEA:  BRA    5EDC
.................... ////////////////////////////////////////////////////////////////////////////////////////   
....................       delay_ms(10); 
5EEC:  MOVLW  0A
5EEE:  MOVWF  x5E
5EF0:  MOVLB  0
5EF2:  CALL   0882
....................       datov0(); 
5EF6:  GOTO   216E
....................       delay_ms(10); 
5EFA:  MOVLW  0A
5EFC:  MOVLB  3
5EFE:  MOVWF  x5E
5F00:  MOVLB  0
5F02:  CALL   0882
....................       datov1(); 
5F06:  GOTO   22EC
....................       delay_ms(10);    
5F0A:  MOVLW  0A
5F0C:  MOVLB  3
5F0E:  MOVWF  x5E
5F10:  MOVLB  0
5F12:  CALL   0882
....................       Luz=(v1*51.2); 
5F16:  MOVFF  2DD,355
5F1A:  MOVFF  2DC,354
5F1E:  MOVFF  2DB,353
5F22:  MOVFF  2DA,352
5F26:  MOVLW  CD
5F28:  MOVLB  3
5F2A:  MOVWF  x59
5F2C:  MOVLW  CC
5F2E:  MOVWF  x58
5F30:  MOVLW  4C
5F32:  MOVWF  x57
5F34:  MOVLW  84
5F36:  MOVWF  x56
5F38:  MOVLB  0
5F3A:  CALL   0D56
5F3E:  MOVFF  03,33B
5F42:  MOVFF  02,33A
5F46:  MOVFF  01,339
5F4A:  MOVFF  00,338
5F4E:  CALL   15B8
5F52:  MOVFF  01,2EA
....................       if(Luz<0){ 
....................          Luz=Luz*(-1); 
....................       }   
....................       vbat=v2*2; 
5F56:  MOVFF  2E1,355
5F5A:  MOVFF  2E0,354
5F5E:  MOVFF  2DF,353
5F62:  MOVFF  2DE,352
5F66:  MOVLB  3
5F68:  CLRF   x59
5F6A:  CLRF   x58
5F6C:  CLRF   x57
5F6E:  MOVLW  80
5F70:  MOVWF  x56
5F72:  MOVLB  0
5F74:  CALL   0D56
5F78:  MOVFF  03,2FE
5F7C:  MOVFF  02,2FD
5F80:  MOVFF  01,2FC
5F84:  MOVFF  00,2FB
....................       printf("Luz: %u  Vbat: %f",Luz,vbat); 
5F88:  MOVLW  5E
5F8A:  MOVWF  FF6
5F8C:  MOVLW  03
5F8E:  MOVWF  FF7
5F90:  MOVLW  05
5F92:  MOVLB  3
5F94:  MOVWF  x39
5F96:  MOVLB  0
5F98:  CALL   0694
5F9C:  MOVFF  2EA,339
5FA0:  MOVLW  1B
5FA2:  MOVLB  3
5FA4:  MOVWF  x3A
5FA6:  MOVLB  0
5FA8:  CALL   06E8
5FAC:  MOVLW  65
5FAE:  MOVWF  FF6
5FB0:  MOVLW  03
5FB2:  MOVWF  FF7
5FB4:  MOVLW  08
5FB6:  MOVLB  3
5FB8:  MOVWF  x39
5FBA:  MOVLB  0
5FBC:  CALL   0694
5FC0:  MOVLW  89
5FC2:  MOVWF  FE9
5FC4:  MOVFF  2FE,339
5FC8:  MOVFF  2FD,338
5FCC:  MOVFF  2FC,337
5FD0:  MOVFF  2FB,336
5FD4:  MOVLW  02
5FD6:  MOVLB  3
5FD8:  MOVWF  x3A
5FDA:  MOVLB  0
5FDC:  CALL   0F24
.................... //////////////////////////////////////////////////////////////////////////////////////// 
....................       delay_ms(100); 
5FE0:  MOVLW  64
5FE2:  MOVLB  3
5FE4:  MOVWF  x5E
5FE6:  MOVLB  0
5FE8:  CALL   0882
....................       initialize(); 
5FEC:  GOTO   3102
....................       delay_ms(100); 
5FF0:  MOVLW  64
5FF2:  MOVLB  3
5FF4:  MOVWF  x5E
5FF6:  MOVLB  0
5FF8:  CALL   0882
....................  
....................       open_doc(); 
5FFC:  CALL   53C0
....................       sprintf(txt, "%02u/%02u/20%02u %02u:%02u | %0.1f | %0.1f | %0.1f ",mytime->day,mytime->month,mytime->year,mytime->hours, mytime->minutes,Humedad,Temps,Presions); 
6000:  MOVLW  04
6002:  MOVLB  2
6004:  ADDWF  xE6,W
6006:  MOVWF  FE9
6008:  MOVLW  00
600A:  ADDWFC xE7,W
600C:  MOVWF  FEA
600E:  MOVFF  FEF,33B
6012:  MOVLW  05
6014:  ADDWF  xE6,W
6016:  MOVWF  FE9
6018:  MOVLW  00
601A:  ADDWFC xE7,W
601C:  MOVWF  FEA
601E:  MOVFF  FEF,337
6022:  MOVLW  06
6024:  ADDWF  xE6,W
6026:  MOVWF  FE9
6028:  MOVLW  00
602A:  ADDWFC xE7,W
602C:  MOVWF  FEA
602E:  MOVFF  FEF,338
6032:  MOVLW  02
6034:  ADDWF  xE6,W
6036:  MOVWF  FE9
6038:  MOVLW  00
603A:  ADDWFC xE7,W
603C:  MOVWF  FEA
603E:  MOVFF  FEF,339
6042:  MOVLW  01
6044:  ADDWF  xE6,W
6046:  MOVWF  FE9
6048:  MOVLW  00
604A:  ADDWFC xE7,W
604C:  MOVWF  FEA
604E:  MOVFF  FEF,33A
6052:  MOVLW  02
6054:  MOVWF  x23
6056:  SETF   x22
6058:  MOVLW  01
605A:  MOVLB  3
605C:  MOVWF  x3C
605E:  MOVLB  0
6060:  CALL   5438
6064:  MOVLW  2F
6066:  MOVLB  3
6068:  MOVWF  x48
606A:  MOVLB  0
606C:  CALL   5416
6070:  MOVFF  337,33B
6074:  MOVLW  01
6076:  MOVLB  3
6078:  MOVWF  x3C
607A:  MOVLB  0
607C:  CALL   5438
6080:  MOVLW  79
6082:  MOVWF  FF6
6084:  MOVLW  03
6086:  MOVWF  FF7
6088:  MOVLW  03
608A:  MOVLB  3
608C:  MOVWF  x3B
608E:  MOVLB  0
6090:  CALL   54B8
6094:  MOVFF  338,33B
6098:  MOVLW  01
609A:  MOVLB  3
609C:  MOVWF  x3C
609E:  MOVLB  0
60A0:  CALL   5438
60A4:  MOVLW  20
60A6:  MOVLB  3
60A8:  MOVWF  x48
60AA:  MOVLB  0
60AC:  CALL   5416
60B0:  MOVFF  339,33B
60B4:  MOVLW  01
60B6:  MOVLB  3
60B8:  MOVWF  x3C
60BA:  MOVLB  0
60BC:  CALL   5438
60C0:  MOVLW  3A
60C2:  MOVLB  3
60C4:  MOVWF  x48
60C6:  MOVLB  0
60C8:  CALL   5416
60CC:  MOVFF  33A,33B
60D0:  MOVLW  01
60D2:  MOVLB  3
60D4:  MOVWF  x3C
60D6:  MOVLB  0
60D8:  CALL   5438
60DC:  MOVLW  8A
60DE:  MOVWF  FF6
60E0:  MOVLW  03
60E2:  MOVWF  FF7
60E4:  MOVLW  03
60E6:  MOVLB  3
60E8:  MOVWF  x3B
60EA:  MOVLB  0
60EC:  CALL   54B8
60F0:  MOVLW  C9
60F2:  MOVWF  FE9
60F4:  MOVFF  2F2,33E
60F8:  MOVFF  2F1,33D
60FC:  MOVFF  2F0,33C
6100:  MOVFF  2EF,33B
6104:  MOVLW  01
6106:  MOVLB  3
6108:  MOVWF  x3F
610A:  MOVLB  0
610C:  CALL   54E0
6110:  MOVLW  92
6112:  MOVWF  FF6
6114:  MOVLW  03
6116:  MOVWF  FF7
6118:  MOVLW  03
611A:  MOVLB  3
611C:  MOVWF  x3B
611E:  MOVLB  0
6120:  CALL   54B8
6124:  MOVLW  C9
6126:  MOVWF  FE9
6128:  MOVFF  2F6,33E
612C:  MOVFF  2F5,33D
6130:  MOVFF  2F4,33C
6134:  MOVFF  2F3,33B
6138:  MOVLW  01
613A:  MOVLB  3
613C:  MOVWF  x3F
613E:  MOVLB  0
6140:  CALL   54E0
6144:  MOVLW  9A
6146:  MOVWF  FF6
6148:  MOVLW  03
614A:  MOVWF  FF7
614C:  MOVLW  03
614E:  MOVLB  3
6150:  MOVWF  x3B
6152:  MOVLB  0
6154:  CALL   54B8
6158:  MOVLW  C9
615A:  MOVWF  FE9
615C:  MOVFF  2FA,33E
6160:  MOVFF  2F9,33D
6164:  MOVFF  2F8,33C
6168:  MOVFF  2F7,33B
616C:  MOVLW  01
616E:  MOVLB  3
6170:  MOVWF  x3F
6172:  MOVLB  0
6174:  CALL   54E0
6178:  MOVLW  20
617A:  MOVLB  3
617C:  MOVWF  x48
617E:  MOVLB  0
6180:  CALL   5416
....................       if(fatputs(txt, &myfile) == 0){ 
6184:  MOVLW  02
6186:  MOVLB  3
6188:  MOVWF  x3C
618A:  SETF   x3B
618C:  MOVWF  x3E
618E:  MOVLW  26
6190:  MOVWF  x3D
6192:  MOVLB  0
6194:  CALL   5690
6198:  MOVF   01,F
619A:  BNZ   61A8
....................         printf(txt); 
619C:  MOVLW  02
619E:  MOVWF  FEA
61A0:  SETF   FE9
61A2:  CALL   56DE
....................       } 
61A6:  BRA    61B4
....................       else{ 
....................         printf("  writing error \r\n"); 
61A8:  MOVLW  A4
61AA:  MOVWF  FF6
61AC:  MOVLW  03
61AE:  MOVWF  FF7
61B0:  CALL   0994
....................       } 
....................        
....................       enter(); 
61B4:  CALL   5704
....................       close_doc(); 
61B8:  RCALL  5BEA
....................        
....................       open_doc(); 
61BA:  CALL   53C0
....................       sprintf(txt, "| %u | %f \r\n",Luz,vbat); 
61BE:  MOVLW  02
61C0:  MOVLB  2
61C2:  MOVWF  x23
61C4:  SETF   x22
61C6:  MOVLW  7C
61C8:  MOVLB  3
61CA:  MOVWF  x48
61CC:  MOVLB  0
61CE:  CALL   5416
61D2:  MOVLW  20
61D4:  MOVLB  3
61D6:  MOVWF  x48
61D8:  MOVLB  0
61DA:  CALL   5416
61DE:  MOVFF  2EA,33B
61E2:  MOVLW  1B
61E4:  MOVLB  3
61E6:  MOVWF  x3C
61E8:  MOVLB  0
61EA:  CALL   5438
61EE:  MOVLW  BC
61F0:  MOVWF  FF6
61F2:  MOVLW  03
61F4:  MOVWF  FF7
61F6:  MOVLW  03
61F8:  MOVLB  3
61FA:  MOVWF  x3B
61FC:  MOVLB  0
61FE:  CALL   54B8
6202:  MOVLW  89
6204:  MOVWF  FE9
6206:  MOVFF  2FE,33E
620A:  MOVFF  2FD,33D
620E:  MOVFF  2FC,33C
6212:  MOVFF  2FB,33B
6216:  MOVLW  02
6218:  MOVLB  3
621A:  MOVWF  x3F
621C:  MOVLB  0
621E:  CALL   54E0
6222:  MOVLW  C1
6224:  MOVWF  FF6
6226:  MOVLW  03
6228:  MOVWF  FF7
622A:  MOVLW  03
622C:  MOVLB  3
622E:  MOVWF  x3B
6230:  MOVLB  0
6232:  CALL   54B8
....................       if(fatputs(txt, &myfile) == 0){ 
6236:  MOVLW  02
6238:  MOVLB  3
623A:  MOVWF  x3C
623C:  SETF   x3B
623E:  MOVWF  x3E
6240:  MOVLW  26
6242:  MOVWF  x3D
6244:  MOVLB  0
6246:  CALL   5690
624A:  MOVF   01,F
624C:  BNZ   625A
....................         printf(txt); 
624E:  MOVLW  02
6250:  MOVWF  FEA
6252:  SETF   FE9
6254:  CALL   56DE
....................       } 
6258:  BRA    6266
....................       else{ 
....................         printf("  writing error \r\n"); 
625A:  MOVLW  C6
625C:  MOVWF  FF6
625E:  MOVLW  03
6260:  MOVWF  FF7
6262:  CALL   0994
....................       } 
....................        
....................       enter(); 
6266:  CALL   5704
....................       close_doc(); 
626A:  RCALL  5BEA
....................        
....................       delay_ms(1000); 
626C:  MOVLW  04
626E:  MOVLB  3
6270:  MOVWF  x36
6272:  MOVLW  FA
6274:  MOVWF  x5E
6276:  MOVLB  0
6278:  CALL   0882
627C:  MOVLB  3
627E:  DECFSZ x36,F
6280:  BRA    6272
....................       Humss=(int)Humedad; 
6282:  MOVFF  2F2,33B
6286:  MOVFF  2F1,33A
628A:  MOVFF  2F0,339
628E:  MOVFF  2EF,338
6292:  MOVLB  0
6294:  CALL   15B8
6298:  MOVFF  01,2E8
....................       Tempss=(int)Temps; 
629C:  MOVFF  2F6,33B
62A0:  MOVFF  2F5,33A
62A4:  MOVFF  2F4,339
62A8:  MOVFF  2F3,338
62AC:  CALL   15B8
62B0:  MOVFF  01,2E9
....................       Press=(long)Presions; 
62B4:  MOVFF  2FA,33B
62B8:  MOVFF  2F9,33A
62BC:  MOVFF  2F8,339
62C0:  MOVFF  2F7,338
62C4:  CALL   15B8
62C8:  MOVFF  02,335
62CC:  MOVFF  01,334
.................... ////////////////////////////////////////////////////////////////////////////////////////   
....................       delay_ms(8000); 
62D0:  MOVLW  20
62D2:  MOVLB  3
62D4:  MOVWF  x36
62D6:  MOVLW  FA
62D8:  MOVWF  x5E
62DA:  MOVLB  0
62DC:  CALL   0882
62E0:  MOVLB  3
62E2:  DECFSZ x36,F
62E4:  BRA    62D6
....................       printf("AT+CIPSTART=%cTCP%c,%capi.thingspeak.com%c,80\r\n",comillas,comillas,comillas,comillas); 
62E6:  MOVLW  DA
62E8:  MOVWF  FF6
62EA:  MOVLW  03
62EC:  MOVWF  FF7
62EE:  MOVLW  0C
62F0:  MOVWF  x39
62F2:  MOVLB  0
62F4:  CALL   0694
62F8:  MOVLW  22
62FA:  MOVLB  3
62FC:  MOVWF  x45
62FE:  MOVLB  0
6300:  CALL   0650
6304:  MOVLW  E8
6306:  MOVWF  FF6
6308:  MOVLW  03
630A:  MOVWF  FF7
630C:  MOVLW  03
630E:  MOVLB  3
6310:  MOVWF  x39
6312:  MOVLB  0
6314:  CALL   0694
6318:  MOVLW  22
631A:  MOVLB  3
631C:  MOVWF  x45
631E:  MOVLB  0
6320:  CALL   0650
6324:  MOVLW  2C
6326:  MOVLB  3
6328:  MOVWF  x45
632A:  MOVLB  0
632C:  CALL   0650
6330:  MOVLW  22
6332:  MOVLB  3
6334:  MOVWF  x45
6336:  MOVLB  0
6338:  CALL   0650
633C:  MOVLW  F0
633E:  MOVWF  FF6
6340:  MOVLW  03
6342:  MOVWF  FF7
6344:  MOVLW  12
6346:  MOVLB  3
6348:  MOVWF  x39
634A:  MOVLB  0
634C:  CALL   0694
6350:  MOVLW  22
6352:  MOVLB  3
6354:  MOVWF  x45
6356:  MOVLB  0
6358:  CALL   0650
635C:  MOVLW  04
635E:  MOVWF  FF6
6360:  MOVLW  04
6362:  MOVWF  FF7
6364:  MOVLW  05
6366:  MOVLB  3
6368:  MOVWF  x39
636A:  MOVLB  0
636C:  CALL   0694
....................       delay_ms(8000); 
6370:  MOVLW  20
6372:  MOVLB  3
6374:  MOVWF  x36
6376:  MOVLW  FA
6378:  MOVWF  x5E
637A:  MOVLB  0
637C:  CALL   0882
6380:  MOVLB  3
6382:  DECFSZ x36,F
6384:  BRA    6376
....................       printf("AT+CIPMODE=1\r\n"); 
6386:  MOVLW  0A
6388:  MOVWF  FF6
638A:  MOVLW  04
638C:  MOVWF  FF7
638E:  MOVLB  0
6390:  CALL   0994
....................       delay_ms(8000); 
6394:  MOVLW  20
6396:  MOVLB  3
6398:  MOVWF  x36
639A:  MOVLW  FA
639C:  MOVWF  x5E
639E:  MOVLB  0
63A0:  CALL   0882
63A4:  MOVLB  3
63A6:  DECFSZ x36,F
63A8:  BRA    639A
....................       printf("AT+CIPSEND\r\n"); 
63AA:  MOVLW  1A
63AC:  MOVWF  FF6
63AE:  MOVLW  04
63B0:  MOVWF  FF7
63B2:  MOVLB  0
63B4:  CALL   0994
....................       delay_ms(8000); 
63B8:  MOVLW  20
63BA:  MOVLB  3
63BC:  MOVWF  x36
63BE:  MOVLW  FA
63C0:  MOVWF  x5E
63C2:  MOVLB  0
63C4:  CALL   0882
63C8:  MOVLB  3
63CA:  DECFSZ x36,F
63CC:  BRA    63BE
....................       output_high(PIN_C6); 
63CE:  BCF    F94.6
63D0:  BSF    F8B.6
.................... //      printf("GET https://api.thingspeak.com/update?api_key=S0Q18RYEFRGYNGMG&field1=%u&field2=%u&field3=%lu&field4=%d\r\n",Humss,Tempss,Press,Luz); 
....................       printf("GET https://api.thingspeak.com/update?api_key=J41AH1ZY79SQ96Y9"); 
63D2:  MOVLW  28
63D4:  MOVWF  FF6
63D6:  MOVLW  04
63D8:  MOVWF  FF7
63DA:  MOVLB  0
63DC:  CALL   0994
....................       printf("&field1=%u&field2=%u&field3=%lu&field4=%u\r\n",Humss,Tempss,Press,Luz); 
63E0:  MOVLW  68
63E2:  MOVWF  FF6
63E4:  MOVLW  04
63E6:  MOVWF  FF7
63E8:  MOVLW  08
63EA:  MOVLB  3
63EC:  MOVWF  x39
63EE:  MOVLB  0
63F0:  CALL   0694
63F4:  MOVFF  2E8,339
63F8:  MOVLW  1B
63FA:  MOVLB  3
63FC:  MOVWF  x3A
63FE:  MOVLB  0
6400:  CALL   06E8
6404:  MOVLW  72
6406:  MOVWF  FF6
6408:  MOVLW  04
640A:  MOVWF  FF7
640C:  MOVLW  08
640E:  MOVLB  3
6410:  MOVWF  x39
6412:  MOVLB  0
6414:  CALL   0694
6418:  MOVFF  2E9,339
641C:  MOVLW  1B
641E:  MOVLB  3
6420:  MOVWF  x3A
6422:  MOVLB  0
6424:  CALL   06E8
6428:  MOVLW  7C
642A:  MOVWF  FF6
642C:  MOVLW  04
642E:  MOVWF  FF7
6430:  MOVLW  08
6432:  MOVLB  3
6434:  MOVWF  x39
6436:  MOVLB  0
6438:  CALL   0694
643C:  MOVLW  10
643E:  MOVWF  FE9
6440:  MOVFF  335,337
6444:  MOVFF  334,336
6448:  GOTO   5C0C
644C:  MOVLW  87
644E:  MOVWF  FF6
6450:  MOVLW  04
6452:  MOVWF  FF7
6454:  MOVLW  08
6456:  MOVLB  3
6458:  MOVWF  x39
645A:  MOVLB  0
645C:  CALL   0694
6460:  MOVFF  2EA,339
6464:  MOVLW  1B
6466:  MOVLB  3
6468:  MOVWF  x3A
646A:  MOVLB  0
646C:  CALL   06E8
6470:  MOVLW  0D
6472:  MOVLB  3
6474:  MOVWF  x45
6476:  MOVLB  0
6478:  CALL   0650
647C:  MOVLW  0A
647E:  MOVLB  3
6480:  MOVWF  x45
6482:  MOVLB  0
6484:  CALL   0650
....................       output_high(PIN_C6); 
6488:  BCF    F94.6
648A:  BSF    F8B.6
....................       delay_ms(3000); 
648C:  MOVLW  0C
648E:  MOVLB  3
6490:  MOVWF  x36
6492:  MOVLW  FA
6494:  MOVWF  x5E
6496:  MOVLB  0
6498:  CALL   0882
649C:  MOVLB  3
649E:  DECFSZ x36,F
64A0:  BRA    6492
....................       output_low(PIN_C6); 
64A2:  BCF    F94.6
64A4:  BCF    F8B.6
....................       delay_ms(3000); 
64A6:  MOVLW  0C
64A8:  MOVWF  x36
64AA:  MOVLW  FA
64AC:  MOVWF  x5E
64AE:  MOVLB  0
64B0:  CALL   0882
64B4:  MOVLB  3
64B6:  DECFSZ x36,F
64B8:  BRA    64AA
....................       output_high(PIN_C6); 
64BA:  BCF    F94.6
64BC:  BSF    F8B.6
....................       delay_ms(3000); 
64BE:  MOVLW  0C
64C0:  MOVWF  x36
64C2:  MOVLW  FA
64C4:  MOVWF  x5E
64C6:  MOVLB  0
64C8:  CALL   0882
64CC:  MOVLB  3
64CE:  DECFSZ x36,F
64D0:  BRA    64C2
....................       printf("AT+GSLP=1\r\n"); 
64D2:  MOVLW  94
64D4:  MOVWF  FF6
64D6:  MOVLW  04
64D8:  MOVWF  FF7
64DA:  MOVLB  0
64DC:  CALL   0994
....................       delay_ms(3000); 
64E0:  MOVLW  0C
64E2:  MOVLB  3
64E4:  MOVWF  x36
64E6:  MOVLW  FA
64E8:  MOVWF  x5E
64EA:  MOVLB  0
64EC:  CALL   0882
64F0:  MOVLB  3
64F2:  DECFSZ x36,F
64F4:  BRA    64E6
....................       printf("AT+GSLP=1\r\n"); 
64F6:  MOVLW  A0
64F8:  MOVWF  FF6
64FA:  MOVLW  04
64FC:  MOVWF  FF7
64FE:  MOVLB  0
6500:  CALL   0994
....................       delay_ms(3000); 
6504:  MOVLW  0C
6506:  MOVLB  3
6508:  MOVWF  x36
650A:  MOVLW  FA
650C:  MOVWF  x5E
650E:  MOVLB  0
6510:  CALL   0882
6514:  MOVLB  3
6516:  DECFSZ x36,F
6518:  BRA    650A
.................... ////////////////////////////////////////////////////////////////////////////////////////       
....................       mytime = RTC_Get(); 
651A:  MOVLB  0
651C:  CALL   0568
6520:  MOVFF  02,2E7
6524:  MOVFF  01,2E6
....................       a2=(mytime->minutes)+20; 
6528:  MOVLW  01
652A:  MOVLB  2
652C:  ADDWF  xE6,W
652E:  MOVWF  FE9
6530:  MOVLW  00
6532:  ADDWFC xE7,W
6534:  MOVWF  FEA
6536:  MOVLW  14
6538:  ADDWF  FEF,W
653A:  MOVLB  3
653C:  MOVWF  x32
....................       printf("%u %u %u %u",a2,mytime->minutes,a1,a3); 
653E:  MOVLW  01
6540:  MOVLB  2
6542:  ADDWF  xE6,W
6544:  MOVWF  FE9
6546:  MOVLW  00
6548:  ADDWFC xE7,W
654A:  MOVWF  FEA
654C:  MOVFF  FEF,336
6550:  MOVFF  332,339
6554:  MOVLW  1B
6556:  MOVLB  3
6558:  MOVWF  x3A
655A:  MOVLB  0
655C:  CALL   06E8
6560:  MOVLW  20
6562:  MOVLB  3
6564:  MOVWF  x45
6566:  MOVLB  0
6568:  CALL   0650
656C:  MOVFF  336,339
6570:  MOVLW  1B
6572:  MOVLB  3
6574:  MOVWF  x3A
6576:  MOVLB  0
6578:  CALL   06E8
657C:  MOVLW  20
657E:  MOVLB  3
6580:  MOVWF  x45
6582:  MOVLB  0
6584:  CALL   0650
6588:  MOVFF  331,339
658C:  MOVLW  1B
658E:  MOVLB  3
6590:  MOVWF  x3A
6592:  MOVLB  0
6594:  CALL   06E8
6598:  MOVLW  20
659A:  MOVLB  3
659C:  MOVWF  x45
659E:  MOVLB  0
65A0:  CALL   0650
65A4:  MOVFF  333,339
65A8:  MOVLW  1B
65AA:  MOVLB  3
65AC:  MOVWF  x3A
65AE:  MOVLB  0
65B0:  CALL   06E8
....................       if(a2>=60){ 
65B4:  MOVLB  3
65B6:  MOVF   x32,W
65B8:  SUBLW  3B
65BA:  BC    65C4
....................           a2=a2-60; 
65BC:  MOVLW  3C
65BE:  SUBWF  x32,F
....................           a3=1; 
65C0:  MOVLW  01
65C2:  MOVWF  x33
....................        } 
....................       while(a1==0){ 
65C4:  MOVF   x31,F
65C6:  BNZ   66A4
....................          mytime = RTC_Get(); 
65C8:  MOVLB  0
65CA:  CALL   0568
65CE:  MOVFF  02,2E7
65D2:  MOVFF  01,2E6
....................          delay_ms(10000); 
65D6:  MOVLW  28
65D8:  MOVLB  3
65DA:  MOVWF  x36
65DC:  MOVLW  FA
65DE:  MOVWF  x5E
65E0:  MOVLB  0
65E2:  CALL   0882
65E6:  MOVLB  3
65E8:  DECFSZ x36,F
65EA:  BRA    65DC
....................          if(a3==1 && (a2>=mytime->minutes)){ 
65EC:  DECFSZ x33,W
65EE:  BRA    660A
65F0:  MOVLW  01
65F2:  MOVLB  2
65F4:  ADDWF  xE6,W
65F6:  MOVWF  FE9
65F8:  MOVLW  00
65FA:  ADDWFC xE7,W
65FC:  MOVWF  FEA
65FE:  MOVF   FEF,W
6600:  MOVLB  3
6602:  SUBWF  x32,W
6604:  BNC   660A
....................             a1=1; 
6606:  MOVLW  01
6608:  MOVWF  x31
....................          } 
....................          if(a3==0 && (a2<=mytime->minutes)){ 
660A:  MOVF   x33,F
660C:  BNZ   662A
660E:  MOVLW  01
6610:  MOVLB  2
6612:  ADDWF  xE6,W
6614:  MOVWF  FE9
6616:  MOVLW  00
6618:  ADDWFC xE7,W
661A:  MOVWF  FEA
661C:  MOVF   FEF,W
661E:  MOVLB  3
6620:  SUBWF  x32,W
6622:  BZ    6626
6624:  BC    662A
....................             a1=1; 
6626:  MOVLW  01
6628:  MOVWF  x31
....................          } 
....................          printf("%u %u %u %u",a2,mytime->minutes,a1,a3); 
662A:  MOVLW  01
662C:  MOVLB  2
662E:  ADDWF  xE6,W
6630:  MOVWF  FE9
6632:  MOVLW  00
6634:  ADDWFC xE7,W
6636:  MOVWF  FEA
6638:  MOVFF  FEF,336
663C:  MOVFF  332,339
6640:  MOVLW  1B
6642:  MOVLB  3
6644:  MOVWF  x3A
6646:  MOVLB  0
6648:  CALL   06E8
664C:  MOVLW  20
664E:  MOVLB  3
6650:  MOVWF  x45
6652:  MOVLB  0
6654:  CALL   0650
6658:  MOVFF  336,339
665C:  MOVLW  1B
665E:  MOVLB  3
6660:  MOVWF  x3A
6662:  MOVLB  0
6664:  CALL   06E8
6668:  MOVLW  20
666A:  MOVLB  3
666C:  MOVWF  x45
666E:  MOVLB  0
6670:  CALL   0650
6674:  MOVFF  331,339
6678:  MOVLW  1B
667A:  MOVLB  3
667C:  MOVWF  x3A
667E:  MOVLB  0
6680:  CALL   06E8
6684:  MOVLW  20
6686:  MOVLB  3
6688:  MOVWF  x45
668A:  MOVLB  0
668C:  CALL   0650
6690:  MOVFF  333,339
6694:  MOVLW  1B
6696:  MOVLB  3
6698:  MOVWF  x3A
669A:  MOVLB  0
669C:  CALL   06E8
66A0:  MOVLB  3
66A2:  BRA    65C4
....................       } 
66A4:  GOTO   5D34
....................    } 
.................... } 
66A8:  SLEEP 

Configuration Fuses:
   Word  1: C821   PLL2 CPUDIV1 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
