CCS PCH C Compiler, Version 5.059, 5967               15-feb.-20 13:39

               Filename:   E:\Trabajos U\ELECTIVA INSTRUMENTACION\PROYECTO\BPM180\main.lst

               ROM used:   5332 bytes (16%)
                           Largest free fragment is 27436
               RAM used:   115 (6%) at main() level
                           159 (8%) worst case
               Stack used: 3 locations
               Stack size: 31

*
0000:  GOTO   140E
.................... #include <main.h> 
.................... #include <18F2550.h> 
.................... //////////// Standard Header file for the PIC18F2550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2550 
0004:  DATA 54,5B
0006:  DATA 63,5D
0008:  DATA 3A,20
000A:  DATA 25,2E
000C:  DATA 33,67
000E:  DATA 20,20
0010:  DATA 0A,0D
0012:  DATA 00,00
0014:  DATA 50,5B
0016:  DATA 63,5D
0018:  DATA 3A,20
001A:  DATA 25,2E
001C:  DATA 33,67
001E:  DATA 20,20
0020:  DATA 0A,0D
0022:  DATA 0A,0D
0024:  DATA 00,00
*
0128:  MOVLW  8E
012A:  MOVWF  00
012C:  MOVFF  73,01
0130:  MOVFF  72,02
0134:  CLRF   03
0136:  BTFSS  x73.7
0138:  BRA    0144
013A:  COMF   01,F
013C:  COMF   02,F
013E:  INCF   02,F
0140:  BNZ   0144
0142:  INCF   01,F
0144:  MOVF   01,F
0146:  BNZ   015A
0148:  MOVFF  02,01
014C:  CLRF   02
014E:  MOVLW  08
0150:  SUBWF  00,F
0152:  MOVF   01,F
0154:  BNZ   015A
0156:  CLRF   00
0158:  BRA    016E
015A:  BCF    FD8.0
015C:  BTFSC  01.7
015E:  BRA    0168
0160:  RLCF   02,F
0162:  RLCF   01,F
0164:  DECF   00,F
0166:  BRA    015A
0168:  BTFSC  x73.7
016A:  BRA    016E
016C:  BCF    01.7
016E:  RETURN 0
0170:  MOVF   x8F,W
0172:  BTFSC  FD8.2
0174:  BRA    0258
0176:  MOVWF  00
0178:  MOVF   x93,W
017A:  BTFSC  FD8.2
017C:  BRA    0258
017E:  ADDWF  00,F
0180:  BNC   018A
0182:  MOVLW  81
0184:  ADDWF  00,F
0186:  BC    0258
0188:  BRA    0192
018A:  MOVLW  7F
018C:  SUBWF  00,F
018E:  BNC   0258
0190:  BZ    0258
0192:  MOVFF  90,97
0196:  MOVF   x94,W
0198:  XORWF  x97,F
019A:  BSF    x90.7
019C:  BSF    x94.7
019E:  MOVF   x92,W
01A0:  MULWF  x96
01A2:  MOVFF  FF4,99
01A6:  MOVF   x91,W
01A8:  MULWF  x95
01AA:  MOVFF  FF4,03
01AE:  MOVFF  FF3,98
01B2:  MULWF  x96
01B4:  MOVF   FF3,W
01B6:  ADDWF  x99,F
01B8:  MOVF   FF4,W
01BA:  ADDWFC x98,F
01BC:  MOVLW  00
01BE:  ADDWFC 03,F
01C0:  MOVF   x92,W
01C2:  MULWF  x95
01C4:  MOVF   FF3,W
01C6:  ADDWF  x99,F
01C8:  MOVF   FF4,W
01CA:  ADDWFC x98,F
01CC:  MOVLW  00
01CE:  CLRF   02
01D0:  ADDWFC 03,F
01D2:  ADDWFC 02,F
01D4:  MOVF   x90,W
01D6:  MULWF  x96
01D8:  MOVF   FF3,W
01DA:  ADDWF  x98,F
01DC:  MOVF   FF4,W
01DE:  ADDWFC 03,F
01E0:  MOVLW  00
01E2:  ADDWFC 02,F
01E4:  MOVF   x90,W
01E6:  MULWF  x95
01E8:  MOVF   FF3,W
01EA:  ADDWF  03,F
01EC:  MOVF   FF4,W
01EE:  ADDWFC 02,F
01F0:  MOVLW  00
01F2:  CLRF   01
01F4:  ADDWFC 01,F
01F6:  MOVF   x92,W
01F8:  MULWF  x94
01FA:  MOVF   FF3,W
01FC:  ADDWF  x98,F
01FE:  MOVF   FF4,W
0200:  ADDWFC 03,F
0202:  MOVLW  00
0204:  ADDWFC 02,F
0206:  ADDWFC 01,F
0208:  MOVF   x91,W
020A:  MULWF  x94
020C:  MOVF   FF3,W
020E:  ADDWF  03,F
0210:  MOVF   FF4,W
0212:  ADDWFC 02,F
0214:  MOVLW  00
0216:  ADDWFC 01,F
0218:  MOVF   x90,W
021A:  MULWF  x94
021C:  MOVF   FF3,W
021E:  ADDWF  02,F
0220:  MOVF   FF4,W
0222:  ADDWFC 01,F
0224:  INCF   00,F
0226:  BTFSC  01.7
0228:  BRA    0234
022A:  RLCF   x98,F
022C:  RLCF   03,F
022E:  RLCF   02,F
0230:  RLCF   01,F
0232:  DECF   00,F
0234:  MOVLW  00
0236:  BTFSS  x98.7
0238:  BRA    024E
023A:  INCF   03,F
023C:  ADDWFC 02,F
023E:  ADDWFC 01,F
0240:  MOVF   01,W
0242:  BNZ   024E
0244:  MOVF   02,W
0246:  BNZ   024E
0248:  MOVF   03,W
024A:  BNZ   024E
024C:  INCF   00,F
024E:  BTFSC  x97.7
0250:  BSF    01.7
0252:  BTFSS  x97.7
0254:  BCF    01.7
0256:  BRA    0260
0258:  CLRF   00
025A:  CLRF   01
025C:  CLRF   02
025E:  CLRF   03
0260:  RETURN 0
0262:  MOVLW  8E
0264:  MOVWF  00
0266:  MOVFF  7B,01
026A:  MOVFF  7A,02
026E:  CLRF   03
0270:  MOVF   01,F
0272:  BNZ   0286
0274:  MOVFF  02,01
0278:  CLRF   02
027A:  MOVLW  08
027C:  SUBWF  00,F
027E:  MOVF   01,F
0280:  BNZ   0286
0282:  CLRF   00
0284:  BRA    0296
0286:  BCF    FD8.0
0288:  BTFSC  01.7
028A:  BRA    0294
028C:  RLCF   02,F
028E:  RLCF   01,F
0290:  DECF   00,F
0292:  BRA    0286
0294:  BCF    01.7
0296:  RETURN 0
0298:  MOVF   x8F,W
029A:  BTFSC  FD8.2
029C:  BRA    03E8
029E:  MOVWF  x9B
02A0:  MOVF   x93,W
02A2:  BTFSC  FD8.2
02A4:  BRA    03E8
02A6:  SUBWF  x9B,F
02A8:  BNC   02B4
02AA:  MOVLW  7F
02AC:  ADDWF  x9B,F
02AE:  BTFSC  FD8.0
02B0:  BRA    03E8
02B2:  BRA    02C0
02B4:  MOVLW  81
02B6:  SUBWF  x9B,F
02B8:  BTFSS  FD8.0
02BA:  BRA    03E8
02BC:  BTFSC  FD8.2
02BE:  BRA    03E8
02C0:  MOVFF  9B,00
02C4:  CLRF   01
02C6:  CLRF   02
02C8:  CLRF   03
02CA:  CLRF   x9A
02CC:  MOVFF  90,99
02D0:  BSF    x99.7
02D2:  MOVFF  91,98
02D6:  MOVFF  92,97
02DA:  MOVLW  19
02DC:  MOVWF  x9B
02DE:  MOVF   x96,W
02E0:  SUBWF  x97,F
02E2:  BC    02FE
02E4:  MOVLW  01
02E6:  SUBWF  x98,F
02E8:  BC    02FE
02EA:  SUBWF  x99,F
02EC:  BC    02FE
02EE:  SUBWF  x9A,F
02F0:  BC    02FE
02F2:  INCF   x9A,F
02F4:  INCF   x99,F
02F6:  INCF   x98,F
02F8:  MOVF   x96,W
02FA:  ADDWF  x97,F
02FC:  BRA    034E
02FE:  MOVF   x95,W
0300:  SUBWF  x98,F
0302:  BC    0328
0304:  MOVLW  01
0306:  SUBWF  x99,F
0308:  BC    0328
030A:  SUBWF  x9A,F
030C:  BC    0328
030E:  INCF   x9A,F
0310:  INCF   x99,F
0312:  MOVF   x95,W
0314:  ADDWF  x98,F
0316:  MOVF   x96,W
0318:  ADDWF  x97,F
031A:  BNC   034E
031C:  INCF   x98,F
031E:  BNZ   034E
0320:  INCF   x99,F
0322:  BNZ   034E
0324:  INCF   x9A,F
0326:  BRA    034E
0328:  MOVF   x94,W
032A:  IORLW  80
032C:  SUBWF  x99,F
032E:  BC    034C
0330:  MOVLW  01
0332:  SUBWF  x9A,F
0334:  BC    034C
0336:  INCF   x9A,F
0338:  MOVF   x94,W
033A:  IORLW  80
033C:  ADDWF  x99,F
033E:  MOVF   x95,W
0340:  ADDWF  x98,F
0342:  BNC   0316
0344:  INCF   x99,F
0346:  BNZ   0316
0348:  INCF   x9A,F
034A:  BRA    0316
034C:  BSF    03.0
034E:  DECFSZ x9B,F
0350:  BRA    0354
0352:  BRA    036A
0354:  BCF    FD8.0
0356:  RLCF   x97,F
0358:  RLCF   x98,F
035A:  RLCF   x99,F
035C:  RLCF   x9A,F
035E:  BCF    FD8.0
0360:  RLCF   03,F
0362:  RLCF   02,F
0364:  RLCF   01,F
0366:  RLCF   x9C,F
0368:  BRA    02DE
036A:  BTFSS  x9C.0
036C:  BRA    037A
036E:  BCF    FD8.0
0370:  RRCF   01,F
0372:  RRCF   02,F
0374:  RRCF   03,F
0376:  RRCF   x9C,F
0378:  BRA    037E
037A:  DECF   00,F
037C:  BZ    03E8
037E:  BTFSC  x9C.7
0380:  BRA    03BE
0382:  BCF    FD8.0
0384:  RLCF   x97,F
0386:  RLCF   x98,F
0388:  RLCF   x99,F
038A:  RLCF   x9A,F
038C:  MOVF   x96,W
038E:  SUBWF  x97,F
0390:  BC    03A0
0392:  MOVLW  01
0394:  SUBWF  x98,F
0396:  BC    03A0
0398:  SUBWF  x99,F
039A:  BC    03A0
039C:  SUBWF  x9A,F
039E:  BNC   03D4
03A0:  MOVF   x95,W
03A2:  SUBWF  x98,F
03A4:  BC    03B0
03A6:  MOVLW  01
03A8:  SUBWF  x99,F
03AA:  BC    03B0
03AC:  SUBWF  x9A,F
03AE:  BNC   03D4
03B0:  MOVF   x94,W
03B2:  IORLW  80
03B4:  SUBWF  x99,F
03B6:  BC    03BE
03B8:  MOVLW  01
03BA:  SUBWF  x9A,F
03BC:  BNC   03D4
03BE:  INCF   03,F
03C0:  BNZ   03D4
03C2:  INCF   02,F
03C4:  BNZ   03D4
03C6:  INCF   01,F
03C8:  BNZ   03D4
03CA:  INCF   00,F
03CC:  BZ    03E8
03CE:  RRCF   01,F
03D0:  RRCF   02,F
03D2:  RRCF   03,F
03D4:  MOVFF  90,9B
03D8:  MOVF   x94,W
03DA:  XORWF  x9B,F
03DC:  BTFSS  x9B.7
03DE:  BRA    03E4
03E0:  BSF    01.7
03E2:  BRA    03F0
03E4:  BCF    01.7
03E6:  BRA    03F0
03E8:  CLRF   00
03EA:  CLRF   01
03EC:  CLRF   02
03EE:  CLRF   03
03F0:  RETURN 0
*
07BE:  MOVLW  8E
07C0:  MOVWF  00
07C2:  MOVF   x75,W
07C4:  SUBWF  00,F
07C6:  MOVFF  76,02
07CA:  MOVFF  77,01
07CE:  BSF    02.7
07D0:  MOVF   00,F
07D2:  BZ    07E6
07D4:  BCF    FD8.0
07D6:  MOVF   02,F
07D8:  BNZ   07DE
07DA:  MOVF   01,F
07DC:  BZ    07E6
07DE:  RRCF   02,F
07E0:  RRCF   01,F
07E2:  DECFSZ 00,F
07E4:  BRA    07D4
07E6:  BTFSS  x76.7
07E8:  BRA    07F4
07EA:  COMF   01,F
07EC:  COMF   02,F
07EE:  INCF   01,F
07F0:  BTFSC  FD8.2
07F2:  INCF   02,F
07F4:  GOTO   0832 (RETURN)
*
0836:  MOVLW  80
0838:  BTFSC  FD8.1
083A:  XORWF  x94,F
083C:  CLRF   x99
083E:  CLRF   x9A
0840:  MOVFF  90,98
0844:  MOVF   x94,W
0846:  XORWF  x98,F
0848:  MOVF   x8F,W
084A:  BTFSC  FD8.2
084C:  BRA    0A06
084E:  MOVWF  x97
0850:  MOVWF  00
0852:  MOVF   x93,W
0854:  BTFSC  FD8.2
0856:  BRA    0A18
0858:  SUBWF  x97,F
085A:  BTFSC  FD8.2
085C:  BRA    0960
085E:  BNC   08DA
0860:  MOVFF  94,9D
0864:  BSF    x9D.7
0866:  MOVFF  95,9C
086A:  MOVFF  96,9B
086E:  CLRF   x9A
0870:  BCF    FD8.0
0872:  RRCF   x9D,F
0874:  RRCF   x9C,F
0876:  RRCF   x9B,F
0878:  RRCF   x9A,F
087A:  DECFSZ x97,F
087C:  BRA    086E
087E:  BTFSS  x98.7
0880:  BRA    0888
0882:  BSF    x99.0
0884:  BRA    0A40
0886:  BCF    x99.0
0888:  BCF    x97.0
088A:  BSF    x99.4
088C:  CLRF   FEA
088E:  MOVLW  92
0890:  MOVWF  FE9
0892:  BRA    0A66
0894:  BCF    x99.4
0896:  BTFSC  x98.7
0898:  BRA    08AE
089A:  BTFSS  x97.0
089C:  BRA    08C4
089E:  RRCF   x9D,F
08A0:  RRCF   x9C,F
08A2:  RRCF   x9B,F
08A4:  RRCF   x9A,F
08A6:  INCF   00,F
08A8:  BTFSC  FD8.2
08AA:  BRA    0A36
08AC:  BRA    08C4
08AE:  BTFSC  x9D.7
08B0:  BRA    08CA
08B2:  BCF    FD8.0
08B4:  RLCF   x9A,F
08B6:  RLCF   x9B,F
08B8:  RLCF   x9C,F
08BA:  RLCF   x9D,F
08BC:  DECF   00,F
08BE:  BTFSC  FD8.2
08C0:  BRA    0A36
08C2:  BRA    08AE
08C4:  BSF    x99.6
08C6:  BRA    099E
08C8:  BCF    x99.6
08CA:  MOVFF  90,98
08CE:  BTFSS  x90.7
08D0:  BRA    08D6
08D2:  BSF    x9D.7
08D4:  BRA    0A28
08D6:  BCF    x9D.7
08D8:  BRA    0A28
08DA:  MOVFF  93,97
08DE:  MOVFF  93,00
08E2:  MOVF   x8F,W
08E4:  SUBWF  x97,F
08E6:  MOVFF  90,9D
08EA:  BSF    x9D.7
08EC:  MOVFF  91,9C
08F0:  MOVFF  92,9B
08F4:  CLRF   x9A
08F6:  BCF    FD8.0
08F8:  RRCF   x9D,F
08FA:  RRCF   x9C,F
08FC:  RRCF   x9B,F
08FE:  RRCF   x9A,F
0900:  DECFSZ x97,F
0902:  BRA    08F4
0904:  BTFSS  x98.7
0906:  BRA    090E
0908:  BSF    x99.1
090A:  BRA    0A40
090C:  BCF    x99.1
090E:  BCF    x97.0
0910:  BSF    x99.5
0912:  CLRF   FEA
0914:  MOVLW  96
0916:  MOVWF  FE9
0918:  BRA    0A66
091A:  BCF    x99.5
091C:  BTFSC  x98.7
091E:  BRA    0934
0920:  BTFSS  x97.0
0922:  BRA    094A
0924:  RRCF   x9D,F
0926:  RRCF   x9C,F
0928:  RRCF   x9B,F
092A:  RRCF   x9A,F
092C:  INCF   00,F
092E:  BTFSC  FD8.2
0930:  BRA    0A36
0932:  BRA    094A
0934:  BTFSC  x9D.7
0936:  BRA    0950
0938:  BCF    FD8.0
093A:  RLCF   x9A,F
093C:  RLCF   x9B,F
093E:  RLCF   x9C,F
0940:  RLCF   x9D,F
0942:  DECF   00,F
0944:  BTFSC  FD8.2
0946:  BRA    0A36
0948:  BRA    0934
094A:  BSF    x99.7
094C:  BRA    099E
094E:  BCF    x99.7
0950:  MOVFF  94,98
0954:  BTFSS  x94.7
0956:  BRA    095C
0958:  BSF    x9D.7
095A:  BRA    0A28
095C:  BCF    x9D.7
095E:  BRA    0A28
0960:  MOVFF  94,9D
0964:  BSF    x9D.7
0966:  MOVFF  95,9C
096A:  MOVFF  96,9B
096E:  BTFSS  x98.7
0970:  BRA    097A
0972:  BCF    x9D.7
0974:  BSF    x99.2
0976:  BRA    0A40
0978:  BCF    x99.2
097A:  CLRF   x9A
097C:  BCF    x97.0
097E:  CLRF   FEA
0980:  MOVLW  92
0982:  MOVWF  FE9
0984:  BRA    0A66
0986:  BTFSC  x98.7
0988:  BRA    09C2
098A:  MOVFF  90,98
098E:  BTFSS  x97.0
0990:  BRA    099E
0992:  RRCF   x9D,F
0994:  RRCF   x9C,F
0996:  RRCF   x9B,F
0998:  RRCF   x9A,F
099A:  INCF   00,F
099C:  BZ    0A36
099E:  BTFSS  x9A.7
09A0:  BRA    09B8
09A2:  INCF   x9B,F
09A4:  BNZ   09B8
09A6:  INCF   x9C,F
09A8:  BNZ   09B8
09AA:  INCF   x9D,F
09AC:  BNZ   09B8
09AE:  RRCF   x9D,F
09B0:  RRCF   x9C,F
09B2:  RRCF   x9B,F
09B4:  INCF   00,F
09B6:  BZ    0A36
09B8:  BTFSC  x99.6
09BA:  BRA    08C8
09BC:  BTFSC  x99.7
09BE:  BRA    094E
09C0:  BRA    09FA
09C2:  MOVLW  80
09C4:  XORWF  x9D,F
09C6:  BTFSS  x9D.7
09C8:  BRA    09D2
09CA:  BRA    0A40
09CC:  MOVFF  94,98
09D0:  BRA    09E6
09D2:  MOVFF  90,98
09D6:  MOVF   x9D,F
09D8:  BNZ   09E6
09DA:  MOVF   x9C,F
09DC:  BNZ   09E6
09DE:  MOVF   x9B,F
09E0:  BNZ   09E6
09E2:  CLRF   00
09E4:  BRA    0A28
09E6:  BTFSC  x9D.7
09E8:  BRA    09FA
09EA:  BCF    FD8.0
09EC:  RLCF   x9A,F
09EE:  RLCF   x9B,F
09F0:  RLCF   x9C,F
09F2:  RLCF   x9D,F
09F4:  DECFSZ 00,F
09F6:  BRA    09E6
09F8:  BRA    0A36
09FA:  BTFSS  x98.7
09FC:  BRA    0A02
09FE:  BSF    x9D.7
0A00:  BRA    0A28
0A02:  BCF    x9D.7
0A04:  BRA    0A28
0A06:  MOVFF  93,00
0A0A:  MOVFF  94,9D
0A0E:  MOVFF  95,9C
0A12:  MOVFF  96,9B
0A16:  BRA    0A28
0A18:  MOVFF  8F,00
0A1C:  MOVFF  90,9D
0A20:  MOVFF  91,9C
0A24:  MOVFF  92,9B
0A28:  MOVFF  9D,01
0A2C:  MOVFF  9C,02
0A30:  MOVFF  9B,03
0A34:  BRA    0A9E
0A36:  CLRF   00
0A38:  CLRF   01
0A3A:  CLRF   02
0A3C:  CLRF   03
0A3E:  BRA    0A9E
0A40:  CLRF   x9A
0A42:  COMF   x9B,F
0A44:  COMF   x9C,F
0A46:  COMF   x9D,F
0A48:  COMF   x9A,F
0A4A:  INCF   x9A,F
0A4C:  BNZ   0A58
0A4E:  INCF   x9B,F
0A50:  BNZ   0A58
0A52:  INCF   x9C,F
0A54:  BNZ   0A58
0A56:  INCF   x9D,F
0A58:  BTFSC  x99.0
0A5A:  BRA    0886
0A5C:  BTFSC  x99.1
0A5E:  BRA    090C
0A60:  BTFSC  x99.2
0A62:  BRA    0978
0A64:  BRA    09CC
0A66:  MOVF   FEF,W
0A68:  ADDWF  x9B,F
0A6A:  BNC   0A76
0A6C:  INCF   x9C,F
0A6E:  BNZ   0A76
0A70:  INCF   x9D,F
0A72:  BTFSC  FD8.2
0A74:  BSF    x97.0
0A76:  MOVF   FED,F
0A78:  MOVF   FEF,W
0A7A:  ADDWF  x9C,F
0A7C:  BNC   0A84
0A7E:  INCF   x9D,F
0A80:  BTFSC  FD8.2
0A82:  BSF    x97.0
0A84:  MOVF   FED,F
0A86:  MOVF   FEF,W
0A88:  BTFSC  FEF.7
0A8A:  BRA    0A8E
0A8C:  XORLW  80
0A8E:  ADDWF  x9D,F
0A90:  BTFSC  FD8.0
0A92:  BSF    x97.0
0A94:  BTFSC  x99.4
0A96:  BRA    0894
0A98:  BTFSC  x99.5
0A9A:  BRA    091A
0A9C:  BRA    0986
0A9E:  RETURN 0
*
0C1A:  MOVF   x7F,W
0C1C:  SUBLW  B6
0C1E:  MOVWF  x7F
0C20:  CLRF   03
0C22:  MOVFF  80,83
0C26:  BSF    x80.7
0C28:  BCF    FD8.0
0C2A:  RRCF   x80,F
0C2C:  RRCF   x81,F
0C2E:  RRCF   x82,F
0C30:  RRCF   03,F
0C32:  RRCF   02,F
0C34:  RRCF   01,F
0C36:  RRCF   00,F
0C38:  DECFSZ x7F,F
0C3A:  BRA    0C28
0C3C:  BTFSS  x83.7
0C3E:  BRA    0C56
0C40:  COMF   00,F
0C42:  COMF   01,F
0C44:  COMF   02,F
0C46:  COMF   03,F
0C48:  INCF   00,F
0C4A:  BTFSC  FD8.2
0C4C:  INCF   01,F
0C4E:  BTFSC  FD8.2
0C50:  INCF   02,F
0C52:  BTFSC  FD8.2
0C54:  INCF   03,F
0C56:  RETURN 0
*
0CD0:  MOVLW  B6
0CD2:  MOVWF  00
0CD4:  CLRF   03
0CD6:  CLRF   02
0CD8:  CLRF   01
0CDA:  MOVF   x73,W
0CDC:  IORWF  x74,W
0CDE:  IORWF  x75,W
0CE0:  IORWF  x76,W
0CE2:  BNZ   0CE8
0CE4:  CLRF   00
0CE6:  BRA    0D02
0CE8:  BCF    FD8.0
0CEA:  BTFSC  01.7
0CEC:  BRA    0D00
0CEE:  RLCF   x73,F
0CF0:  RLCF   x74,F
0CF2:  RLCF   x75,F
0CF4:  RLCF   x76,F
0CF6:  RLCF   03,F
0CF8:  RLCF   02,F
0CFA:  RLCF   01,F
0CFC:  DECFSZ 00,F
0CFE:  BRA    0CE8
0D00:  BCF    01.7
0D02:  GOTO   10EC (RETURN)
*
11A6:  TBLRD*+
11A8:  MOVFF  FF6,73
11AC:  MOVFF  FF7,74
11B0:  MOVFF  FF5,7F
11B4:  RCALL  1168
11B6:  MOVFF  73,FF6
11BA:  MOVFF  74,FF7
11BE:  DECFSZ x72,F
11C0:  BRA    11A6
11C2:  RETURN 0
11C4:  BTFSC  FD8.1
11C6:  BRA    11CE
11C8:  CLRF   FEA
11CA:  MOVLW  87
11CC:  MOVWF  FE9
11CE:  CLRF   00
11D0:  CLRF   01
11D2:  CLRF   02
11D4:  CLRF   03
11D6:  CLRF   x87
11D8:  CLRF   x88
11DA:  CLRF   x89
11DC:  CLRF   x8A
11DE:  MOVF   x86,W
11E0:  IORWF  x85,W
11E2:  IORWF  x84,W
11E4:  IORWF  x83,W
11E6:  BZ    1240
11E8:  MOVLW  20
11EA:  MOVWF  x8B
11EC:  BCF    FD8.0
11EE:  RLCF   x7F,F
11F0:  RLCF   x80,F
11F2:  RLCF   x81,F
11F4:  RLCF   x82,F
11F6:  RLCF   x87,F
11F8:  RLCF   x88,F
11FA:  RLCF   x89,F
11FC:  RLCF   x8A,F
11FE:  MOVF   x86,W
1200:  SUBWF  x8A,W
1202:  BNZ   1214
1204:  MOVF   x85,W
1206:  SUBWF  x89,W
1208:  BNZ   1214
120A:  MOVF   x84,W
120C:  SUBWF  x88,W
120E:  BNZ   1214
1210:  MOVF   x83,W
1212:  SUBWF  x87,W
1214:  BNC   1234
1216:  MOVF   x83,W
1218:  SUBWF  x87,F
121A:  MOVF   x84,W
121C:  BTFSS  FD8.0
121E:  INCFSZ x84,W
1220:  SUBWF  x88,F
1222:  MOVF   x85,W
1224:  BTFSS  FD8.0
1226:  INCFSZ x85,W
1228:  SUBWF  x89,F
122A:  MOVF   x86,W
122C:  BTFSS  FD8.0
122E:  INCFSZ x86,W
1230:  SUBWF  x8A,F
1232:  BSF    FD8.0
1234:  RLCF   00,F
1236:  RLCF   01,F
1238:  RLCF   02,F
123A:  RLCF   03,F
123C:  DECFSZ x8B,F
123E:  BRA    11EC
1240:  MOVFF  87,FEF
1244:  MOVFF  88,FEC
1248:  MOVFF  89,FEC
124C:  MOVFF  8A,FEC
1250:  RETURN 0
1252:  MOVF   FE9,W
1254:  MOVWF  x77
1256:  MOVF   x76,W
1258:  MOVWF  x79
125A:  BZ    1290
125C:  MOVFF  75,92
1260:  MOVFF  74,91
1264:  MOVFF  73,90
1268:  MOVFF  72,8F
126C:  CLRF   x96
126E:  CLRF   x95
1270:  MOVLW  20
1272:  MOVWF  x94
1274:  MOVLW  82
1276:  MOVWF  x93
1278:  CALL   0170
127C:  MOVFF  03,75
1280:  MOVFF  02,74
1284:  MOVFF  01,73
1288:  MOVFF  00,72
128C:  DECFSZ x79,F
128E:  BRA    125C
1290:  MOVLW  7E
1292:  MOVWF  00
1294:  CLRF   01
1296:  BTFSC  x73.7
1298:  BSF    01.7
129A:  CLRF   02
129C:  CLRF   03
129E:  BCF    FD8.1
12A0:  MOVFF  75,92
12A4:  MOVFF  74,91
12A8:  MOVFF  73,90
12AC:  MOVFF  72,8F
12B0:  MOVFF  03,96
12B4:  MOVFF  02,95
12B8:  MOVFF  01,94
12BC:  MOVWF  x93
12BE:  CALL   0836
12C2:  MOVFF  03,75
12C6:  MOVFF  02,74
12CA:  MOVFF  01,73
12CE:  MOVFF  00,72
12D2:  MOVFF  75,82
12D6:  MOVFF  74,81
12DA:  MOVFF  73,80
12DE:  MOVFF  72,7F
12E2:  RCALL  0C1A
12E4:  MOVFF  03,75
12E8:  MOVFF  02,74
12EC:  MOVFF  01,73
12F0:  MOVFF  00,72
12F4:  BTFSS  x75.7
12F6:  BRA    1312
12F8:  DECF   x77,F
12FA:  BSF    x77.5
12FC:  COMF   x72,F
12FE:  COMF   x73,F
1300:  COMF   x74,F
1302:  COMF   x75,F
1304:  INCF   x72,F
1306:  BTFSC  FD8.2
1308:  INCF   x73,F
130A:  BTFSC  FD8.2
130C:  INCF   x74,F
130E:  BTFSC  FD8.2
1310:  INCF   x75,F
1312:  MOVLW  3B
1314:  MOVWF  x7E
1316:  MOVLW  9A
1318:  MOVWF  x7D
131A:  MOVLW  CA
131C:  MOVWF  x7C
131E:  CLRF   x7B
1320:  MOVLW  0A
1322:  MOVWF  x79
1324:  MOVF   x76,W
1326:  BTFSC  FD8.2
1328:  INCF   x77,F
132A:  BSF    FD8.1
132C:  CLRF   FEA
132E:  MOVLW  72
1330:  MOVWF  FE9
1332:  MOVFF  75,82
1336:  MOVFF  74,81
133A:  MOVFF  73,80
133E:  MOVFF  72,7F
1342:  MOVFF  7E,86
1346:  MOVFF  7D,85
134A:  MOVFF  7C,84
134E:  MOVFF  7B,83
1352:  RCALL  11C4
1354:  MOVF   01,W
1356:  MOVF   00,F
1358:  BNZ   1378
135A:  INCF   x76,W
135C:  SUBWF  x79,W
135E:  BZ    1378
1360:  MOVF   x77,W
1362:  BZ    137C
1364:  ANDLW  0F
1366:  SUBWF  x79,W
1368:  BZ    136C
136A:  BC    13DA
136C:  BTFSC  x77.7
136E:  BRA    13DA
1370:  BTFSC  x77.6
1372:  BRA    137C
1374:  MOVLW  20
1376:  BRA    13D2
1378:  MOVLW  20
137A:  ANDWF  x77,F
137C:  BTFSS  x77.5
137E:  BRA    1398
1380:  BCF    x77.5
1382:  MOVF   x76,W
1384:  BTFSS  FD8.2
1386:  DECF   x77,F
1388:  MOVF   00,W
138A:  MOVWF  x77
138C:  MOVLW  2D
138E:  MOVWF  x7F
1390:  RCALL  1168
1392:  MOVF   x77,W
1394:  MOVWF  00
1396:  CLRF   x77
1398:  MOVF   x76,W
139A:  SUBWF  x79,W
139C:  BNZ   13B2
139E:  MOVF   00,W
13A0:  MOVWF  x77
13A2:  MOVLW  2E
13A4:  MOVWF  x7F
13A6:  RCALL  1168
13A8:  MOVF   x77,W
13AA:  MOVWF  00
13AC:  MOVLW  20
13AE:  ANDWF  x77,F
13B0:  MOVLW  00
13B2:  MOVLW  30
13B4:  BTFSS  x77.5
13B6:  BRA    13D2
13B8:  BCF    x77.5
13BA:  MOVF   x76,W
13BC:  BTFSS  FD8.2
13BE:  DECF   x77,F
13C0:  MOVF   00,W
13C2:  MOVWF  x77
13C4:  MOVLW  2D
13C6:  MOVWF  x7F
13C8:  RCALL  1168
13CA:  MOVF   x77,W
13CC:  MOVWF  00
13CE:  CLRF   x77
13D0:  MOVLW  30
13D2:  ADDWF  00,F
13D4:  MOVFF  00,7F
13D8:  RCALL  1168
13DA:  BCF    FD8.1
13DC:  MOVFF  7E,82
13E0:  MOVFF  7D,81
13E4:  MOVFF  7C,80
13E8:  MOVFF  7B,7F
13EC:  CLRF   x86
13EE:  CLRF   x85
13F0:  CLRF   x84
13F2:  MOVLW  0A
13F4:  MOVWF  x83
13F6:  RCALL  11C4
13F8:  MOVFF  03,7E
13FC:  MOVFF  02,7D
1400:  MOVFF  01,7C
1404:  MOVFF  00,7B
1408:  DECFSZ x79,F
140A:  BRA    132A
140C:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(internal=8MHz) 
*
0798:  CLRF   FEA
079A:  MOVLW  7A
079C:  MOVWF  FE9
079E:  MOVF   FEF,W
07A0:  BZ    07BC
07A2:  MOVLW  02
07A4:  MOVWF  01
07A6:  CLRF   00
07A8:  DECFSZ 00,F
07AA:  BRA    07A8
07AC:  DECFSZ 01,F
07AE:  BRA    07A6
07B0:  MOVLW  97
07B2:  MOVWF  00
07B4:  DECFSZ 00,F
07B6:  BRA    07B4
07B8:  DECFSZ FEF,F
07BA:  BRA    07A2
07BC:  RETURN 0
.................... #use i2c(Master,Fast,sda=PIN_A0,scl=PIN_A1) 
*
0026:  MOVLW  08
0028:  MOVWF  01
002A:  NOP   
002C:  BCF    F89.1
002E:  BCF    F92.1
0030:  NOP   
0032:  RLCF   x7C,F
0034:  BCF    F89.0
0036:  BTFSC  FD8.0
0038:  BSF    F92.0
003A:  BTFSS  FD8.0
003C:  BCF    F92.0
003E:  BSF    F92.1
0040:  BTFSS  F80.1
0042:  BRA    0040
0044:  DECFSZ 01,F
0046:  BRA    002A
0048:  NOP   
004A:  BCF    F89.1
004C:  BCF    F92.1
004E:  NOP   
0050:  BSF    F92.0
0052:  NOP   
0054:  NOP   
0056:  BSF    F92.1
0058:  BTFSS  F80.1
005A:  BRA    0058
005C:  CLRF   01
005E:  NOP   
0060:  BTFSC  F80.0
0062:  BSF    01.0
0064:  BCF    F89.1
0066:  BCF    F92.1
0068:  BCF    F89.0
006A:  BCF    F92.0
006C:  RETURN 0
006E:  MOVLW  08
0070:  MOVWF  x7D
0072:  MOVFF  00,7E
0076:  BSF    F92.0
0078:  NOP   
007A:  BSF    F92.1
007C:  BTFSS  F80.1
007E:  BRA    007C
0080:  BTFSC  F80.0
0082:  BSF    FD8.0
0084:  BTFSS  F80.0
0086:  BCF    FD8.0
0088:  RLCF   01,F
008A:  NOP   
008C:  BCF    F92.1
008E:  BCF    F89.1
0090:  DECFSZ x7D,F
0092:  BRA    0076
0094:  BSF    F92.0
0096:  NOP   
0098:  BCF    F89.0
009A:  MOVF   x7E,W
009C:  BTFSS  FD8.2
009E:  BCF    F92.0
00A0:  NOP   
00A2:  BSF    F92.1
00A4:  BTFSS  F80.1
00A6:  BRA    00A4
00A8:  NOP   
00AA:  BCF    F89.1
00AC:  BCF    F92.1
00AE:  NOP   
00B0:  BCF    F89.0
00B2:  BCF    F92.0
00B4:  RETURN 0
.................... #use rs232(baud=115200,parity=N,xmit=PIN_A3,rcv=PIN_A4,stream=asd) 
*
1168:  BCF    F92.3
116A:  BCF    F89.3
116C:  MOVLW  08
116E:  MOVWF  01
1170:  BRA    1172
1172:  NOP   
1174:  BSF    01.7
1176:  BRA    119C
1178:  BCF    01.7
117A:  MOVFF  7F,02
117E:  RRCF   02,F
1180:  BTFSC  FD8.0
1182:  BSF    F89.3
1184:  BTFSS  FD8.0
1186:  BCF    F89.3
1188:  BSF    01.6
118A:  BRA    119C
118C:  BCF    01.6
118E:  DECFSZ 01,F
1190:  BRA    117E
1192:  MOVFF  02,7F
1196:  BRA    1198
1198:  NOP   
119A:  BSF    F89.3
119C:  BTFSC  01.7
119E:  BRA    1178
11A0:  BTFSC  01.6
11A2:  BRA    118C
11A4:  RETURN 0
....................  
.................... #include <BMP085.c> 
....................  
.................... //************************************************  
.................... //  BMP085 Barometric Pressure Sensor  
.................... //  
.................... //  - Datasheet: http://www.bosch-sensortec.com/content/language1/downloads/BST-BMP085-DS000-05.pdf  
.................... //  
.................... //  - Written in CCS PCH C using floating point math  
.................... //  - Several integer math versions of this driver exist but the speed improvement is  
.................... //    not warranted in typical weather station type applications  
.................... //   
.................... //  - Based on a paper posted to thebackshed.com by DuinoMiteMegaAn  
.................... //    http://www.thebackshed.com/forum/forum_posts.asp?TID=4768&PN=9   
.................... //  
.................... //  - Usage:  
.................... //     Call once: bmp085Calibration();  
.................... //     P_mBar_float = BMP085Pressure(true);  //  calls for temperature first  
.................... //     P_mBar_float = BMP085Pressure(false);  // skips temperature reading, assumes done previously  
.................... //     T_Cent_float = BMP085Temperature();  
.................... //     t_reading = _Temp;  _Temp set on every temperature reading  
.................... //        Note:   pressure reading is temp compensated so call for temp reading prior to pressure reading periodically or on each reading  
.................... //  
.................... //  Al Testani  
.................... //  08/17/12  
.................... //************************************************  
....................  
.................... // place a #use i2c statement in the main program and comment this out if not applicable  
.................... //#use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST, FORCE_HW)  
....................  
.................... #include <math.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... const int8 OVS_S = 3; // Oversampling Setting (0,1,2,3 from ultra low power, to ultra hi-resolution)  
....................  
.................... #define BMP085_ADDRESS 0xEE          // I2C address of BMP085  
.................... #define P_CORRECTION   1.5           // in mBars - factor to adjust for elevation to match local weather station pressure  
....................                                      // this value for 14' above sea level (in Boca Raton, Florida)  
....................  
....................  
.................... // Calibration values  
.................... signed int16 ac1;  
.................... signed int16 ac2;  
.................... signed int16 ac3;  
.................... int16 ac4;  
.................... int16 ac5;  
.................... int16 ac6;  
.................... signed int16 b1;  
.................... signed int16 b2;  
.................... signed int16 mb;  
.................... signed int16 mc;  
.................... signed int16 md;  
....................  
.................... // floating point cal factors  
.................... float _c3;  
.................... float _c4;  
.................... float _b1;  
.................... float _c5;  
.................... float _c6;  
.................... float _mc;  
.................... float _md;  
....................  
.................... // polynomomial constants  
.................... float _x0;  
.................... float _x1;  
.................... float _x2;  
.................... float _y0;  
.................... float _y1;  
.................... float _y2;  
.................... float _p0;  
.................... float _p1;  
.................... float _p2;  
....................  
.................... float _s;     // T-25, used in pressure calculation - must run temperature reading before pressure reading  
.................... float _Temp;  // set after every temperature or temperature/pressure reading  
....................  
....................  
.................... //----------------------------------------------  
.................... int8 BMP085ReadByte(int8 address)  
.................... //----------------------------------------------  
.................... {  
.................... int8 data;  
....................  
....................    i2c_start();  
*
0BB6:  BSF    F92.0
0BB8:  NOP   
0BBA:  BSF    F92.1
0BBC:  NOP   
0BBE:  BCF    F89.0
0BC0:  BCF    F92.0
0BC2:  NOP   
0BC4:  BCF    F89.1
0BC6:  BCF    F92.1
....................    i2c_write(BMP085_ADDRESS);  
0BC8:  MOVLW  EE
0BCA:  MOVWF  x7C
0BCC:  CALL   0026
....................    i2c_write(address);  
0BD0:  MOVFF  7A,7C
0BD4:  CALL   0026
....................    i2c_start();  
0BD8:  BSF    F92.0
0BDA:  NOP   
0BDC:  BSF    F92.1
0BDE:  NOP   
0BE0:  BTFSS  F80.1
0BE2:  BRA    0BE0
0BE4:  BCF    F89.0
0BE6:  BCF    F92.0
0BE8:  NOP   
0BEA:  BCF    F89.1
0BEC:  BCF    F92.1
....................    i2c_write(BMP085_ADDRESS | 0x01 );  
0BEE:  MOVLW  EF
0BF0:  MOVWF  x7C
0BF2:  CALL   0026
....................    data=i2c_read(0);  
0BF6:  CLRF   00
0BF8:  CALL   006E
0BFC:  MOVFF  01,7B
....................    i2c_stop();  
0C00:  BCF    F92.0
0C02:  NOP   
0C04:  BSF    F92.1
0C06:  BTFSS  F80.1
0C08:  BRA    0C06
0C0A:  NOP   
0C0C:  BRA    0C0E
0C0E:  NOP   
0C10:  BSF    F92.0
0C12:  NOP   
....................    return(data);  
0C14:  MOVFF  7B,01
0C18:  RETURN 0
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... int16 BMP085ReadInt(int8 address)  
.................... //----------------------------------------------  
.................... {  
.................... int8 msb, lsb;  
.................... int16 temp;  
....................  
....................    i2c_start();  
*
00B6:  BSF    F92.0
00B8:  NOP   
00BA:  BSF    F92.1
00BC:  NOP   
00BE:  BCF    F89.0
00C0:  BCF    F92.0
00C2:  NOP   
00C4:  BCF    F89.1
00C6:  BCF    F92.1
....................    i2c_write(BMP085_ADDRESS);  
00C8:  MOVLW  EE
00CA:  MOVWF  x7C
00CC:  RCALL  0026
....................    i2c_write(address);  
00CE:  MOVFF  75,7C
00D2:  RCALL  0026
....................    i2c_start();  
00D4:  BSF    F92.0
00D6:  NOP   
00D8:  BSF    F92.1
00DA:  NOP   
00DC:  BTFSS  F80.1
00DE:  BRA    00DC
00E0:  BCF    F89.0
00E2:  BCF    F92.0
00E4:  NOP   
00E6:  BCF    F89.1
00E8:  BCF    F92.1
....................    i2c_write(BMP085_ADDRESS | 0x01 );  
00EA:  MOVLW  EF
00EC:  MOVWF  x7C
00EE:  RCALL  0026
....................    msb = i2c_read();  
00F0:  MOVLW  01
00F2:  MOVWF  00
00F4:  RCALL  006E
00F6:  MOVFF  01,76
....................    lsb = i2c_read(0);  
00FA:  CLRF   00
00FC:  RCALL  006E
00FE:  MOVFF  01,77
....................    i2c_stop();  
0102:  BCF    F92.0
0104:  NOP   
0106:  BSF    F92.1
0108:  BTFSS  F80.1
010A:  BRA    0108
010C:  NOP   
010E:  BRA    0110
0110:  NOP   
0112:  BSF    F92.0
0114:  NOP   
....................    temp = make16(msb, lsb);  
0116:  MOVFF  76,79
011A:  MOVFF  77,78
....................    return ( temp );  
011E:  MOVFF  78,01
0122:  MOVFF  79,02
0126:  RETURN 0
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... void BMP085WriteByte(int8 address, int8 data)  
.................... //----------------------------------------------  
.................... {  
....................    i2c_start();  
*
075E:  BSF    F92.0
0760:  NOP   
0762:  BSF    F92.1
0764:  NOP   
0766:  BCF    F89.0
0768:  BCF    F92.0
076A:  NOP   
076C:  BCF    F89.1
076E:  BCF    F92.1
....................    i2c_write(BMP085_ADDRESS);  
0770:  MOVLW  EE
0772:  MOVWF  x7C
0774:  RCALL  0026
....................    i2c_write(address);  
0776:  MOVFF  7A,7C
077A:  RCALL  0026
....................    i2c_write(data);  
077C:  MOVFF  7B,7C
0780:  RCALL  0026
....................    i2c_stop();  
0782:  BCF    F92.0
0784:  NOP   
0786:  BSF    F92.1
0788:  BTFSS  F80.1
078A:  BRA    0788
078C:  NOP   
078E:  BRA    0790
0790:  NOP   
0792:  BSF    F92.0
0794:  NOP   
0796:  RETURN 0
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... void bmp085Calibration()  
.................... //----------------------------------------------  
.................... {  
....................    // read BMP085 EEPROM cal factors  
....................    ac1 = bmp085ReadInt(0xAA);  
*
03F2:  MOVLW  AA
03F4:  MOVWF  x75
03F6:  RCALL  00B6
03F8:  MOVFF  02,05
03FC:  MOVFF  01,04
....................    ac2 = bmp085ReadInt(0xAC);  
0400:  MOVLW  AC
0402:  MOVWF  x75
0404:  RCALL  00B6
0406:  MOVFF  02,07
040A:  MOVFF  01,06
....................    ac3 = bmp085ReadInt(0xAE);  
040E:  MOVLW  AE
0410:  MOVWF  x75
0412:  RCALL  00B6
0414:  MOVFF  02,09
0418:  MOVFF  01,08
....................    ac4 = bmp085ReadInt(0xB0);  
041C:  MOVLW  B0
041E:  MOVWF  x75
0420:  RCALL  00B6
0422:  MOVFF  02,0B
0426:  MOVFF  01,0A
....................    ac5 = bmp085ReadInt(0xB2);  
042A:  MOVLW  B2
042C:  MOVWF  x75
042E:  RCALL  00B6
0430:  MOVFF  02,0D
0434:  MOVFF  01,0C
....................    ac6 = bmp085ReadInt(0xB4);  
0438:  MOVLW  B4
043A:  MOVWF  x75
043C:  RCALL  00B6
043E:  MOVFF  02,0F
0442:  MOVFF  01,0E
....................    b1  = bmp085ReadInt(0xB6);  
0446:  MOVLW  B6
0448:  MOVWF  x75
044A:  RCALL  00B6
044C:  MOVFF  02,11
0450:  MOVFF  01,10
....................    b2  = bmp085ReadInt(0xB8);  
0454:  MOVLW  B8
0456:  MOVWF  x75
0458:  RCALL  00B6
045A:  MOVFF  02,13
045E:  MOVFF  01,12
....................    mb  = bmp085ReadInt(0xBA);  
0462:  MOVLW  BA
0464:  MOVWF  x75
0466:  RCALL  00B6
0468:  MOVFF  02,15
046C:  MOVFF  01,14
....................    mc  = bmp085ReadInt(0xBC);  
0470:  MOVLW  BC
0472:  MOVWF  x75
0474:  RCALL  00B6
0476:  MOVFF  02,17
047A:  MOVFF  01,16
....................    md  = bmp085ReadInt(0xBE);  
047E:  MOVLW  BE
0480:  MOVWF  x75
0482:  RCALL  00B6
0484:  MOVFF  02,19
0488:  MOVFF  01,18
....................  
....................     // calculate floating point cal factors  
....................    _c3 = 0.0048828125 * ac3;            // 160 * pow2(-15) * ac3;  
048C:  MOVFF  09,73
0490:  MOVFF  08,72
0494:  RCALL  0128
0496:  CLRF   x92
0498:  CLRF   x91
049A:  MOVLW  20
049C:  MOVWF  x90
049E:  MOVLW  77
04A0:  MOVWF  x8F
04A2:  MOVFF  03,96
04A6:  MOVFF  02,95
04AA:  MOVFF  01,94
04AE:  MOVFF  00,93
04B2:  RCALL  0170
04B4:  MOVFF  03,1D
04B8:  MOVFF  02,1C
04BC:  MOVFF  01,1B
04C0:  MOVFF  00,1A
....................    _c4 = 0.000000030517578125 * ac4;    // 1E-3 * pow2(-15) * ac4;  
04C4:  MOVFF  0B,7B
04C8:  MOVFF  0A,7A
04CC:  RCALL  0262
04CE:  MOVLW  6F
04D0:  MOVWF  x92
04D2:  MOVLW  12
04D4:  MOVWF  x91
04D6:  MOVLW  03
04D8:  MOVWF  x90
04DA:  MOVLW  66
04DC:  MOVWF  x8F
04DE:  MOVFF  03,96
04E2:  MOVFF  02,95
04E6:  MOVFF  01,94
04EA:  MOVFF  00,93
04EE:  RCALL  0170
04F0:  MOVFF  03,21
04F4:  MOVFF  02,20
04F8:  MOVFF  01,1F
04FC:  MOVFF  00,1E
....................    _c5 = 0.00000019073486328125 * ac5;  // (pow2(-15)/160) * ac5;  
0500:  MOVFF  0D,7B
0504:  MOVFF  0C,7A
0508:  RCALL  0262
050A:  MOVLW  CD
050C:  MOVWF  x92
050E:  MOVLW  CC
0510:  MOVWF  x91
0512:  MOVLW  4C
0514:  MOVWF  x90
0516:  MOVLW  68
0518:  MOVWF  x8F
051A:  MOVFF  03,96
051E:  MOVFF  02,95
0522:  MOVFF  01,94
0526:  MOVFF  00,93
052A:  RCALL  0170
052C:  MOVFF  03,29
0530:  MOVFF  02,28
0534:  MOVFF  01,27
0538:  MOVFF  00,26
....................    _c6 = (float)ac6;  
053C:  MOVFF  0F,7B
0540:  MOVFF  0E,7A
0544:  RCALL  0262
0546:  MOVFF  03,2D
054A:  MOVFF  02,2C
054E:  MOVFF  01,2B
0552:  MOVFF  00,2A
....................    _b1 = 0.00002384185791015625 * b1;   // 25600 * pow2(-30) * b1;  
0556:  MOVFF  11,73
055A:  MOVFF  10,72
055E:  RCALL  0128
0560:  CLRF   x92
0562:  CLRF   x91
0564:  MOVLW  48
0566:  MOVWF  x90
0568:  MOVLW  6F
056A:  MOVWF  x8F
056C:  MOVFF  03,96
0570:  MOVFF  02,95
0574:  MOVFF  01,94
0578:  MOVFF  00,93
057C:  RCALL  0170
057E:  MOVFF  03,25
0582:  MOVFF  02,24
0586:  MOVFF  01,23
058A:  MOVFF  00,22
....................    _mc = 0.08 * mc;                     // (pow2(11) / 25600) * mc;  
058E:  MOVFF  17,73
0592:  MOVFF  16,72
0596:  RCALL  0128
0598:  MOVLW  0A
059A:  MOVWF  x92
059C:  MOVLW  D7
059E:  MOVWF  x91
05A0:  MOVLW  23
05A2:  MOVWF  x90
05A4:  MOVLW  7B
05A6:  MOVWF  x8F
05A8:  MOVFF  03,96
05AC:  MOVFF  02,95
05B0:  MOVFF  01,94
05B4:  MOVFF  00,93
05B8:  RCALL  0170
05BA:  MOVFF  03,31
05BE:  MOVFF  02,30
05C2:  MOVFF  01,2F
05C6:  MOVFF  00,2E
....................    _md = (float)md / 160;  
05CA:  MOVFF  19,73
05CE:  MOVFF  18,72
05D2:  RCALL  0128
05D4:  MOVFF  03,75
05D8:  MOVFF  02,74
05DC:  MOVFF  01,73
05E0:  MOVFF  00,72
05E4:  MOVFF  03,92
05E8:  MOVFF  02,91
05EC:  MOVFF  01,90
05F0:  MOVFF  00,8F
05F4:  CLRF   x96
05F6:  CLRF   x95
05F8:  MOVLW  20
05FA:  MOVWF  x94
05FC:  MOVLW  86
05FE:  MOVWF  x93
0600:  RCALL  0298
0602:  MOVFF  03,35
0606:  MOVFF  02,34
060A:  MOVFF  01,33
060E:  MOVFF  00,32
....................      
....................    // calculate polynomial constants  
....................    _x0 = (float)ac1;  
0612:  MOVFF  05,73
0616:  MOVFF  04,72
061A:  RCALL  0128
061C:  MOVFF  03,39
0620:  MOVFF  02,38
0624:  MOVFF  01,37
0628:  MOVFF  00,36
....................    _x1 = 0.01953125 * ac2;             // 160 * pow2(-13) * ac2;  
062C:  MOVFF  07,73
0630:  MOVFF  06,72
0634:  RCALL  0128
0636:  CLRF   x92
0638:  CLRF   x91
063A:  MOVLW  20
063C:  MOVWF  x90
063E:  MOVLW  79
0640:  MOVWF  x8F
0642:  MOVFF  03,96
0646:  MOVFF  02,95
064A:  MOVFF  01,94
064E:  MOVFF  00,93
0652:  RCALL  0170
0654:  MOVFF  03,3D
0658:  MOVFF  02,3C
065C:  MOVFF  01,3B
0660:  MOVFF  00,3A
....................    _x2 = 0.000762939453125 * b2;       // 25600 * pow2(-25) * b2;  
0664:  MOVFF  13,73
0668:  MOVFF  12,72
066C:  RCALL  0128
066E:  CLRF   x92
0670:  CLRF   x91
0672:  MOVLW  48
0674:  MOVWF  x90
0676:  MOVLW  74
0678:  MOVWF  x8F
067A:  MOVFF  03,96
067E:  MOVFF  02,95
0682:  MOVFF  01,94
0686:  MOVFF  00,93
068A:  RCALL  0170
068C:  MOVFF  03,41
0690:  MOVFF  02,40
0694:  MOVFF  01,3F
0698:  MOVFF  00,3E
....................    _y0 = _c4 * 32768;                  //_c4 * pow2(15);  
069C:  MOVFF  21,92
06A0:  MOVFF  20,91
06A4:  MOVFF  1F,90
06A8:  MOVFF  1E,8F
06AC:  CLRF   x96
06AE:  CLRF   x95
06B0:  CLRF   x94
06B2:  MOVLW  8E
06B4:  MOVWF  x93
06B6:  RCALL  0170
06B8:  MOVFF  03,45
06BC:  MOVFF  02,44
06C0:  MOVFF  01,43
06C4:  MOVFF  00,42
....................    _y1 = _c4 * _c3;  
06C8:  MOVFF  21,92
06CC:  MOVFF  20,91
06D0:  MOVFF  1F,90
06D4:  MOVFF  1E,8F
06D8:  MOVFF  1D,96
06DC:  MOVFF  1C,95
06E0:  MOVFF  1B,94
06E4:  MOVFF  1A,93
06E8:  RCALL  0170
06EA:  MOVFF  03,49
06EE:  MOVFF  02,48
06F2:  MOVFF  01,47
06F6:  MOVFF  00,46
....................    _y2 = _c4 * _b1;  
06FA:  MOVFF  21,92
06FE:  MOVFF  20,91
0702:  MOVFF  1F,90
0706:  MOVFF  1E,8F
070A:  MOVFF  25,96
070E:  MOVFF  24,95
0712:  MOVFF  23,94
0716:  MOVFF  22,93
071A:  RCALL  0170
071C:  MOVFF  03,4D
0720:  MOVFF  02,4C
0724:  MOVFF  01,4B
0728:  MOVFF  00,4A
....................    _p0 = 2.364375;   
072C:  MOVLW  EC
072E:  MOVWF  51
0730:  MOVLW  51
0732:  MOVWF  50
0734:  MOVLW  17
0736:  MOVWF  4F
0738:  MOVLW  80
073A:  MOVWF  4E
....................    _p1 = 0.992984;  
073C:  MOVLW  33
073E:  MOVWF  55
0740:  MOVLW  34
0742:  MOVWF  54
0744:  MOVLW  7E
0746:  MOVWF  53
0748:  MOVWF  52
....................    _p2 = 0.000004421;     
074A:  MOVLW  1A
074C:  MOVWF  59
074E:  MOVLW  58
0750:  MOVWF  58
0752:  MOVLW  14
0754:  MOVWF  57
0756:  MOVLW  6D
0758:  MOVWF  56
075A:  GOTO   142C (RETURN)
.................... }  
....................  
....................  
.................... // Read the uncompensated temperature value  
.................... //----------------------------------------------  
.................... int16 BMP085ReadUT()  
.................... //----------------------------------------------  
.................... {  
.................... int16 ut;  
....................    
....................   // Write 0x2E into Register 0xF4  
....................   BMP085WriteByte(0xF4, 0x2E);  
*
07F8:  MOVLW  F4
07FA:  MOVWF  x7A
07FC:  MOVLW  2E
07FE:  MOVWF  x7B
0800:  RCALL  075E
....................   delay_ms(5); // Wait at least 4.5ms  
0802:  MOVLW  05
0804:  MOVWF  x7A
0806:  RCALL  0798
....................   // Read two bytes from registers 0xF6 and 0xF7  
....................   ut = BMP085ReadInt(0xF6);  
0808:  MOVLW  F6
080A:  MOVWF  x75
080C:  RCALL  00B6
080E:  MOVFF  02,74
0812:  MOVFF  01,73
....................   return((float)ut);  
0816:  MOVFF  74,7B
081A:  MOVFF  73,7A
081E:  RCALL  0262
0820:  MOVFF  03,78
0824:  MOVFF  02,77
0828:  MOVFF  01,76
082C:  MOVFF  00,75
0830:  BRA    07BE
0832:  MOVF   02,W
0834:  RETURN 0
.................... }  
....................  
....................  
.................... // Read the uncompensated pressure value  
.................... //----------------------------------------------  
.................... int32 bmp085ReadUP()  
.................... //----------------------------------------------  
.................... {  
.................... int8 msb, lsb, xlsb;  
.................... float p;  
....................    
....................   // Write 0x34+(OSS<<6) into register 0xF4  
....................   // Request a pressure reading w/ oversampling setting  
....................   BMP085WriteByte(0xF4, (0x34 + (OVS_S<<6)) );  
*
0C58:  MOVLW  F4
0C5A:  MOVWF  x7A
0C5C:  MOVWF  x7B
0C5E:  RCALL  075E
....................    
....................   // Wait for conversion, delay time dependent on OSS  
....................   switch (OVS_S)  
....................   {  
....................      case 0: delay_ms(5);  break;  
....................      case 1: delay_ms(8);  break;  
....................      case 2: delay_ms(14); break;  
....................      case 3: delay_ms(26); break;  
0C60:  MOVLW  1A
0C62:  MOVWF  x7A
0C64:  RCALL  0798
....................   }     
....................    
....................   // Read register 0xF6 (MSB), 0xF7 (LSB), and 0xF8 (XLSB)  
....................    msb  = BMP085ReadByte(0xF6);  
0C66:  MOVLW  F6
0C68:  MOVWF  x7A
0C6A:  RCALL  0BB6
0C6C:  MOVFF  01,73
....................    lsb  = BMP085ReadByte(0xF7);  
0C70:  MOVLW  F7
0C72:  MOVWF  x7A
0C74:  RCALL  0BB6
0C76:  MOVFF  01,74
....................    xlsb = BMP085ReadByte(0xF8);  
0C7A:  MOVLW  F8
0C7C:  MOVWF  x7A
0C7E:  RCALL  0BB6
0C80:  MOVFF  01,75
....................    p = (256*msb) + lsb + (xlsb/256);  
0C84:  CLRF   03
0C86:  MOVFF  73,7B
0C8A:  CLRF   x7A
0C8C:  MOVF   x74,W
0C8E:  ADDWF  x7A,F
0C90:  MOVLW  00
0C92:  ADDWFC x7B,F
0C94:  CLRF   03
0C96:  ADDWF  x7A,W
0C98:  MOVWF  01
0C9A:  MOVF   x7B,W
0C9C:  ADDWFC 03,F
0C9E:  MOVFF  01,7A
0CA2:  MOVFF  03,7B
0CA6:  CALL   0262
0CAA:  MOVFF  03,79
0CAE:  MOVFF  02,78
0CB2:  MOVFF  01,77
0CB6:  MOVFF  00,76
....................    return(p);  
0CBA:  MOVFF  79,82
0CBE:  MOVFF  78,81
0CC2:  MOVFF  77,80
0CC6:  MOVFF  76,7F
0CCA:  RCALL  0C1A
0CCC:  GOTO   10DA (RETURN)
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085GetTemp(float _tu)  
.................... //----------------------------------------------  
.................... {  
.................... float alpha, T;  
....................  
....................    alpha = _c5 * (_tu - _c6);  
*
0AA0:  BSF    FD8.1
0AA2:  MOVFF  7A,92
0AA6:  MOVFF  79,91
0AAA:  MOVFF  78,90
0AAE:  MOVFF  77,8F
0AB2:  MOVFF  2D,96
0AB6:  MOVFF  2C,95
0ABA:  MOVFF  2B,94
0ABE:  MOVFF  2A,93
0AC2:  RCALL  0836
0AC4:  MOVFF  29,92
0AC8:  MOVFF  28,91
0ACC:  MOVFF  27,90
0AD0:  MOVFF  26,8F
0AD4:  MOVFF  03,96
0AD8:  MOVFF  02,95
0ADC:  MOVFF  01,94
0AE0:  MOVFF  00,93
0AE4:  CALL   0170
0AE8:  MOVFF  03,7E
0AEC:  MOVFF  02,7D
0AF0:  MOVFF  01,7C
0AF4:  MOVFF  00,7B
....................    T = alpha + (_mc/(alpha + _md));  
0AF8:  BCF    FD8.1
0AFA:  MOVFF  7E,92
0AFE:  MOVFF  7D,91
0B02:  MOVFF  7C,90
0B06:  MOVFF  7B,8F
0B0A:  MOVFF  35,96
0B0E:  MOVFF  34,95
0B12:  MOVFF  33,94
0B16:  MOVFF  32,93
0B1A:  RCALL  0836
0B1C:  MOVFF  31,92
0B20:  MOVFF  30,91
0B24:  MOVFF  2F,90
0B28:  MOVFF  2E,8F
0B2C:  MOVFF  03,96
0B30:  MOVFF  02,95
0B34:  MOVFF  01,94
0B38:  MOVFF  00,93
0B3C:  CALL   0298
0B40:  BCF    FD8.1
0B42:  MOVFF  7E,92
0B46:  MOVFF  7D,91
0B4A:  MOVFF  7C,90
0B4E:  MOVFF  7B,8F
0B52:  MOVFF  03,96
0B56:  MOVFF  02,95
0B5A:  MOVFF  01,94
0B5E:  MOVFF  00,93
0B62:  RCALL  0836
0B64:  MOVFF  03,82
0B68:  MOVFF  02,81
0B6C:  MOVFF  01,80
0B70:  MOVFF  00,7F
....................    _s = T - 25;  
0B74:  BSF    FD8.1
0B76:  MOVFF  82,92
0B7A:  MOVFF  81,91
0B7E:  MOVFF  80,90
0B82:  MOVFF  7F,8F
0B86:  CLRF   x96
0B88:  CLRF   x95
0B8A:  MOVLW  48
0B8C:  MOVWF  x94
0B8E:  MOVLW  83
0B90:  MOVWF  x93
0B92:  RCALL  0836
0B94:  MOVFF  03,5D
0B98:  MOVFF  02,5C
0B9C:  MOVFF  01,5B
0BA0:  MOVFF  00,5A
....................    return(T);  
0BA4:  MOVFF  7F,00
0BA8:  MOVFF  80,01
0BAC:  MOVFF  81,02
0BB0:  MOVFF  82,03
0BB4:  RETURN 0
.................... }     
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085GetPressure(float _pu)  
.................... //----------------------------------------------  
.................... {  
.................... float x, y, z;  
.................... float P;  
....................  
....................    x = _x2*_s*_s + _x1*_s + _x0;  
*
0D06:  MOVFF  41,92
0D0A:  MOVFF  40,91
0D0E:  MOVFF  3F,90
0D12:  MOVFF  3E,8F
0D16:  MOVFF  5D,96
0D1A:  MOVFF  5C,95
0D1E:  MOVFF  5B,94
0D22:  MOVFF  5A,93
0D26:  CALL   0170
0D2A:  MOVFF  03,8E
0D2E:  MOVFF  02,8D
0D32:  MOVFF  01,8C
0D36:  MOVFF  00,8B
0D3A:  MOVFF  03,92
0D3E:  MOVFF  02,91
0D42:  MOVFF  01,90
0D46:  MOVFF  00,8F
0D4A:  MOVFF  5D,96
0D4E:  MOVFF  5C,95
0D52:  MOVFF  5B,94
0D56:  MOVFF  5A,93
0D5A:  CALL   0170
0D5E:  MOVFF  03,8E
0D62:  MOVFF  02,8D
0D66:  MOVFF  01,8C
0D6A:  MOVFF  00,8B
0D6E:  MOVFF  3D,92
0D72:  MOVFF  3C,91
0D76:  MOVFF  3B,90
0D7A:  MOVFF  3A,8F
0D7E:  MOVFF  5D,96
0D82:  MOVFF  5C,95
0D86:  MOVFF  5B,94
0D8A:  MOVFF  5A,93
0D8E:  CALL   0170
0D92:  BCF    FD8.1
0D94:  MOVFF  8E,92
0D98:  MOVFF  8D,91
0D9C:  MOVFF  8C,90
0DA0:  MOVFF  8B,8F
0DA4:  MOVFF  03,96
0DA8:  MOVFF  02,95
0DAC:  MOVFF  01,94
0DB0:  MOVFF  00,93
0DB4:  RCALL  0836
0DB6:  MOVFF  03,8E
0DBA:  MOVFF  02,8D
0DBE:  MOVFF  01,8C
0DC2:  MOVFF  00,8B
0DC6:  BCF    FD8.1
0DC8:  MOVFF  03,92
0DCC:  MOVFF  02,91
0DD0:  MOVFF  01,90
0DD4:  MOVFF  00,8F
0DD8:  MOVFF  39,96
0DDC:  MOVFF  38,95
0DE0:  MOVFF  37,94
0DE4:  MOVFF  36,93
0DE8:  RCALL  0836
0DEA:  MOVFF  03,7E
0DEE:  MOVFF  02,7D
0DF2:  MOVFF  01,7C
0DF6:  MOVFF  00,7B
....................    y = _y2*_s*_s + _y1*_s + _y0;  
0DFA:  MOVFF  4D,92
0DFE:  MOVFF  4C,91
0E02:  MOVFF  4B,90
0E06:  MOVFF  4A,8F
0E0A:  MOVFF  5D,96
0E0E:  MOVFF  5C,95
0E12:  MOVFF  5B,94
0E16:  MOVFF  5A,93
0E1A:  CALL   0170
0E1E:  MOVFF  03,8E
0E22:  MOVFF  02,8D
0E26:  MOVFF  01,8C
0E2A:  MOVFF  00,8B
0E2E:  MOVFF  03,92
0E32:  MOVFF  02,91
0E36:  MOVFF  01,90
0E3A:  MOVFF  00,8F
0E3E:  MOVFF  5D,96
0E42:  MOVFF  5C,95
0E46:  MOVFF  5B,94
0E4A:  MOVFF  5A,93
0E4E:  CALL   0170
0E52:  MOVFF  03,8E
0E56:  MOVFF  02,8D
0E5A:  MOVFF  01,8C
0E5E:  MOVFF  00,8B
0E62:  MOVFF  49,92
0E66:  MOVFF  48,91
0E6A:  MOVFF  47,90
0E6E:  MOVFF  46,8F
0E72:  MOVFF  5D,96
0E76:  MOVFF  5C,95
0E7A:  MOVFF  5B,94
0E7E:  MOVFF  5A,93
0E82:  CALL   0170
0E86:  BCF    FD8.1
0E88:  MOVFF  8E,92
0E8C:  MOVFF  8D,91
0E90:  MOVFF  8C,90
0E94:  MOVFF  8B,8F
0E98:  MOVFF  03,96
0E9C:  MOVFF  02,95
0EA0:  MOVFF  01,94
0EA4:  MOVFF  00,93
0EA8:  RCALL  0836
0EAA:  MOVFF  03,8E
0EAE:  MOVFF  02,8D
0EB2:  MOVFF  01,8C
0EB6:  MOVFF  00,8B
0EBA:  BCF    FD8.1
0EBC:  MOVFF  03,92
0EC0:  MOVFF  02,91
0EC4:  MOVFF  01,90
0EC8:  MOVFF  00,8F
0ECC:  MOVFF  45,96
0ED0:  MOVFF  44,95
0ED4:  MOVFF  43,94
0ED8:  MOVFF  42,93
0EDC:  RCALL  0836
0EDE:  MOVFF  03,82
0EE2:  MOVFF  02,81
0EE6:  MOVFF  01,80
0EEA:  MOVFF  00,7F
....................    z = ((float)_pu - x) / y;  
0EEE:  BSF    FD8.1
0EF0:  MOVFF  7A,92
0EF4:  MOVFF  79,91
0EF8:  MOVFF  78,90
0EFC:  MOVFF  77,8F
0F00:  MOVFF  7E,96
0F04:  MOVFF  7D,95
0F08:  MOVFF  7C,94
0F0C:  MOVFF  7B,93
0F10:  RCALL  0836
0F12:  MOVFF  03,8E
0F16:  MOVFF  02,8D
0F1A:  MOVFF  01,8C
0F1E:  MOVFF  00,8B
0F22:  MOVFF  03,92
0F26:  MOVFF  02,91
0F2A:  MOVFF  01,90
0F2E:  MOVFF  00,8F
0F32:  MOVFF  82,96
0F36:  MOVFF  81,95
0F3A:  MOVFF  80,94
0F3E:  MOVFF  7F,93
0F42:  CALL   0298
0F46:  MOVFF  03,86
0F4A:  MOVFF  02,85
0F4E:  MOVFF  01,84
0F52:  MOVFF  00,83
....................    P = _p2*z*z + _p1*z + _p0;  
0F56:  MOVFF  59,92
0F5A:  MOVFF  58,91
0F5E:  MOVFF  57,90
0F62:  MOVFF  56,8F
0F66:  MOVFF  86,96
0F6A:  MOVFF  85,95
0F6E:  MOVFF  84,94
0F72:  MOVFF  83,93
0F76:  CALL   0170
0F7A:  MOVFF  03,8E
0F7E:  MOVFF  02,8D
0F82:  MOVFF  01,8C
0F86:  MOVFF  00,8B
0F8A:  MOVFF  03,92
0F8E:  MOVFF  02,91
0F92:  MOVFF  01,90
0F96:  MOVFF  00,8F
0F9A:  MOVFF  86,96
0F9E:  MOVFF  85,95
0FA2:  MOVFF  84,94
0FA6:  MOVFF  83,93
0FAA:  CALL   0170
0FAE:  MOVFF  03,8E
0FB2:  MOVFF  02,8D
0FB6:  MOVFF  01,8C
0FBA:  MOVFF  00,8B
0FBE:  MOVFF  55,92
0FC2:  MOVFF  54,91
0FC6:  MOVFF  53,90
0FCA:  MOVFF  52,8F
0FCE:  MOVFF  86,96
0FD2:  MOVFF  85,95
0FD6:  MOVFF  84,94
0FDA:  MOVFF  83,93
0FDE:  CALL   0170
0FE2:  BCF    FD8.1
0FE4:  MOVFF  8E,92
0FE8:  MOVFF  8D,91
0FEC:  MOVFF  8C,90
0FF0:  MOVFF  8B,8F
0FF4:  MOVFF  03,96
0FF8:  MOVFF  02,95
0FFC:  MOVFF  01,94
1000:  MOVFF  00,93
1004:  RCALL  0836
1006:  MOVFF  03,8E
100A:  MOVFF  02,8D
100E:  MOVFF  01,8C
1012:  MOVFF  00,8B
1016:  BCF    FD8.1
1018:  MOVFF  03,92
101C:  MOVFF  02,91
1020:  MOVFF  01,90
1024:  MOVFF  00,8F
1028:  MOVFF  51,96
102C:  MOVFF  50,95
1030:  MOVFF  4F,94
1034:  MOVFF  4E,93
1038:  CALL   0836
103C:  MOVFF  03,8A
1040:  MOVFF  02,89
1044:  MOVFF  01,88
1048:  MOVFF  00,87
....................    P += P_CORRECTION;  
104C:  BCF    FD8.1
104E:  MOVFF  8A,92
1052:  MOVFF  89,91
1056:  MOVFF  88,90
105A:  MOVFF  87,8F
105E:  CLRF   x96
1060:  CLRF   x95
1062:  MOVLW  40
1064:  MOVWF  x94
1066:  MOVLW  7F
1068:  MOVWF  x93
106A:  CALL   0836
106E:  MOVFF  03,8A
1072:  MOVFF  02,89
1076:  MOVFF  01,88
107A:  MOVFF  00,87
....................    return(P);  
107E:  MOVFF  87,00
1082:  MOVFF  88,01
1086:  MOVFF  89,02
108A:  MOVFF  8A,03
108E:  GOTO   110E (RETURN)
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085Pressure(boolean getTemp)  
.................... //----------------------------------------------  
.................... {  
....................    if (getTemp)  
1092:  MOVF   x72,F
1094:  BZ    10D8
....................       _Temp = BMP085GetTemp(BMP085ReadUT());  // creates _s required for pressure calculation  
1096:  CALL   07F8
109A:  MOVFF  02,7B
109E:  MOVFF  01,7A
10A2:  CALL   0262
10A6:  MOVFF  03,76
10AA:  MOVFF  02,75
10AE:  MOVFF  01,74
10B2:  MOVFF  00,73
10B6:  MOVFF  03,7A
10BA:  MOVFF  02,79
10BE:  MOVFF  01,78
10C2:  MOVFF  00,77
10C6:  RCALL  0AA0
10C8:  MOVFF  03,61
10CC:  MOVFF  02,60
10D0:  MOVFF  01,5F
10D4:  MOVFF  00,5E
....................    return(BMP085GetPressure(BMP085ReadUP()));  
10D8:  BRA    0C58
10DA:  MOVFF  03,76
10DE:  MOVFF  02,75
10E2:  MOVFF  01,74
10E6:  MOVFF  00,73
10EA:  BRA    0CD0
10EC:  MOVFF  03,76
10F0:  MOVFF  02,75
10F4:  MOVFF  01,74
10F8:  MOVFF  00,73
10FC:  MOVFF  03,7A
1100:  MOVFF  02,79
1104:  MOVFF  01,78
1108:  MOVFF  00,77
110C:  BRA    0D06
110E:  GOTO   1432 (RETURN)
.................... }  
....................  
....................  
.................... //----------------------------------------------  
.................... float BMP085Temperature(void)  
.................... //----------------------------------------------  
.................... {  
....................    _Temp = BMP085GetTemp(BMP085ReadUT());  
1112:  CALL   07F8
1116:  MOVFF  02,7B
111A:  MOVFF  01,7A
111E:  CALL   0262
1122:  MOVFF  03,75
1126:  MOVFF  02,74
112A:  MOVFF  01,73
112E:  MOVFF  00,72
1132:  MOVFF  03,7A
1136:  MOVFF  02,79
113A:  MOVFF  01,78
113E:  MOVFF  00,77
1142:  RCALL  0AA0
1144:  MOVFF  03,61
1148:  MOVFF  02,60
114C:  MOVFF  01,5F
1150:  MOVFF  00,5E
....................    return(_Temp);  
1154:  MOVFF  5E,00
1158:  MOVFF  5F,01
115C:  MOVFF  60,02
1160:  MOVFF  61,03
1164:  GOTO   1444 (RETURN)
.................... }  
....................  
.................... float a,b,c,d; 
....................  
.................... void main(){ 
*
140E:  CLRF   FF8
1410:  BCF    FD0.7
1412:  MOVLW  70
1414:  MOVWF  FD3
1416:  MOVF   FD3,W
1418:  BCF    F92.3
141A:  BSF    F89.3
141C:  MOVF   FC1,W
141E:  ANDLW  C0
1420:  IORLW  0F
1422:  MOVWF  FC1
1424:  MOVLW  07
1426:  MOVWF  FB4
....................    bmp085Calibration(); 
1428:  GOTO   03F2
....................    while(true){ 
....................       a = BMP085Pressure(true);  //  calls for temperature first 
142C:  MOVLW  01
142E:  MOVWF  x72
1430:  BRA    1092
1432:  MOVFF  03,65
1436:  MOVFF  02,64
143A:  MOVFF  01,63
143E:  MOVFF  00,62
....................       b = BMP085Temperature();  
1442:  BRA    1112
1444:  MOVFF  03,69
1448:  MOVFF  02,68
144C:  MOVFF  01,67
1450:  MOVFF  00,66
....................        
....................       printf("T[c]: %.3g  \n\r",b); 
1454:  MOVLW  04
1456:  MOVWF  FF6
1458:  MOVLW  00
145A:  MOVWF  FF7
145C:  MOVLW  06
145E:  MOVWF  x72
1460:  RCALL  11A6
1462:  MOVLW  89
1464:  MOVWF  FE9
1466:  MOVFF  69,75
146A:  MOVFF  68,74
146E:  MOVFF  67,73
1472:  MOVFF  66,72
1476:  MOVLW  03
1478:  MOVWF  x76
147A:  RCALL  1252
147C:  MOVLW  0E
147E:  MOVWF  FF6
1480:  MOVLW  00
1482:  MOVWF  FF7
1484:  MOVLW  04
1486:  MOVWF  x72
1488:  RCALL  11A6
....................       printf("P[c]: %.3g  \n\r\n\r",a); 
148A:  MOVLW  14
148C:  MOVWF  FF6
148E:  MOVLW  00
1490:  MOVWF  FF7
1492:  MOVLW  06
1494:  MOVWF  x72
1496:  RCALL  11A6
1498:  MOVLW  89
149A:  MOVWF  FE9
149C:  MOVFF  65,75
14A0:  MOVFF  64,74
14A4:  MOVFF  63,73
14A8:  MOVFF  62,72
14AC:  MOVLW  03
14AE:  MOVWF  x76
14B0:  RCALL  1252
14B2:  MOVLW  1E
14B4:  MOVWF  FF6
14B6:  MOVLW  00
14B8:  MOVWF  FF7
14BA:  MOVLW  06
14BC:  MOVWF  x72
14BE:  RCALL  11A6
....................       delay_ms(500); 
14C0:  MOVLW  02
14C2:  MOVWF  x72
14C4:  MOVLW  FA
14C6:  MOVWF  x7A
14C8:  CALL   0798
14CC:  DECFSZ x72,F
14CE:  BRA    14C4
14D0:  BRA    142C
....................    } 
.................... } 
14D2:  SLEEP 

Configuration Fuses:
   Word  1: C827   PLL12 CPUDIV1 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
